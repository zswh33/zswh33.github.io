<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>uwupu Blog</title>
  
  <subtitle>学习日志</subtitle>
  <link href="http://zswh33.github.io/atom.xml" rel="self"/>
  
  <link href="http://zswh33.github.io/"/>
  <updated>2023-07-26T18:18:15.618Z</updated>
  <id>http://zswh33.github.io/</id>
  
  <author>
    <name>YN</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>人工智能 1</title>
    <link href="http://zswh33.github.io/2023/07/27/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD-1/"/>
    <id>http://zswh33.github.io/2023/07/27/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD-1/</id>
    <published>2023-07-26T17:52:42.000Z</published>
    <updated>2023-07-26T18:18:15.618Z</updated>
    
    <content type="html"><![CDATA[<h1 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h1><ol><li>获取数据</li><li>数据基本处理</li><li>特征工程</li><li>机器学习（模型训练）</li><li>模型评估</li></ol><h1 id="数据集介绍"><a href="#数据集介绍" class="headerlink" title="数据集介绍"></a>数据集介绍</h1><ol><li><p>专有名词</p><p>样本，特征，目标值（标签值），特征值</p></li><li><p>数据类型构成</p><ol><li>特征值 + 目标值<ul><li>目标值可以是<strong>分散</strong>和<strong>连续</strong>两种情况</li></ul></li><li>只有<strong>特征值</strong>，没有目标值</li></ol></li><li><p>数据分割</p><ul><li>机器学习一般将数据集分为两部分<ul><li>训练数据：用于训练和构建模型</li><li>测试数据：检验模型，评估模型是否有效</li></ul></li><li>划分比例<ul><li>训练集：70% 80% 75%</li><li>测试集：30% 20% 25%</li></ul></li></ul></li></ol><h1 id="特征工程"><a href="#特征工程" class="headerlink" title="特征工程"></a>特征工程</h1><h2 id="什么是特征工程"><a href="#什么是特征工程" class="headerlink" title="什么是特征工程"></a>什么是特征工程</h2><p>特征工程师使用专业背景知识和技巧处理数据，使得特征能在机器学习算法上发挥更好的作用的过程。</p><h2 id="特征工程包含内容"><a href="#特征工程包含内容" class="headerlink" title="特征工程包含内容"></a>特征工程包含内容</h2><ul><li>特征提取：将任意数据（如文本或图像）转换为可用于机器学习的数字特征。</li><li>特征预处理：通过一些转换函数将特征数据转换成更加适合算法模型的特征数据过程。</li><li>特征降维：在某些限定条件下，<strong>降低随机变量（特征）的个数</strong>，得到一组“不相关“主变量的过程</li></ul><h1 id="完整机械学习流程"><a href="#完整机械学习流程" class="headerlink" title="完整机械学习流程"></a>完整机械学习流程</h1><p><img src="/2023/07/27/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD-1/YN\hexo\source_posts\人工智能-1\image-20230727021501797.png" alt="image-20230727021501797"></p><p><img src="/2023/07/27/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD-1/YN\hexo\source_posts\人工智能-1\image-20230727021550628.png" alt="image-20230727021550628"></p><p><img src="/2023/07/27/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD-1/YN\hexo\source_posts\人工智能-1\image-20230727021658371.png" alt="image-20230727021658371"></p><p><img src="/2023/07/27/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD-1/YN\hexo\source_posts\人工智能-1\image-20230727021725735.png" alt="image-20230727021725735"></p><p><img src="/2023/07/27/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD-1/YN\hexo\source_posts\人工智能-1\image-20230727021754655.png" alt="image-20230727021754655"></p><p><img src="/2023/07/27/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD-1/YN\hexo\source_posts\人工智能-1\image-20230727021814881.png" alt="image-20230727021814881"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;工作流程&quot;&gt;&lt;a href=&quot;#工作流程&quot; class=&quot;headerlink&quot; title=&quot;工作流程&quot;&gt;&lt;/a&gt;工作流程&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;获取数据&lt;/li&gt;
&lt;li&gt;数据基本处理&lt;/li&gt;
&lt;li&gt;特征工程&lt;/li&gt;
&lt;li&gt;机器学习（模型训练）&lt;/</summary>
      
    
    
    
    
    <category term="人工智能" scheme="http://zswh33.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>为jar包签名，并验证签名。</title>
    <link href="http://zswh33.github.io/2023/05/11/%E4%B8%BAjar%E5%8C%85%E7%AD%BE%E5%90%8D%EF%BC%8C%E5%B9%B6%E9%AA%8C%E8%AF%81%E7%AD%BE%E5%90%8D%E3%80%82/"/>
    <id>http://zswh33.github.io/2023/05/11/%E4%B8%BAjar%E5%8C%85%E7%AD%BE%E5%90%8D%EF%BC%8C%E5%B9%B6%E9%AA%8C%E8%AF%81%E7%AD%BE%E5%90%8D%E3%80%82/</id>
    <published>2023-05-11T15:26:37.000Z</published>
    <updated>2023-05-12T15:20:07.470Z</updated>
    
    <content type="html"><![CDATA[<h1 id="keytool生成密钥对"><a href="#keytool生成密钥对" class="headerlink" title="keytool生成密钥对"></a>keytool生成密钥对</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -genkeypair -<span class="built_in">alias</span> KEYALIAS -keyalg RSA -keysize 2048 -validity 36500 -keystore FILE.jks</span><br></pre></td></tr></table></figure><ul><li>alias 指定密钥对别名</li><li>keyalg 指定算法</li><li>keysize 指定密钥大小</li><li>validity 证书有效期</li><li>keystore 密钥库文件名称</li></ul><h1 id="jarsigner数字签名以及验证"><a href="#jarsigner数字签名以及验证" class="headerlink" title="jarsigner数字签名以及验证"></a>jarsigner数字签名以及验证</h1><blockquote><p>进行数字签名</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jarsigner -keystore FILE.jks JARFILE.jar KEYALIAS</span><br></pre></td></tr></table></figure><ul><li>keystore 指定密钥库文件名</li><li>JARFILE.jar 指定要签名的Jar文件名称</li><li>KEYALIAS 是密钥库中密钥对的别称</li></ul><blockquote><p>验证数字签名</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jarsigner -verify JARFILE.jar -keystore FILE.jks</span><br></pre></td></tr></table></figure><h1 id="Java中使用Security-API对jar文件进行验证"><a href="#Java中使用Security-API对jar文件进行验证" class="headerlink" title="Java中使用Security API对jar文件进行验证"></a>Java中使用Security API对jar文件进行验证</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;keytool生成密钥对&quot;&gt;&lt;a href=&quot;#keytool生成密钥对&quot; class=&quot;headerlink&quot; title=&quot;keytool生成密钥对&quot;&gt;&lt;/a&gt;keytool生成密钥对&lt;/h1&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;t</summary>
      
    
    
    
    
    <category term="jar" scheme="http://zswh33.github.io/tags/jar/"/>
    
    <category term="java" scheme="http://zswh33.github.io/tags/java/"/>
    
    <category term="加密" scheme="http://zswh33.github.io/tags/%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud 1</title>
    <link href="http://zswh33.github.io/2023/05/10/SpringCloud-1/"/>
    <id>http://zswh33.github.io/2023/05/10/SpringCloud-1/</id>
    <published>2023-05-10T15:20:57.000Z</published>
    <updated>2023-05-10T15:20:57.446Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Job Study 3 String</title>
    <link href="http://zswh33.github.io/2023/04/29/Job-Study-3-String/"/>
    <id>http://zswh33.github.io/2023/04/29/Job-Study-3-String/</id>
    <published>2023-04-29T08:37:36.000Z</published>
    <updated>2023-04-29T09:40:53.960Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a href="https://juejin.cn/post/7226157821708648509">https://juejin.cn/post/7226157821708648509</a></p><p>[2] <a href="https://blog.csdn.net/hl_java/article/details/104352925">https://blog.csdn.net/hl_java/article/details/104352925</a></p><h1 id="final修饰String类"><a href="#final修饰String类" class="headerlink" title="final修饰String类"></a>final修饰String类</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence,</span><br><span class="line">               Constable, ConstantDesc</span><br></pre></td></tr></table></figure><ul><li>final：表示String类不可被继承</li><li>String字符串是常量，一旦被创建，不可改变</li><li>String字符串缓冲区支持可变字符串</li><li>因为String不可变，即String可共享。</li></ul><h1 id="final修饰的value"><a href="#final修饰的value" class="headerlink" title="final修饰的value[]"></a>final修饰的value[]</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span>[] value;</span><br></pre></td></tr></table></figure><ul><li>value是一个私有的字符数组，String通过这个value保存字符串内容。</li><li>由final修饰，不可修改。</li></ul><h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><p>Java中使用字符串常量池存储字符串字面量。</p><ul><li>由于JDK版本不同，常量池位置也不同<ul><li>JDK6及以下字符串常量池在方法区（perm Gen）中，此时常量池存储字符串对象。</li><li>在JDK8中，方法区（永久代被元空间取代）。</li><li>JDK7，8中，字符串常量池被转移到堆中，此时常量池存储字符串对象的引用，而不是字符串对象本身。</li></ul></li></ul><h1 id="不可变性的优点"><a href="#不可变性的优点" class="headerlink" title="不可变性的优点"></a>不可变性的优点</h1><ul><li>只有当字符串不可变，字符串池才可实现。字符串池可以节省很多heap空间，因为不同的字符串引用都可以指向池中同一个字符串。</li><li>（存疑）如果字符串可变，可能会引起严重的安全问题。</li><li>字符串不可变，使得同一个字符串实例可以被多个线程共享。</li><li>字符串不可变，在字符串对象创建的时候，hashCode就被执行并把结果缓存，每次使用hashCode不需要重新计算。字符串变得很容易去成为Map的键。</li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li>丧失灵活性。可以通过StringBuilder弥补这个缺点。</li><li>脆弱的不可变性。String可以通过JNI或反射来改变其不可变性。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;参考文献&quot;&gt;&lt;a href=&quot;#参考文献&quot; class=&quot;headerlink&quot; title=&quot;参考文献&quot;&gt;&lt;/a&gt;参考文献&lt;/h1&gt;&lt;p&gt;[1] &lt;a href=&quot;https://juejin.cn/post/7226157821708648509&quot;&gt;https</summary>
      
    
    
    
    
    <category term="Java" scheme="http://zswh33.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Job Study 2</title>
    <link href="http://zswh33.github.io/2023/04/29/Job-Study-2/"/>
    <id>http://zswh33.github.io/2023/04/29/Job-Study-2/</id>
    <published>2023-04-29T07:05:55.000Z</published>
    <updated>2023-04-29T10:58:41.360Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a href="https://cloud.tencent.com/developer/article/1872211">https://cloud.tencent.com/developer/article/1872211</a></p><h1 id="Java语言特点"><a href="#Java语言特点" class="headerlink" title="Java语言特点"></a>Java语言特点</h1><ul><li>纯面向对象的语言。</li><li>具有平台无关性。</li><li>解释型语言。（相对的是编译型语言）</li><li>很多内置类库，如多线程支持，网络通信支持，垃圾回收器。</li><li>较好的安全性和健壮性。提供异常处理和垃圾回收机制。</li></ul><h1 id="JDK和JRE区别"><a href="#JDK和JRE区别" class="headerlink" title="JDK和JRE区别"></a>JDK和JRE区别</h1><ul><li>JDK：Java Development Kit，开发工具包，提供开发环境和运行环境。</li><li>JRE：Java Runtime Environment，Java运行环境。</li><li>JDK包含了JRE。</li></ul><h1 id="Java数据类型"><a href="#Java数据类型" class="headerlink" title="Java数据类型"></a>Java数据类型</h1><ul><li><p>基本数据类型</p><ul><li><p>整数类型</p><ul><li>byte，1字节，-128 ~ 127。</li><li>short，2字节，-32768 ~ 32767。</li><li>int，4字节，-2^31 ~ 2^31-1</li><li>long，8字节，-2^63 ~ 2^63-1</li></ul></li><li><p>浮点数</p><ul><li>float，浮点数，32位，4字节</li><li>double，浮点数，64位，8字节</li></ul></li><li><p>布尔类型</p><ul><li>boolean：布尔，占用大小依据虚拟机不同有差异。<ul><li>在规范上，没有要求boolean占用多大内存。</li><li>在遵循规范的基础上，如果boolean是单独使用，boolean占用4字节。如果boolean以数组使用，则一个boolean占用1字节。</li></ul></li></ul></li><li><p>字符类型</p><ul><li>char：2字节，16位。</li></ul></li></ul></li><li><p>引用数据类型</p><ul><li>数组</li><li>对象</li></ul></li></ul><h1 id="自动装箱拆箱"><a href="#自动装箱拆箱" class="headerlink" title="自动装箱拆箱"></a>自动装箱拆箱</h1><p>对于Java基础数据类型，都有其对象的包装类。</p><p>装箱就是把基本数组类型封装为包装器类型。</p><p>拆箱就是自动将包装器类型转换为基础数据类型。</p><h1 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h1><ul><li>default：默认修饰符，同一包内可见。</li><li>private：同一类内可见</li><li>protected：同一包内的类和所有子类可见，不能修饰类。</li><li>public：所有类可见。</li></ul><h1 id="构造方法，成员变量初始化以及静态成员变量三者初始化顺序"><a href="#构造方法，成员变量初始化以及静态成员变量三者初始化顺序" class="headerlink" title="构造方法，成员变量初始化以及静态成员变量三者初始化顺序"></a>构造方法，成员变量初始化以及静态成员变量三者初始化顺序</h1><p>先后顺序：静态成员变量，成员变量，构造方法。</p><p>详细先后顺序：</p><ul><li>父类静态变量，</li><li>父类静态代码块，</li><li>子类静态变量，</li><li>子类静态代码块，</li><li>父类成员变量，父类构造方法，子类成员变量，子类构造方法。</li></ul><h1 id="面向对象三大特征"><a href="#面向对象三大特征" class="headerlink" title="面向对象三大特征"></a>面向对象三大特征</h1><ul><li><p>继承：对象新类可以从现有的类中派生，派生类可以从它的基类那继承方法和实例变量，且派生类可以修改或新增新的方法使之更适合特殊的需求。</p></li><li><p>封装：将客观事物抽象成类，每个类可以把自身数据和方法只让可信的类或对象操作，对不可信的类进行信息隐藏。</p></li><li><p>多态：允许不同类的对象对同一消息做出响应，不同对象调用相同方法即使参数也相同，最终表现行为是不一样的。</p></li></ul><h1 id="Java多态"><a href="#Java多态" class="headerlink" title="Java多态"></a>Java多态</h1><p>Java多态分为编译时多态和运行时多态。</p><p>编译时多态主要指方法的重载，即通过参数列表的不同来区分不同的方法。</p><p>运行时多态主要指继承父类和实现接口时，可以使用父类引用指向子类对象。</p><p>运行时多态表现：主要依靠方法表，放发表最先存放Object类的方法，接下来是该类父类的方法，最后是该类本身的方法。若子类改写了父类的方法，则子类和父类同名方法共享一个方法表项，都被认作是父类的方法。因此可以实现运行时多态。</p><h1 id="Java提供多态机制"><a href="#Java提供多态机制" class="headerlink" title="Java提供多态机制"></a>Java提供多态机制</h1><p>重载，同一个类有多个同名的方法，方法有不同的参数，在编译期间可以确定调用哪个方法。</p><p>覆盖：派生类重写基类的方法。父类引用指向子类对象，在运行时可以确定要调用的方法。</p><h1 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h1><ul><li>重写是父类与子类的关系。重载是同一类中方法之间的关系。</li></ul><h1 id="接口和抽象类的区别"><a href="#接口和抽象类的区别" class="headerlink" title="接口和抽象类的区别"></a>接口和抽象类的区别</h1><ul><li>相同<ul><li>都不能被实例化</li><li>接口的实现类或抽象类的子类需实现接口或抽象类中相应的方法才能被实例化。</li></ul></li><li>不同<ul><li>接口只能有方法定义，不能有方法实现。抽象类可以有方法的定义和实现。</li><li>实现接口implement，继承抽象类使用extends。只能“单继承，多实现“。</li><li>对于应用<ul><li>抽象类：当子类和父类之间存在逻辑上的层次接口，建议用抽象类。</li><li>接口类：当功能不需要，希望支持差别较大的两个或更多对象间的特定交互行为。</li></ul></li></ul></li></ul><h1 id="内部类及其作用"><a href="#内部类及其作用" class="headerlink" title="内部类及其作用"></a>内部类及其作用</h1><ul><li>成员内部类：<ul><li>成员内部类可以访问private及以上外部类的属性和方法。</li><li>外部类想要访问内部类属性或方法时，必须创建一个内部类对象，然后通过该对象访问内部类的属性或方法。</li><li>外部类也可以访问private修饰的内部类属性。</li></ul></li><li>局部内部类：<ul><li>存在于放啊中的内部类，访问权限类似局部变量，只能访问外部类的final变量。</li></ul></li><li>匿名内部类：<ul><li>只能用一次，没有类名，只能访问外部类的final变量。</li></ul></li><li>静态内部类<ul><li>类似类的静态成员变量。</li></ul></li></ul><h1 id="Java的static"><a href="#Java的static" class="headerlink" title="Java的static"></a>Java的static</h1><ul><li>修饰成员变量</li><li>修饰常用方法</li><li>修饰代码块</li><li>修饰内部类</li></ul><h1 id="为什么String被设计为不可变"><a href="#为什么String被设计为不可变" class="headerlink" title="为什么String被设计为不可变"></a>为什么String被设计为不可变</h1><ul><li>节省空间：字符串常量存储在JVM的字符串池中可以被用户共享。</li><li>提高效率：String可以被不同线程共享，是线程安全的。在涉及多线程操作中不需要同步操作。</li><li><del>安全：String常用于用户名，密码，文件名使用，由于其不可变，可避免黑客行为对其恶意修改</del>（什么胡言乱语）</li></ul><h1 id="String，StringBuffer，StringBuilder"><a href="#String，StringBuffer，StringBuilder" class="headerlink" title="String，StringBuffer，StringBuilder"></a>String，StringBuffer，StringBuilder</h1><p>String类：不可变。</p><p>StringBuilder：采用无final修饰的字符数组保存，可变，效率高，线程不安全。</p><p>StringBuffer：采用无final修饰的字符数组保存，可变，效率低，线程安全。</p><ul><li>StringBuilder和StringBuffer原理上的区别：StringBuffer的所有方法都有synchronized修饰，所以线程安全。</li></ul><h1 id="Object类常用方法"><a href="#Object类常用方法" class="headerlink" title="Object类常用方法"></a>Object类常用方法</h1><ul><li>hashCode：通过对象计算散列码。常用于map和equals。</li><li>equals：判断两个对象是否一致。若equals相同，则hashCode也必须相同。</li><li>toString：用String表示该对象。</li><li>clone：深拷贝一个对象。</li></ul><h1 id="Java一维数组和二维数组声明方式"><a href="#Java一维数组和二维数组声明方式" class="headerlink" title="Java一维数组和二维数组声明方式"></a>Java一维数组和二维数组声明方式</h1><p>一维数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type[] arrayName;</span><br><span class="line">type arrayName[];</span><br></pre></td></tr></table></figure><p>二维数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type[][] arrayName;</span><br><span class="line">type arrayName[][];</span><br><span class="line">type[] arrayName[];</span><br></pre></td></tr></table></figure><h1 id="Java异常的分类"><a href="#Java异常的分类" class="headerlink" title="Java异常的分类"></a>Java异常的分类</h1><p>Error：程序无法处理的错误</p><p>Exception：程序可以处理的异常</p><p>Error常见的有StackOverFlowError，OutOfMemoryError。</p><p>Exception分为运行时异常和非运行时异常。对于运行时异常，可以用try，catch处理，也可不处理。对于非运行时异常，则无法通过编译。</p><h1 id="throw和throws的区别"><a href="#throw和throws的区别" class="headerlink" title="throw和throws的区别"></a>throw和throws的区别</h1><ul><li>throw一般用在方法体内部，用于抛出异常</li><li>throws用在方法声明上，代表该方法可能会抛出异常的列表。</li></ul><h1 id="finally是否一定会执行"><a href="#finally是否一定会执行" class="headerlink" title="finally是否一定会执行"></a>finally是否一定会执行</h1><ul><li>在try语句之前出现异常。</li><li>程序在try中出现程序强制退出，如System.exit(0)等方法，finally不会执行。</li><li>其他<ul><li>当try&#x2F;catch&#x2F;finally时，若try中存在return，finally语句会在return之前执行。若try&#x2F;catch&#x2F;finally中都有return语句，finally语句中的return语句会覆盖try&#x2F;catch中的return语句。</li></ul></li></ul><h1 id="final，finally和finalize区别"><a href="#final，finally和finalize区别" class="headerlink" title="final，finally和finalize区别"></a>final，finally和finalize区别</h1><ul><li>final，用于声明属性、方法和类，分别表示属性不可变，方法不可重写，类不可继承。</li><li>finally作为异常处理的一部分，只能在try&#x2F;catch中使用，finally语句在try&#x2F;catch后一定会被执行，一般用于释放资源。</li><li>finalize时Object类的一个方法，在垃圾收集器要回收对象时，会先调用finalize方法，并在下次垃圾回收动作时真正回收对象占用的内存。</li></ul><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p>即“参数化类型”，解决不确定对象具体类型的问题。</p><p>在编译阶段有效，操作的数据类型被指定为一个参数，这种参数类型在类中成为泛型类，接口中称为泛型接口，方法称为泛型方法。</p><h1 id="泛型擦除"><a href="#泛型擦除" class="headerlink" title="泛型擦除"></a>泛型擦除</h1><p>Java编译器生成的字节码不包含泛型西悉尼，泛型类型信息将在编译处理阶段擦除。</p><h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><p>Java注解用于为Java代码提供元数据。作为元数据，注解不直接影响代码执行，有些类型的注解可以用于这个目的。</p><p>可以用于提供信息给编译器，在编译阶段时给软件提供信息进行相关的处理，在运行时处理写相应代码，做对应操作。</p><h1 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h1><p>元注解可以理解为注解的注解，即在注解中使用，实现想要的功能，具体有：</p><ul><li>@Retention：表示注解存在阶段。包括：保留在源码，在字节码（类加载），还是在运行期间。</li><li>@Target，注解作用范围。</li><li>@Document，将注解元素包含到Javadoc中。</li><li>@Inherited：一个被@Inherited注解了的注解修饰一个父类，若子类没有被其他注解修饰，则子类继承父类注解。</li><li>@Repeatable：被这个元注解修饰的注解可以同时作用一个对象多次，但每次作用注解又可以表示不同的含义。</li></ul><h1 id="Java的Class对象"><a href="#Java的Class对象" class="headerlink" title="Java的Class对象"></a>Java的Class对象</h1><p>Jav中对象可分为实例对象和Class对象，每个类都有一个Class对象，其包含了与该类相关的信息。</p><p>获取Class对象的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;类的全限定名&quot;</span>);</span><br><span class="line">实例对象.getClass();</span><br><span class="line">类名.class</span><br></pre></td></tr></table></figure><h1 id="Java反射机制"><a href="#Java反射机制" class="headerlink" title="Java反射机制"></a>Java反射机制</h1><p>Java反射机制是指程序在运行过程中可以构造任意一个类的对象，获取任意一个类的成员变量和成员方法，获取任意一个对象所属的类信息，调用任意一个对象的属性和方法。反射机制使得Java具有动态获取程序信息和动态调用对象放啊的能力。可以通过以下类调用反射API。</p><ul><li>Class类：可以获得类属性方法</li><li>Field：可以获得类的成员信息</li><li>Method：类的方法信息</li><li>Construct：类的构造方法等信息。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;参考文献&quot;&gt;&lt;a href=&quot;#参考文献&quot; class=&quot;headerlink&quot; title=&quot;参考文献&quot;&gt;&lt;/a&gt;参考文献&lt;/h1&gt;&lt;p&gt;[1] &lt;a href=&quot;https://cloud.tencent.com/developer/article/18722</summary>
      
    
    
    
    
    <category term="Java" scheme="http://zswh33.github.io/tags/Java/"/>
    
    <category term="Job" scheme="http://zswh33.github.io/tags/Job/"/>
    
  </entry>
  
  <entry>
    <title>Job Study 1 Java</title>
    <link href="http://zswh33.github.io/2023/04/28/Job-Study-1/"/>
    <id>http://zswh33.github.io/2023/04/28/Job-Study-1/</id>
    <published>2023-04-28T15:44:08.000Z</published>
    <updated>2023-04-29T07:05:33.171Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="接口类和抽象类的区别"><a href="#接口类和抽象类的区别" class="headerlink" title="接口类和抽象类的区别"></a>接口类和抽象类的区别</h2><ul><li>实现方式不同<ul><li>抽象类是一个普通的类，使用abstract修饰，可以包含普通方法和抽象方法</li><li>接口类是一种特殊的抽象类，使用interface修饰，只能包含抽象方法、常量和默认方法。</li></ul></li><li>继承方式不同<ul><li>子类只能继承一个抽象类，子类可以实现多个接口。（单继承，多实现）</li></ul></li><li>实现方法不同<ul><li>抽象类抽象方法可以具体实现代码</li><li>接口类抽象方法必须由实现类提供具体实现。</li></ul></li><li>设计目的<ul><li>抽象类：被继承，提供一些通用的功能和属性，让子类实现自己特有的功能。</li><li>接口类：被实现，定义一组规范，规定实现类要实现哪些方法。</li></ul></li></ul><h2 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h2><ul><li>重载发生在同一个类中，方法名相同；参数列表，返回类型，权限修饰符可以不同</li><li>重写发生在子类中，方法名、参数列表和返回类型都相同，权限修饰符要大于父类方法，声明异常范围要小于弗雷方法，但final和private修饰的方法都不可重写。</li></ul><h1 id="x3D-x3D-和equals的区别"><a href="#x3D-x3D-和equals的区别" class="headerlink" title="&#x3D;&#x3D;和equals的区别"></a>&#x3D;&#x3D;和equals的区别</h1><p>&#x3D;&#x3D;用于比较两个对象的引用是否相同。对于基本数据类型，比较两个值是否相等。</p><p>equals比较两个对象在逻辑上是否相等，通常需要根据对象的属性值来判断。</p><h2 id="异常处理机制"><a href="#异常处理机制" class="headerlink" title="异常处理机制"></a>异常处理机制</h2><p>Java异常处理机制是一种在程序运行时检测和处理错误的方式。</p><p>当出现异常情况，JVM会生成一个异常对象，描述异常的类型和发生的位置。</p><p>关键字：</p><ul><li>try：包裹可能会抛出异常的代码块</li><li>catch：捕获try块中抛出的异常，并执行相应的处理逻辑。</li><li>finally：无论是否发生异常，都会执行的代码块。常用于资源释放。</li><li>throws：声明方法可能抛出的异常类型。</li></ul><h2 id="HashMap扩容机制"><a href="#HashMap扩容机制" class="headerlink" title="HashMap扩容机制"></a>HashMap扩容机制</h2><h2 id="HashMap实现原理"><a href="#HashMap实现原理" class="headerlink" title="HashMap实现原理"></a>HashMap实现原理</h2><h2 id="HashMap存取原理"><a href="#HashMap存取原理" class="headerlink" title="HashMap存取原理"></a>HashMap存取原理</h2><h2 id="线程安全的HashMap"><a href="#线程安全的HashMap" class="headerlink" title="线程安全的HashMap"></a>线程安全的HashMap</h2><h2 id="HashTable与HashMap区别"><a href="#HashTable与HashMap区别" class="headerlink" title="HashTable与HashMap区别"></a>HashTable与HashMap区别</h2><h2 id="ArrayList和LinkedList区别"><a href="#ArrayList和LinkedList区别" class="headerlink" title="ArrayList和LinkedList区别"></a>ArrayList和LinkedList区别</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java&quot;&gt;&lt;a href=&quot;#Java&quot; class=&quot;headerlink&quot; title=&quot;Java&quot;&gt;&lt;/a&gt;Java&lt;/h1&gt;&lt;h2 id=&quot;接口类和抽象类的区别&quot;&gt;&lt;a href=&quot;#接口类和抽象类的区别&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    
    <category term="Job" scheme="http://zswh33.github.io/tags/Job/"/>
    
  </entry>
  
  <entry>
    <title>Openssl 1</title>
    <link href="http://zswh33.github.io/2023/03/27/OpenSSL-1/"/>
    <id>http://zswh33.github.io/2023/03/27/OpenSSL-1/</id>
    <published>2023-03-27T06:04:02.000Z</published>
    <updated>2023-03-27T07:35:43.889Z</updated>
    
    <content type="html"><![CDATA[<h1 id="子命令"><a href="#子命令" class="headerlink" title="子命令"></a>子命令</h1><ul><li><code>ca</code>：对整数办法机构CA相关操作的子命令，可用于签发证书，吊销证书</li><li><code>genrsa</code>：生成RSA密钥，</li><li><code>genkey</code>：生成密钥的通用子命令</li><li><code>passwd</code>：修改私钥密码的命令</li><li><code>rsa</code>：进行RSA算法相关操作的子命令</li><li><code>x509</code>：与X.509证书操作相关的命令，可以生成证书，查看证书信息。</li></ul><h2 id="genrsa"><a href="#genrsa" class="headerlink" title="genrsa"></a>genrsa</h2><p>用于生成RSA密钥对。</p><p><code>openssl genrsa [options] [-out filename] [numbits]</code></p><ul><li><p>numbits: 密钥长度</p></li><li><p><code>-out filename</code>: 输出文件名</p></li><li><p><code>-des | -des3 | -aes128 | -aes192 | -aes256</code>：指定加密私钥使用的算法</p></li><li><p><code>-passout pass:&quot;123456&quot;</code>：指定加密私钥的密码，这里可以是一个字符串，也可以是一个文件名</p></li><li><p><code>-f4</code>：使用F4作为RSA密钥生成器的指数值，F4是一个公认的安全值。</p></li><li><p><code>-rand filename</code>：用于提供额外的熵，增加RSA密钥的强度，用于提高RSA密钥对的随机性。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -rand /dev/random -out key.pem 2048</span><br></pre></td></tr></table></figure></li><li><p><code>-outform format</code>：指定生成文件的格式。可以是pem，der，net等其他格式；</p></li></ul><h2 id="rsa"><a href="#rsa" class="headerlink" title="rsa"></a>rsa</h2><p>用于RSA算法相关的操作</p><p><code>openssl rsa [options]</code></p><ul><li><code>-in filename</code>：输入文件名，必须是一个pem格式的RSA密钥文件，若未指定该参数，则从标准输入流中读取密钥</li><li><code>-out filenmae</code>：指定输出的文件名，未指定则到标准输出流中</li><li><code>-inform 输入文件格式</code>：der, net, pem</li><li><code>-outform 输出文件格式</code>：der, net, pem</li><li><code>-des | -des3 | -aes128 | -aes192 | -aes256</code>：加密方式</li><li><code>-pubin</code>：指定输入文件为公钥文件，若未指定，默认输入文件为私钥文件</li><li><code>-pubout</code>：指定输出的公钥部分，若指定参数，输出公钥，默认输出私钥</li><li><code>-text</code>：输出密钥的详细信息，则输出RSA密钥的详细信息，包括模数，指数，系数等</li><li><code>-noout</code>：不打印密钥key数据</li><li><code>-passin</code>：指定输入文件的密码；</li><li><code>-passout</code>：指定输出文件的密码</li></ul><h2 id="dgst-文件签名"><a href="#dgst-文件签名" class="headerlink" title="dgst 文件签名"></a>dgst 文件签名</h2><p><code>openssl dgst [options] [filename]</code></p><ul><li><p>filename: 操作的文件</p></li><li><p><code>-sign PRIKEY</code>：使用私钥生成一个文件的签名</p></li><li><p><code>-verify PUBKEY</code>：使用公钥对一个文件进行验证</p></li><li><p><code>--passin pass:&quot;123456&quot;</code>：指定私钥的密码</p></li></ul><h2 id="enc-对文件进行密码加密"><a href="#enc-对文件进行密码加密" class="headerlink" title="enc 对文件进行密码加密"></a>enc 对文件进行密码加密</h2><p><code>openssl enc</code></p><ul><li><code>-e </code>：对文件进行加密操作</li><li><code>-d</code>：对文件进行解密操作</li><li><code>-in FILENAME</code>：输入文件</li><li><code>-out FILENAME</code>：输出文件</li><li><code>-aes256</code>：指定加密方式</li></ul><h2 id="rsautl-使用密钥进行文件加密"><a href="#rsautl-使用密钥进行文件加密" class="headerlink" title="rsautl 使用密钥进行文件加密"></a>rsautl 使用密钥进行文件加密</h2><ul><li><code>-encrypt</code>：文件加密</li><li><code>-decrypt</code>：文件解密</li><li><code>-inkey KEY</code>：输入密钥文件</li><li><code>-pubin</code>：指定输入文件为公钥</li><li><code>-in FILENAME</code>：输入文件</li><li><code>-out FILENAME</code>：输出文件</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;子命令&quot;&gt;&lt;a href=&quot;#子命令&quot; class=&quot;headerlink&quot; title=&quot;子命令&quot;&gt;&lt;/a&gt;子命令&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ca&lt;/code&gt;：对整数办法机构CA相关操作的子命令，可用于签发证书，吊销证书&lt;/li&gt;
&lt;li&gt;&lt;cod</summary>
      
    
    
    
    
    <category term="openssl" scheme="http://zswh33.github.io/tags/openssl/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ 7</title>
    <link href="http://zswh33.github.io/2023/03/20/RabbitMQ-7/"/>
    <id>http://zswh33.github.io/2023/03/20/RabbitMQ-7/</id>
    <published>2023-03-20T15:53:18.000Z</published>
    <updated>2023-03-21T16:16:38.065Z</updated>
    
    <content type="html"><![CDATA[<h1 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h1><p>在消息消费时，消息会根据优先级进行排序，优先级高的消息会被最先被消费。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="队列配置"><a href="#队列配置" class="headerlink" title="队列配置"></a>队列配置</h3><p><code>x-max-priority</code>可以配置队列的优先级数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> ExchangeBuilder.directExchange(EXCHANGE).withArgument(<span class="string">&quot;x-max-priority&quot;</span>,<span class="number">10</span>).build();</span><br></pre></td></tr></table></figure><h3 id="消息配置"><a href="#消息配置" class="headerlink" title="消息配置"></a>消息配置</h3><p>发送消息的时候要为消息配置优先级。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template.convertAndSend(RabbitMQConfig.EXCHANGE,RabbitMQConfig.QUEUE_KEY,<span class="string">&quot;当前是消息&quot;</span>+i, message -&gt; &#123;</span><br><span class="line">message.getMessageProperties().setPriority(<span class="number">7</span>);</span><br><span class="line">    <span class="keyword">return</span> message;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>在测试过程中，要为消费者设置较小的<code>basicQos</code>，否则由于消费者一次获取多个消息，无法达到优先队列的效果。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>RabbitMQ使用堆排序。</p><h1 id="惰性队列"><a href="#惰性队列" class="headerlink" title="惰性队列"></a>惰性队列</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ul><li>惰性队列可以将消息尽可能多地存储在磁盘中，而不是驻留在内存中，直到消费者需要消费相应消息时才会被加载到内存中。</li><li>默认情况下，队列会尽可能地将消息存储在内存中，这样可以更快地将消息发给消费者。<ul><li>即使是持久化队列，也会在内存中驻留一份备份。</li></ul></li><li>当需要释放内存时，RabbitMQ会将消息换页到磁盘中，这个操作会消耗大量时间，并且造成阻塞队列，无法收到新的消息</li><li>在惰性队列中，<ul><li>持久化队列会将收到的消息直接存入文件系统，减少内存消耗，增加I&#x2F;O使用，</li><li>若是非持久化消息，将不会发生变化。</li></ul></li></ul><h2 id="配置惰性队列"><a href="#配置惰性队列" class="headerlink" title="配置惰性队列"></a>配置惰性队列</h2><ul><li><p>通过配置arguments来配置惰性队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">lazyQueue</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> QueueBuilder.durable(<span class="string">&quot;lazyQueue_Study_1030&quot;</span>).withArgument(<span class="string">&quot;x-queue-mode&quot;</span>,<span class="string">&quot;lazy&quot;</span>).build();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">lazyQueue2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> QueueBuilder.durable(<span class="string">&quot;lazyQueue_Study_10302&quot;</span>).lazy().build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过配置Policy的方式配置惰性队列</p><p>hole…</p></li></ul><h1 id="RabbitMQ集群"><a href="#RabbitMQ集群" class="headerlink" title="RabbitMQ集群"></a>RabbitMQ集群</h1><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p><img src="/2023/03/20/RabbitMQ-7/RabbitMQ%E9%9B%86%E7%BE%A4.svg" alt="RabbitMQ集群"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl stop_app <span class="comment">#停止当前RabbitMQ</span></span><br><span class="line">rabbitmqctl reset <span class="comment"># 重置RabbitMQ</span></span><br><span class="line">rabbitmqctl join_cluster rabbitmq@192.168.x.x:port <span class="comment">#加入集群</span></span><br><span class="line">rabbitmqctl start_app <span class="comment"># 开启服务</span></span><br></pre></td></tr></table></figure><h2 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h2><p>查看集群状态：<code>rabbitmqctl cluster_status</code></p><h2 id="从集群中删除节点"><a href="#从集群中删除节点" class="headerlink" title="从集群中删除节点"></a>从集群中删除节点</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl forget_cluster_node rabbitmq@node2 <span class="comment">#在集群的任意节点执行</span></span><br></pre></td></tr></table></figure><h1 id="镜像队列"><a href="#镜像队列" class="headerlink" title="镜像队列"></a>镜像队列</h1><p>镜像队列配置在Policy中，具体配置三个参数</p><ul><li>ha-mode：配置镜像队列的复制模式<ul><li>exactly：队列复制到指定数量的节点</li><li>nodes：将队列复制到所有具有相同名称的节点</li><li>all：将队列复制到所有节点</li></ul></li><li>ha-params：ha-mode指定后的参数<ul><li>exactly模式，这里表示要复制的节点数量</li><li>nodes模式，这里表示要复制到的节点的名称，如：<code>[&quot;rabbitmq@node1&quot;,&quot;rabbitmq@node2&quot;]</code></li></ul></li><li>ha-sync-mode：表示镜像的同步方式，<ul><li>automatic：异步模式进行同步</li><li>manual：需要显式调用API进行同步操作</li></ul></li></ul><h1 id="Haproxy，keepalive"><a href="#Haproxy，keepalive" class="headerlink" title="Haproxy，keepalive"></a>Haproxy，keepalive</h1><p>实现RabbitMQ的高可用，负载均衡。</p><h1 id="Federation插件"><a href="#Federation插件" class="headerlink" title="Federation插件"></a>Federation插件</h1><p><del>Federation联邦，用于为用户优选RabbitMQ主机。</del></p><h2 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_federation  <span class="comment">#开启插件</span></span><br><span class="line">rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_federation_management  <span class="comment">#开启插件</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;优先级队列&quot;&gt;&lt;a href=&quot;#优先级队列&quot; class=&quot;headerlink&quot; title=&quot;优先级队列&quot;&gt;&lt;/a&gt;优先级队列&lt;/h1&gt;&lt;p&gt;在消息消费时，消息会根据优先级进行排序，优先级高的消息会被最先被消费。&lt;/p&gt;
&lt;h2 id=&quot;使用&quot;&gt;&lt;a hre</summary>
      
    
    
    
    
    <category term="RabbitMQ" scheme="http://zswh33.github.io/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ 6 交换机确认回调 消息回退 备份交换机 幂等性</title>
    <link href="http://zswh33.github.io/2023/03/20/RabbitMQ-6/"/>
    <id>http://zswh33.github.io/2023/03/20/RabbitMQ-6/</id>
    <published>2023-03-20T12:34:28.000Z</published>
    <updated>2023-03-20T15:59:12.206Z</updated>
    
    <content type="html"><![CDATA[<h1 id="发布确认回调"><a href="#发布确认回调" class="headerlink" title="发布确认回调"></a>发布确认回调</h1><p>通过实现<code>RabbitTemplate.ConfirmCallback</code>接口，可以实现<strong>当消息向交换机传递失败时</strong>，触发回调方法。</p><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.rabbitmq.publisher-confirm-type</span>=<span class="string">correlated</span></span><br></pre></td></tr></table></figure><ul><li>该配置用于设置<strong>消息从程序传递到交换机，交换机是否响应结果</strong>；</li><li>参数<ul><li><strong>CORRELATED</strong>：关联模式，消息发送到交换机会触发回调方法</li><li>NONE：禁用发布确认，是<strong>默认</strong>模式。</li><li>SIMPLE：<ul><li>像CORRELATED一样会触发回调方法</li><li>发布消息成功后使用<code>rabbitTemplate</code>调用<code>waitForConfirms</code>或<code>waitForConfirmsOrDie</code>方法等待broker节点返回发送结果，根据返回结果来判定下一步的逻辑，要注意的点是<code>waitForConfirmsOrDie</code>方法如果返回false则会关闭channel，则接下来无法发送消息到broker;</li></ul></li></ul></li></ul><h2 id="CORRELATED"><a href="#CORRELATED" class="headerlink" title="CORRELATED"></a>CORRELATED</h2><h3 id="发布消息"><a href="#发布消息" class="headerlink" title="发布消息"></a>发布消息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template.convertAndSend(RabbitMQConfig.EXCHANGE,RabbitMQConfig.QUEUE_KEY,m,<span class="keyword">new</span> <span class="title class_">CorrelationData</span>(<span class="string">&quot;这是ID&quot;</span>));</span><br><span class="line"><span class="comment">//new CorrelationData(&quot;这是ID&quot;)，这个参数会在回调函数中获得，一般用于在回调函数中区分被回调的消息。</span></span><br></pre></td></tr></table></figure><h3 id="接收回调"><a href="#接收回调" class="headerlink" title="接收回调"></a>接收回调</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FailedMessageConfig</span> <span class="keyword">implements</span> <span class="title class_">RabbitTemplate</span>.ConfirmCallback &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RabbitTemplate template;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        template.setConfirmCallback(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">confirm</span><span class="params">(CorrelationData correlationData, <span class="type">boolean</span> ack, String cause)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">m</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (correlationData!=<span class="literal">null</span>)m = correlationData.getId();<span class="comment">//这里获取消息的ID</span></span><br><span class="line">        <span class="keyword">if</span> (ack)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;成功发送消息：&quot;</span>+m);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;发送消息失败，原因：&quot;</span>+cause);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">发送消息失败，原因：channel error; protocol method: <span class="comment">#method&lt;channel.close&gt;(reply-code=404, reply-text=NOT_FOUND - no exchange &#x27;exchange_study_2131q&#x27; in vhost &#x27;/&#x27;, class-id=60, method-id=40)</span></span><br></pre></td></tr></table></figure><h1 id="消息回退"><a href="#消息回退" class="headerlink" title="消息回退"></a>消息回退</h1><ul><li><p>当仅开启了生产者确认机制的情况下，交换机接收到消息后，会直接给消息生产者发送确认消息，如果发现消息该消息不可路由，消息会被直接丢弃。</p></li><li><p>解决方法</p><ul><li>设置mandatory参数，当消息不可到达目的地时将消息返回给生产者。</li></ul></li></ul><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#当消息不可被路由，回退消息给生产者</span><br><span class="line">spring.rabbitmq.publisher-returns=true</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class FailedMessageConfig implements RabbitTemplate.ReturnsCallback &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    RabbitTemplate template;</span><br><span class="line"></span><br><span class="line">    @PostConstruct</span><br><span class="line">    public void init()&#123;</span><br><span class="line">        template.setReturnsCallback(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //可以当消息传递过程中，消息不可达目的地，则返回给生产者</span><br><span class="line">    @Override</span><br><span class="line">    public void returnedMessage(ReturnedMessage returned) &#123;</span><br><span class="line">        System.out.printf(&quot;消息%s,被交换机%s退回，退回原因%s,路由key:%s&quot;,</span><br><span class="line">                returned.getMessage(),</span><br><span class="line">                returned.getExchange(),</span><br><span class="line">                returned.getReplyText(),</span><br><span class="line">                returned.getRoutingKey());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">消息 你好 ,被交换机 exchange_study_2131 退回，退回原因 NO_ROUTE ,路由key: queue_key_study_2131qwe</span><br></pre></td></tr></table></figure><h1 id="备份交换机"><a href="#备份交换机" class="headerlink" title="备份交换机"></a>备份交换机</h1><p>当交换机无法将消息传递给队列，会将消息传递给<code>备份交换机</code>。</p><p>可以在交换机中配置参数：<code>alternate-exchange</code>值为备份交换机的名字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Exchange <span class="title function_">directExchange2131</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ExchangeBuilder.directExchange(EXCHANGE).withArgument(<span class="string">&quot;alternate-exchange&quot;</span>,BACKUP_EXCHANGE).build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="消息回退与备份交换机"><a href="#消息回退与备份交换机" class="headerlink" title="消息回退与备份交换机"></a>消息回退与备份交换机</h1><p>当<strong>消息回退</strong>和<strong>备份交换机</strong>同时开启时，<strong>备份交换机优先级更高</strong>。</p><h1 id="死信队列和备份交换机的区别"><a href="#死信队列和备份交换机的区别" class="headerlink" title="死信队列和备份交换机的区别"></a>死信队列和备份交换机的区别</h1><h2 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h2><ul><li><p>死信队列：<code>x-dead-letter-exchange</code>设置死信交换机，<code>x-dead-letter-routing-key</code>设置使用的路由key。</p></li><li><p>备份交换机：<code>alternate-exchange</code>指定备份交换机的名字。</p></li></ul><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><ul><li>死信队列：负责处理交换机的消息无法到达队列的情况，<code>消息被拒绝/队列达最大长度/TTL过期</code>。</li><li>备份交换机：当消息无法到达交换机时，消息将尝试到达备份交换机。</li></ul><p><img src="/2023/03/20/RabbitMQ-6/%E6%B6%88%E6%81%AF%E5%BC%80%E5%A7%8B%E5%8F%91%E9%80%81.svg" alt="消息开始发送"></p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="幂等性"><a href="#幂等性" class="headerlink" title="幂等性"></a>幂等性</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><ul><li><p>要求用户对于同一操作发起的<strong>一次或多次请求的结果是一致的</strong>，不会因多次请求产生副作用。</p></li><li><p>解决的问题如：支付，用户购买商品支付，扣款成功，但网络异常，导致<strong>二次扣款</strong>。</p></li></ul><h3 id="如何出现"><a href="#如何出现" class="headerlink" title="如何出现"></a>如何出现</h3><ul><li><p>消费者在MQ消费消息，</p></li><li><p>当MQ向消费者发送消息，消费者要返回ACK时，网络中断，</p></li><li><p>此时MQ没有收到确认消息，</p><ul><li>这个消息会被发送给其他消费者，</li><li>或在网络恢复后将消息重新发给消费者</li></ul></li><li><p>产生<strong>重复消费</strong>。</p></li></ul><h3 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h3><ul><li>为消息标记一个<strong>全局ID</strong>或一个<strong>唯一标识</strong>，每次消费消息前判断该消息是否被消费过。</li></ul><h3 id="主流解决方案"><a href="#主流解决方案" class="headerlink" title="主流解决方案"></a>主流解决方案</h3><ul><li>唯一ID+指纹码机制<ul><li>利用数据库主键去重</li><li>指纹码：为消息添加唯一标志。</li><li>优势：简单</li><li>劣势：在高并发时，会出现性能问题。</li></ul></li><li>分布式锁，如<strong>利用<code>Redis</code>原子性实现</strong>（推荐的方式）<ul><li>使用Redis的setnx命令。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;发布确认回调&quot;&gt;&lt;a href=&quot;#发布确认回调&quot; class=&quot;headerlink&quot; title=&quot;发布确认回调&quot;&gt;&lt;/a&gt;发布确认回调&lt;/h1&gt;&lt;p&gt;通过实现&lt;code&gt;RabbitTemplate.ConfirmCallback&lt;/code&gt;接口，可以实现</summary>
      
    
    
    
    
    <category term="RabbitMQ" scheme="http://zswh33.github.io/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ 基础知识 1</title>
    <link href="http://zswh33.github.io/2023/03/18/RabbitMQ-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-1/"/>
    <id>http://zswh33.github.io/2023/03/18/RabbitMQ-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-1/</id>
    <published>2023-03-18T07:00:10.000Z</published>
    <updated>2023-03-21T16:06:14.447Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为队列设置arguments"><a href="#为队列设置arguments" class="headerlink" title="为队列设置arguments"></a>为队列设置arguments</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">channel.queueDeclare(NORMAL_QUEUE,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,Object&gt;()&#123;&#123;</span><br><span class="line">    put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>,DEAD_EXCHANGE);<span class="comment">//设置死信要送达的交换机</span></span><br><span class="line">    put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>,<span class="string">&quot;lisi&quot;</span>);<span class="comment">//设置死信送达使用的RoutingKey</span></span><br><span class="line">&#125;&#125;);</span><br></pre></td></tr></table></figure><ul><li><p><code>x-dead-letter-exchange</code>：设置死信要送达的交换机</p></li><li><p><code>x-dead-letter-routing-key</code>：设置死信送达使用的<code>RoutingKey</code></p></li><li><p><code>x-max-length</code>：队列的最大长度</p></li><li><p><code>x-message-ttl</code>：设置消息过期时间，单位毫秒</p></li><li><p><code>x-max-priority</code>：设置队列支持的消息的优先级级数，默认为10个级数，最大允许255；</p></li><li><p><code>x-expires</code>：设置队列的自动删除，单位毫秒</p></li><li><p><code>x-queue-mode</code>：可以设置队列模式</p><ul><li>对于持久化队列，消息会被存储到磁盘中，并在内存不吃紧的情况下，在内存中创建一个备份，这个备份包含队列的部分消息；</li><li>默认情况下，内存中的备份会尽可能多的存储消息。<ul><li><code>lazy</code>惰性队列：若设置了惰性队列，持久化队列将不在内存中设置备份，只有当被消费者消费的时候才会读入内存。</li><li><code>classic</code>经典：消息会被直接保存在内存中</li><li><code>quorum</code>仲裁：需要安装插件。在多个节点间复制队列，使得队列有更好的可靠性和可扩展性，但会带来一定的性能损失。</li></ul></li></ul></li><li><p><code>ha-mode</code>：集群节点的复制模式。</p><ul><li><code>all</code>：队列将复制到所有的集群节点，并且在从节点不可用时，主节点不再接收新的消息；</li><li><code>exactly</code>：队列将在特定数量的节点上进行复制。<ul><li><code>ha-params</code>可以指定在多少个节点上进行复制，若不指定，则默认为所有节点。</li></ul></li><li><code>nodes</code>：队列将复制到指定节点上，通过<code>ha-params</code>指定要复制的节点。</li></ul></li></ul><h1 id="发布消息指定配置"><a href="#发布消息指定配置" class="headerlink" title="发布消息指定配置"></a>发布消息指定配置</h1><h2 id="原生配置方式"><a href="#原生配置方式" class="headerlink" title="原生配置方式"></a>原生配置方式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">channel.basicPublish(</span><br><span class="line">        Consumer.NORMAL_EXCHANGE,</span><br><span class="line">        <span class="string">&quot;zhangsan&quot;</span>,</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">AMQP</span>.BasicProperties().builder().expiration(<span class="string">&quot;10000&quot;</span>).build(),<span class="comment">//设置发布消息的配置，这里设置消息过期时间10秒</span></span><br><span class="line">        message.getBytes());</span><br></pre></td></tr></table></figure><h2 id="SpringBoot配置方式"><a href="#SpringBoot配置方式" class="headerlink" title="SpringBoot配置方式"></a>SpringBoot配置方式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">template.convertAndSend(</span><br><span class="line">    MQUtils.NORMAL_EXCHANGE,</span><br><span class="line">    MQUtils.NORMAL_QUEUE_1_ROUTINGKEY,</span><br><span class="line">    message,(msg)-&gt;&#123;</span><br><span class="line">    msg.getMessageProperties().setExpiration(<span class="string">&quot;10000&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> msg;</span><br><span class="line">&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="配置列表"><a href="#配置列表" class="headerlink" title="配置列表"></a>配置列表</h2><ul><li><code>contentType</code>：消息体编码方式，如<code>application/json</code></li><li><code>contentEncoding</code>：消息体的字符集，如<code>UTF-8</code></li><li><code>deliveryMode</code>：消息持久化，1表示持久化，0表示不持久化。</li><li><code>priority</code>：消息的优先级，默认可以为0-9的整数</li><li><code>correlationId</code>：关联Id，用于关联RPC请求和响应</li><li><code>replyTo</code>：指定回复的队列名称</li><li><code>expiration</code>：过期时间，单位毫秒<ul><li>若与为队列设置的消息过期时间<code>ttl</code>同时存在，则以值较小的那个为准。</li></ul></li><li><code>messageId</code>：消息Id</li><li><code>headers</code>：存储自定义键值对，可以在不同服务之间传递消息</li><li><code>type</code>：消息类型，可以用于标识消息的目的，如”order_create”或”payment_success”等</li><li><code>timestamp</code>：消息的时间戳，表示消息的创建时间</li><li><code>userId</code>：标识发送消息的用户</li><li><code>appId</code>：应用程序Id，标识发送消息的应用程序</li><li><code>clusterId</code>：集群Id，标识所属集群</li></ul><h1 id="Policy配置"><a href="#Policy配置" class="headerlink" title="Policy配置"></a>Policy配置</h1><p>可以在RabbitMQ的控制台的Admin中配置Policies</p><p>配置Policy的参数</p><ul><li>Name：Policy的名称</li><li>Pattern：配置队列名称的正则表达式<ul><li>如：<code>^mirror</code>表示以mirror为前缀的队列。<code>mirror_hello</code></li></ul></li><li>Definition：一个JSON对象，包含要为队列设置的属性和选项<ul><li>message-ttl：消息过期时间</li><li>maxlength：队列最大消息数</li><li>ha-mode：队列镜像模式</li><li>ha-sync-mode：队列的复制模式</li><li>ha-params：镜像模式的参数</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;为队列设置arguments&quot;&gt;&lt;a href=&quot;#为队列设置arguments&quot; class=&quot;headerlink&quot; title=&quot;为队列设置arguments&quot;&gt;&lt;/a&gt;为队列设置arguments&lt;/h1&gt;&lt;figure class=&quot;highlight </summary>
      
    
    
    
    
    <category term="RabbitMQ" scheme="http://zswh33.github.io/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ 4</title>
    <link href="http://zswh33.github.io/2023/03/01/RabbitMQ-4/"/>
    <id>http://zswh33.github.io/2023/03/01/RabbitMQ-4/</id>
    <published>2023-03-01T15:33:03.000Z</published>
    <updated>2023-03-06T06:50:34.622Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RabbitMQ持久化"><a href="#RabbitMQ持久化" class="headerlink" title="RabbitMQ持久化"></a>RabbitMQ持久化</h1><h2 id="队列持久化"><a href="#队列持久化" class="headerlink" title="队列持久化"></a>队列持久化</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>在<code>queueDeclare</code>方法上将durable设为true来实现持久化。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">channel.queueDeclare(MQUtils.KEY,<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">true</span>,null);</span><br><span class="line">                                  ^</span><br></pre></td></tr></table></figure><h2 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>Hole,…</p><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p>修改<code>basicPublish</code>的参数props为<code>MessageProperties.PERSISTENT_TEXT_PLAIN</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basicPublish(<span class="string">&quot;&quot;</span>,MQUtils.KEY,MessageProperties.PERSISTENT_TEXT_PLAIN,scanner.next().getBytes());</span><br></pre></td></tr></table></figure><h1 id="消息分发模式"><a href="#消息分发模式" class="headerlink" title="消息分发模式"></a>消息分发模式</h1><p>注：<strong>该模式并非RabbitMQ原本的模式，而是依据RabbitMQ使用方式来衍生出来的使用策略。</strong></p><p><strong>默认为轮询模式。</strong></p><ul><li>轮询模式：一个消费者一条，按均分配；</li><li>公平分发：根据消费者消费能力进行公平分发，处理快的处理的多，处理慢的处理的少。</li></ul><p>在Java中，通过设置是否进行自动应答和Qos来进行公平分发模式的实现。</p><h2 id="轮询模式-Round-Robin"><a href="#轮询模式-Round-Robin" class="headerlink" title="轮询模式 Round-Robin"></a>轮询模式 Round-Robin</h2><p><del>特点：当有多个消费者接入时，消息的分配模式是一个消费者分配一条，直到消费者消费完成</del></p><p> 若有2个消费者，1个生产者，不论两个消费者速度快慢，两个消费者收到的消息数量一致。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">channel.basicConsume(<span class="string">&quot;Queue1&quot;</span>, <span class="literal">true</span>, <span class="keyword">new</span> <span class="title class_">DeliverCallback</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(String consumerTag, Delivery message)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;收到消息：&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>( message.getBody()));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="keyword">new</span> <span class="title class_">CancelCallback</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(String consumerTag)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消息接受失败。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="不公平分发"><a href="#不公平分发" class="headerlink" title="不公平分发"></a>不公平分发</h2><p><em>能者多劳。</em></p><p>在消费者的channel设置<strong>参数Qos为1</strong>，即可实现公平分发。</p><ul><li>Qos为0则表示轮询模式。</li></ul><p><code>channel.basicQos(1);</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">channel.basicQos(<span class="number">1</span>);</span><br><span class="line">channel.basicConsume(<span class="string">&quot;Queue1&quot;</span>,<span class="literal">false</span>,<span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel)&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费成功：&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(body));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.getChannel().basicAck(envelope.getDeliveryTag(),<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="预取值"><a href="#预取值" class="headerlink" title="预取值"></a>预取值</h1><p><code>prefetch</code></p><p>信道缓存区的大小，通过basic.qos来设置消费者“预取计数”值来完成；</p><p>定义<strong>通道上允许的未确认消息的最大数量</strong>，一旦达到配置的数量，RabbitMQ将停止在通道上传递更多消息，直到至少有1个未处理的消息被确认。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basicQos(prefetchSize);</span><br></pre></td></tr></table></figure><h1 id="发布确认"><a href="#发布确认" class="headerlink" title="发布确认"></a>发布确认</h1><h2 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h2><ul><li><p>信道的confirm模式；</p></li><li><p>在信道confirm模式下，生产者向Broker发送消息后，都会收到来自Broker的反馈；</p><ul><li>若生产者要求消息持久化，Broker会在将消息持久化之后向生产者发送反馈；</li><li>原理：在confirm模式下，所有在该信道上面发布的消息都会被指派一个唯一的ID，一旦消息被投递到所有匹配的队列后，Broker会向生产者发送一条<strong>确认通知</strong>（包含消息的ID），这样生产者就会了解到消息是否成功送达队列。若消息是可持久化的，则确认通知会在消息写入磁盘后发出；<ul><li>Broker的确认通知中delivery-tag域包含了消息是否已送达和消息的确认序列号；<ul><li>若RabbitMQ因内部原因导致消息丢失，就会发送一条nack消息表示消息出错。</li></ul></li><li>Broker可以设置basic.ack的multiple域，表示这个序列号之前的所有消息都已经得到处理。</li></ul></li><li>confirm是异步的，生产者在等待确认通知的同时也可以继续发送下一跳消息；生产者在收到nack消息后可以在回调方法中处理该nack消息。</li></ul></li></ul><h2 id="开启confirm模式"><a href="#开启confirm模式" class="headerlink" title="开启confirm模式"></a>开启confirm模式</h2><p>在信道上使用<code>confirmSelect()</code>方法开启confirm模式。</p><p><code>channel.confirmSelect()</code></p><h2 id="确认发布模式"><a href="#确认发布模式" class="headerlink" title="确认发布模式"></a>确认发布模式</h2><h3 id="单个确认发布"><a href="#单个确认发布" class="headerlink" title="单个确认发布"></a>单个确认发布</h3><ul><li><p>一种简单的确认方式，它是一种<strong>同步确认发布</strong>的方式，</p><ul><li>发布一个消息后，只有这个消息被<strong>确认</strong>，后续的消息才能继续发布</li><li>waitForConfirmDie(long)，在指定时间内收到确认则返回，若在时间范围内未确认则抛出异常。</li></ul></li><li><p>缺点</p><ul><li>发布速度特别慢</li></ul></li><li><p>场景：每秒不超过数百条发布消息吞吐量，有些应用程序是可以用的。</p></li><li><p>使用：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开启发布确认</span></span><br><span class="line">channel.confirmSelect();</span><br><span class="line"><span class="comment">//批量发消息</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; MessageCount; i++) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> i + <span class="string">&quot;&quot;</span>;</span><br><span class="line">    channel.basicPublish(<span class="string">&quot;&quot;</span>,queueName,<span class="literal">null</span>,message.getBytes());</span><br><span class="line">    <span class="comment">//单个消息，发布后马上确认</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> channel.waitForConfirms();</span><br><span class="line">    <span class="keyword">if</span> (b)&#123;</span><br><span class="line">        System.out.println(i+<span class="string">&quot;消息发送成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="批量"><a href="#批量" class="headerlink" title="批量"></a>批量</h3><ul><li>先发一批消息，然后一起确认；</li><li>优点：速度快</li><li>缺点：不能确定是哪条消息出错</li><li>使用：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开启发布确认</span></span><br><span class="line">channel.confirmSelect();</span><br><span class="line"><span class="comment">//批量多少开确认一次</span></span><br><span class="line"><span class="type">int</span> <span class="variable">batchSize</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="comment">//批量发消息</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; MessageCount; i++) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> i + <span class="string">&quot;&quot;</span>;</span><br><span class="line">    channel.basicPublish(<span class="string">&quot;&quot;</span>,queueName,<span class="literal">null</span>,message.getBytes());</span><br><span class="line">    <span class="comment">//到100条消息时候，批量确认一次</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="number">1</span>+i)%batchSize ==<span class="number">0</span>)&#123;</span><br><span class="line">        channel.waitForConfirms();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><ul><li><p>hole…</p></li><li><p>使用</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//消息监听器</span></span><br><span class="line">channel.addConfirmListener((tag,multi)-&gt;&#123;</span><br><span class="line">    <span class="comment">//监听 成功 ack</span></span><br><span class="line">    System.out.println(<span class="string">&quot;确认成功的消息：&quot;</span>+tag);</span><br><span class="line">&#125;,(tag,multi)-&gt;&#123;</span><br><span class="line">    <span class="comment">//监听 失败 nack</span></span><br><span class="line">    System.out.println(<span class="string">&quot;确认表示失败的消息：&quot;</span>+tag);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//批量发消息</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; MessageCount; i++) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> i + <span class="string">&quot;&quot;</span>;</span><br><span class="line">    channel.basicPublish(<span class="string">&quot;&quot;</span>,queueName,<span class="literal">null</span>,message.getBytes());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;RabbitMQ持久化&quot;&gt;&lt;a href=&quot;#RabbitMQ持久化&quot; class=&quot;headerlink&quot; title=&quot;RabbitMQ持久化&quot;&gt;&lt;/a&gt;RabbitMQ持久化&lt;/h1&gt;&lt;h2 id=&quot;队列持久化&quot;&gt;&lt;a href=&quot;#队列持久化&quot; class</summary>
      
    
    
    
    
    <category term="RabbitMQ" scheme="http://zswh33.github.io/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ 4.9 SpringBoot与RabbitMQ</title>
    <link href="http://zswh33.github.io/2023/02/28/RabbitMQ-5/"/>
    <id>http://zswh33.github.io/2023/02/28/RabbitMQ-5/</id>
    <published>2023-02-28T14:18:09.000Z</published>
    <updated>2023-03-20T12:33:41.479Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot整合RabbitMQ"><a href="#SpringBoot整合RabbitMQ" class="headerlink" title="SpringBoot整合RabbitMQ"></a>SpringBoot整合RabbitMQ</h1><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Fanout生产者示例"><a href="#Fanout生产者示例" class="headerlink" title="Fanout生产者示例"></a>Fanout生产者示例</h2><ol><li><p>使用RabbitMQConfiguration初始化Exchange、Queue以及进行队列交换机绑定；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMQConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明注册fanout模式的交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> FanoutExchange <span class="title function_">fanoutExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FanoutExchange</span>(<span class="string">&quot;fanoutExchange&quot;</span>,<span class="literal">true</span>,<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//声明队列：save, sms, email, notice</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">saveQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;save.fanout.queue&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">smsQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;sms.fanout.queue&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">emailQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;email.fanout.queue&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">noticeQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;notice.fanout.queue&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//完成绑定关系（队列和交换机完成绑定关系）</span></span><br><span class="line">    <span class="meta">@Bean</span> <span class="keyword">public</span> Binding <span class="title function_">saveBinding</span><span class="params">()</span>&#123;<span class="keyword">return</span> BindingBuilder.bind(saveQueue()).to(fanoutExchange());&#125;</span><br><span class="line">    <span class="meta">@Bean</span> <span class="keyword">public</span> Binding <span class="title function_">smsBinding</span><span class="params">()</span>&#123;<span class="keyword">return</span> BindingBuilder.bind(smsQueue()).to(fanoutExchange());&#125;</span><br><span class="line">    <span class="meta">@Bean</span> <span class="keyword">public</span> Binding <span class="title function_">emailBinding</span><span class="params">()</span>&#123;<span class="keyword">return</span> BindingBuilder.bind(emailQueue()).to(fanoutExchange());&#125;</span><br><span class="line">    <span class="meta">@Bean</span> <span class="keyword">public</span> Binding <span class="title function_">noticeBinding</span><span class="params">()</span>&#123;<span class="keyword">return</span> BindingBuilder.bind(noticeQueue()).to(fanoutExchange());&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用rabbitTemplate进行消息发送</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟用户下单</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uid  x</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pid x</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> num x</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeOrder</span><span class="params">(String uid,String pid,<span class="type">int</span> num)</span>&#123;</span><br><span class="line">        <span class="comment">//生成订单</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">orderId</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">        System.out.println(<span class="string">&quot;生成订单：&quot;</span>+orderId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过MQ发送消息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;fanoutExchange&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">routingKey</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 交换机 ，  路由Key或队列名称，  消息内容</span></span><br><span class="line">        rabbitTemplate.convertAndSend(exchangeName,routingKey,orderId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">OrderService orderService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">    orderService.makeOrder(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="number">123</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="消费者示例"><a href="#消费者示例" class="headerlink" title="消费者示例"></a>消费者示例</h2><p>创建一个Consumer类，使用@Service注解和@RabbitListener注解</p><p>其中：<code>@RabbitListener(queues = &#123;&quot;email.fanout.queue&quot;,&quot;队列名&quot;&#125;)</code>，表示要监听指定队列的消息信息</p><p>然后在类的方法中加注解<code>@RabbitHandler</code>表示该方法负责处理收到的消息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &#123;&quot;email.fanout.queue&quot;&#125;)</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmailConsumer</span> &#123;</span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">recevieMessage</span><span class="params">(String message)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;email 收到订单信息：&quot;</span>+message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DirectExchange生产者示例"><a href="#DirectExchange生产者示例" class="headerlink" title="DirectExchange生产者示例"></a>DirectExchange生产者示例</h2><p>与Fanout不同的是，直接将Bean Exchange的类型改为DirectExchange，然后键Binding Bean的添加方法with绑定RoutingKey即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DirectRabbitMQConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明注册fanout模式的注册机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">directExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(<span class="string">&quot;directExchange&quot;</span>,<span class="literal">true</span>,<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//声明队列：save, sms, email, notice</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">saveQueue_testInDirect</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;save.direct.queue&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">smsQueue_testInDirect</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;sms.direct.queue&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">emailQueue_testInDirect</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;email.direct.queue&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">noticeQueue_testInDirect</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;notice.direct.queue&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//完成绑定关系（队列和交换机完成绑定关系）</span></span><br><span class="line">    <span class="meta">@Bean</span> <span class="keyword">public</span> Binding <span class="title function_">saveBindingInDirect</span><span class="params">()</span>&#123;<span class="keyword">return</span> BindingBuilder.bind(saveQueue_testInDirect()).to(directExchange()).with(<span class="string">&quot;save&quot;</span>);&#125;</span><br><span class="line">    <span class="meta">@Bean</span> <span class="keyword">public</span> Binding <span class="title function_">smsBindingInDirect</span><span class="params">()</span>&#123;<span class="keyword">return</span> BindingBuilder.bind(smsQueue_testInDirect()).to(directExchange()).with(<span class="string">&quot;sms&quot;</span>);&#125;</span><br><span class="line">    <span class="meta">@Bean</span> <span class="keyword">public</span> Binding <span class="title function_">emailBindingInDirect</span><span class="params">()</span>&#123;<span class="keyword">return</span> BindingBuilder.bind(emailQueue_testInDirect()).to(directExchange()).with(<span class="string">&quot;email&quot;</span>);&#125;</span><br><span class="line">    <span class="meta">@Bean</span> <span class="keyword">public</span> Binding <span class="title function_">noticeBindingInDirect</span><span class="params">()</span>&#123;<span class="keyword">return</span> BindingBuilder.bind(noticeQueue_testInDirect()).to(directExchange()).with(<span class="string">&quot;notice&quot;</span>);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TopicExchange注解方式消费者示例"><a href="#TopicExchange注解方式消费者示例" class="headerlink" title="TopicExchange注解方式消费者示例"></a>TopicExchange注解方式消费者示例</h2><p>这个没有可以学到的内容，建议先学@QueueBinding注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(</span></span><br><span class="line"><span class="meta">        bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">                value = @Queue(value = &quot;email.topic.queue&quot;,durable = &quot;true&quot;,autoDelete = &quot;false&quot;),</span></span><br><span class="line"><span class="meta">                exchange = @Exchange(value = &quot;topicExchange&quot;,type = ExchangeTypes.TOPIC),</span></span><br><span class="line"><span class="meta">                key = &quot;#.email.*&quot;</span></span><br><span class="line"><span class="meta">        )</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmailConsumerTopic</span> &#123;</span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">recevieMessage</span><span class="params">(String message)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;email topic 收到订单信息：&quot;</span>+message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="一些SpringBoot的配置"><a href="#一些SpringBoot的配置" class="headerlink" title="一些SpringBoot的配置"></a>一些SpringBoot的配置</h1><h2 id="配置连接名，集群，地址连接方式"><a href="#配置连接名，集群，地址连接方式" class="headerlink" title="配置连接名，集群，地址连接方式"></a>配置连接名，集群，地址连接方式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 配置连接名 */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> SimplePropertyValueConnectionNameStrategy <span class="title function_">cns</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SimplePropertyValueConnectionNameStrategy</span>(<span class="string">&quot;自定义连接Rabbit的名字&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line">ConnectionFactory <span class="title function_">rabbitConnectionFactory</span><span class="params">(ConnectionNameStrategy cns)</span>&#123;</span><br><span class="line">    <span class="type">CachingConnectionFactory</span> <span class="variable">cachingConnectionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CachingConnectionFactory</span>();</span><br><span class="line">    <span class="comment">//配置连接名</span></span><br><span class="line">    cachingConnectionFactory.setConnectionNameStrategy(cns);;</span><br><span class="line">    <span class="comment">//配置集群，多地址</span></span><br><span class="line">    cachingConnectionFactory.setAddresses(<span class="string">&quot;host1:5672,host2:5672,host3:5672&quot;</span>);</span><br><span class="line">    <span class="comment">//设置地址连接方式，默认情况下会随机选择一个地址，若不可用，则从前往后依次连接。</span></span><br><span class="line">    cachingConnectionFactory.setAddressShuffleMode(AbstractConnectionFactory.AddressShuffleMode.RANDOM);</span><br><span class="line">    <span class="keyword">return</span> cachingConnectionFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SpringBoot整合RabbitMQ&quot;&gt;&lt;a href=&quot;#SpringBoot整合RabbitMQ&quot; class=&quot;headerlink&quot; title=&quot;SpringBoot整合RabbitMQ&quot;&gt;&lt;/a&gt;SpringBoot整合RabbitMQ&lt;/h1&gt;&lt;</summary>
      
    
    
    
    
    <category term="RabbitMQ" scheme="http://zswh33.github.io/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ 5 交换机 死信队列 延时队列</title>
    <link href="http://zswh33.github.io/2023/02/28/RabbitMQ-5_v2/"/>
    <id>http://zswh33.github.io/2023/02/28/RabbitMQ-5_v2/</id>
    <published>2023-02-28T14:18:09.000Z</published>
    <updated>2023-03-20T15:27:23.830Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RabbitMQ交换机"><a href="#RabbitMQ交换机" class="headerlink" title="RabbitMQ交换机"></a>RabbitMQ交换机</h1><p>消息路线：生产者 -&gt; 交换机 -&gt; 队列 -&gt; 消费者</p><p>交换机接收生产者的消息，依据routingKey按照指定规则将消息转交给队列。</p><p>类型：<code>     </code>，<code>direct</code>，<code>topic</code>，<code>headers</code>，<code>fanout</code> </p><h2 id="默认交换机"><a href="#默认交换机" class="headerlink" title="默认交换机"></a>默认交换机</h2><p>即：<code> </code></p><p>使用queueName代替routingKey，可以直接向队列中插入数据。</p><h2 id="绑定关系"><a href="#绑定关系" class="headerlink" title="绑定关系"></a>绑定关系</h2><p>除了默认交换机，其他交换机都可将<strong>队列</strong>和<strong>RoutingKey</strong>进行绑定。</p><p>交换机通过RoutingKey来匹配队列，将消息投递。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.queueBind(queueName,Exchange,RoutingKey)</span><br></pre></td></tr></table></figure><h2 id="Fanout交换机"><a href="#Fanout交换机" class="headerlink" title="Fanout交换机"></a>Fanout交换机</h2><p>将接收到的所有消息<strong>广播</strong>。</p><p>队列与该交换机绑定不需要RoutingKey，</p><p>只要绑定了该交换机，该交换机收到的消息都会被传递给绑定的队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*  exchangeName：交换机的名字</span></span><br><span class="line"><span class="comment">*  typeName：交换机类型，fanout等</span></span><br><span class="line"><span class="comment">* public enum BuiltinExchangeType &#123;</span></span><br><span class="line"><span class="comment">*   DIRECT(&quot;direct&quot;),FANOUT(&quot;fanout&quot;),TOPIC(&quot;topic&quot;), *   HEADERS(&quot;headers&quot;);</span></span><br><span class="line"><span class="comment">* &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">channel.exchangeDeclare(exchangeName,BuiltinExchangeType.FANOUT);</span><br></pre></td></tr></table></figure><h2 id="Direct交换机"><a href="#Direct交换机" class="headerlink" title="Direct交换机"></a>Direct交换机</h2><p>将接收到的消息，按照RoutingKey完全匹配的队列进行消息投递。</p><h2 id="Topic交换机"><a href="#Topic交换机" class="headerlink" title="Topic交换机"></a>Topic交换机</h2><p>支持RoutingKey模糊匹配。</p><p>Topic交换机的RoutingKey不能随意写，必须是：一个单词列表，用<code>.</code>分割。</p><p>如：quick.orange.rabbit</p><ul><li><p>其他规则：</p><ul><li><p><code>*</code>可以代替一个单词</p></li><li><p><code>#</code>可以代替0个或多个单词</p></li></ul></li><li><p>若匹配<code>RoutingKey</code>使用<code>#</code>，则匹配任意队列。</p></li></ul><h1 id="临时队列"><a href="#临时队列" class="headerlink" title="临时队列"></a>临时队列</h1><p>可以指定让服务器创建一个临时队列，</p><ul><li>临时队列是一个随机名称的队列，</li><li>一旦断开了消费者的连接，队列将被自动删除。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> channel.queueDeclare().getQueue()</span><br></pre></td></tr></table></figure><p>这种队列有<code>AD</code>标志。AD，即AutoDelete。</p><h1 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h1><p>死信，即无法被消费的信息。</p><p>当Consumer从Queue取出消息进行消费，但由于某些原因使得消费没有被消费，若没有后续的处理，这些消息就变成了<strong>死信</strong>。</p><p>使用RabbitMQ的死信队列机制，当消息发生异常，消息会进入到死信队列中。</p><h2 id="死信的出现"><a href="#死信的出现" class="headerlink" title="死信的出现"></a>死信的出现</h2><ul><li>消息TTL过期</li><li>队列达最大长度，多余添加到</li><li>消息被拒绝<ul><li>basic.reject或basci.nack并且requeue&#x3D;false</li></ul></li></ul><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ol><li>生产者生产消息</li><li>消息被拒绝&#x2F;队列达最大长度&#x2F;TTL过期</li><li>进入dead_exchange死信交换机</li><li>进入死信队列</li></ol><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul><li><p>在需要进行死信处理的队列上添加<strong>死信arguments</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">channel.queueDeclare(NORMAL_QUEUE,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,Object&gt;()&#123;&#123;</span><br><span class="line">    put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>,DEAD_EXCHANGE);  <span class="comment">//死信提交的交换机</span></span><br><span class="line">    put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>,<span class="string">&quot;lisi&quot;</span>);      <span class="comment">//死信</span></span><br><span class="line">&#125;&#125;);</span><br></pre></td></tr></table></figure></li></ul><h2 id="实战1-消息TTL过期"><a href="#实战1-消息TTL过期" class="headerlink" title="实战1 消息TTL过期"></a>实战1 消息TTL过期</h2><ul><li><p>消费者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//普通交换机</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NORMAL_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;normal_exchange&quot;</span>;</span><br><span class="line">    <span class="comment">//死信交换机</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEAD_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;dead_exchange&quot;</span>;</span><br><span class="line">    <span class="comment">//普通队列名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NORMAL_QUEUE</span> <span class="operator">=</span> <span class="string">&quot;normal_queue&quot;</span>;</span><br><span class="line">    <span class="comment">//死信队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEAD_QUEUE</span> <span class="operator">=</span> <span class="string">&quot;dead_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> MQUtils.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明交换机</span></span><br><span class="line">        channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);<span class="comment">//普通交换机</span></span><br><span class="line">        channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);<span class="comment">//死信交换机</span></span><br><span class="line">        <span class="comment">//声明队列</span></span><br><span class="line">        channel.queueDeclare(NORMAL_QUEUE,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,Object&gt;()&#123;&#123;</span><br><span class="line">            put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>,DEAD_EXCHANGE);<span class="comment">//为普通队列添加死信队列</span></span><br><span class="line">            put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>,<span class="string">&quot;lisi&quot;</span>);<span class="comment">//添加死信使用的key</span></span><br><span class="line">        &#125;&#125;);</span><br><span class="line">        channel.queueDeclare(DEAD_QUEUE,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);<span class="comment">//声明死信队列</span></span><br><span class="line">        channel.queueBind(NORMAL_QUEUE,NORMAL_EXCHANGE,<span class="string">&quot;zhangsan&quot;</span>);<span class="comment">//绑定队列</span></span><br><span class="line">        channel.queueBind(DEAD_QUEUE,DEAD_EXCHANGE,<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        channel.basicConsume(NORMAL_QUEUE,<span class="literal">true</span>,(String consumerTag, Delivery message)-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Consumer1接收到消息：&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(message.getBody(), StandardCharsets.UTF_8));</span><br><span class="line">        &#125;,(String consumerTag)-&gt;&#123;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>生产者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> MQUtils.getChannel();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;info&quot;</span>+i;</span><br><span class="line">            channel.basicPublish(</span><br><span class="line">                    Consumer.NORMAL_EXCHANGE,</span><br><span class="line">                    <span class="string">&quot;zhangsan&quot;</span>,</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">AMQP</span>.BasicProperties().builder().expiration(<span class="string">&quot;10000&quot;</span>).build(),</span><br><span class="line">                    message.getBytes());<span class="comment">//生产信息，配置信息的过期时间为10000毫秒</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="实战2-消息队列溢出"><a href="#实战2-消息队列溢出" class="headerlink" title="实战2 消息队列溢出"></a>实战2 消息队列溢出</h2><p>在声明队列的时候，设置队列最大长度，就可实现消息队列消息溢出，消息溢出后即为死信；</p><p>若配置了死信队列，消息会被转移到死信队列中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">channel.queueDeclare(NORMAL_QUEUE,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,Object&gt;()&#123;&#123;</span><br><span class="line">    put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>,DEAD_EXCHANGE);</span><br><span class="line">    put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>,<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">    put(<span class="string">&quot;x-max-length&quot;</span>,<span class="number">6</span>);<span class="comment">//设置队列最大长度</span></span><br><span class="line">&#125;&#125;);</span><br></pre></td></tr></table></figure><h2 id="实战3-消息拒绝"><a href="#实战3-消息拒绝" class="headerlink" title="实战3 消息拒绝"></a>实战3 消息拒绝</h2><p>对消息进行nack，即拒绝消息，并设置不自动回到队列，即可实现消息拒绝，消息会被定为死信。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">p1：消息的Tag</span></span><br><span class="line"><span class="comment">p2：是否批量</span></span><br><span class="line"><span class="comment">p3：是否回到队列，这里为false。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">channel.basicNack(message.getEnvelope().getDeliveryTag(),<span class="literal">false</span>,<span class="literal">false</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="基于死信实现的延迟队列"><a href="#基于死信实现的延迟队列" class="headerlink" title="基于死信实现的延迟队列"></a>基于死信实现的延迟队列</h1><p><em>为队列设置消息的ttl过期，即延时队列。</em></p><p>延时队列并非RabbitMQ原生队列，而是在基础上衍生出来的一种使用方式。</p><p>在RabbitMQ中为队列设置ttl，并设置死信队列，消费者在死信队列进行消费，即<strong>延时队列</strong>。</p><p><strong>注意：RabbitMQ只会检测第一个消息的过期时间，不会检测后面的消息是否过期。</strong></p><p><strong>弥补：插件解决</strong></p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li>订单在十分钟内未支付则自动取消</li><li>新创建的店铺，若10天内没有上传商品，则自动发送消息提醒</li><li>用户注册成功，若3天内未登录自动提醒</li></ol><h1 id="真正的延时队列交换机"><a href="#真正的延时队列交换机" class="headerlink" title="真正的延时队列交换机"></a>真正的延时<del>队列</del>交换机</h1><p>安装<code>rabbitmq_delayed_message_exchange</code>插件实现</p><p>安装后会增加延时交换机类型<code>x-delayed-message</code>。</p><ul><li>使用该交换机的消息，可以增加<code>x-delay</code>属性来支持消息的延时传递，单位毫秒，若未设置<code>x-delay</code>属性，消息会被立即传递。</li><li>该交换机遇上带有<code>x-delay</code>属性的消息后，会将该消息缓存，直到指定的时间结束后，消息会进入到指定的队列中。</li></ul><h2 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h2><h3 id="创建交换机"><a href="#创建交换机" class="headerlink" title="创建交换机"></a>创建交换机</h3><ul><li>需要设交换机类型为<code>x-delayed-message</code></li><li>添加参数<code>x-delayed-type</code>为交换机类型，比如<code>direct</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Exchange <span class="title function_">exchange</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ExchangeBuilder</span>(DELAY_EXCHANGE,<span class="string">&quot;x-delayed-message&quot;</span>).withArgument(<span class="string">&quot;x-delayed-type&quot;</span>,<span class="string">&quot;direct&quot;</span>).build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="向交换机发送消息"><a href="#向交换机发送消息" class="headerlink" title="向交换机发送消息"></a>向交换机发送消息</h3><ul><li>添加参数<code>x-delay</code>为要进行延时的长度，单位毫秒</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send3</span><span class="params">(String message,Integer delay)</span>&#123;</span><br><span class="line">    template.convertAndSend(<span class="string">&quot;delay_exchange_study&quot;</span>,<span class="string">&quot;delay_message_queue_key&quot;</span>,message,(msg)-&gt;&#123;</span><br><span class="line">        msg.getMessageProperties().setDelay(delay);</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="机制"><a href="#机制" class="headerlink" title="机制"></a>机制</h3><p>安装插件后会生成新的Exchange类型<code>x-delayed-message</code>，该类型消息支持延迟投递机制,接收到消息后并未立即将消息投递至目标队列中，而是存储在<code>mnesia</code>(一个分布式数据系统)表中，并且当前节点是磁盘节点，那么节点重启后，消息还能保留。检测消息延迟时间，如达到可投递时间时并将其通过<code>x-delayed-type</code>类型标记的交换机类型投递至目标队列。但是要注意的是，如果集群中只有一个磁盘节点，如果说磁盘节点丢失，或者节点上的插件失效。意味着消息将会丢失。</p><h1 id="延迟队列总结"><a href="#延迟队列总结" class="headerlink" title="延迟队列总结"></a>延迟队列总结</h1><h2 id="其他选择"><a href="#其他选择" class="headerlink" title="其他选择"></a>其他选择</h2><ul><li>Java的<code>DelayQueue</code></li><li><code>Redis</code>的<code>Zset</code></li><li>Quartz</li><li>或Kafka的时间轮。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;RabbitMQ交换机&quot;&gt;&lt;a href=&quot;#RabbitMQ交换机&quot; class=&quot;headerlink&quot; title=&quot;RabbitMQ交换机&quot;&gt;&lt;/a&gt;RabbitMQ交换机&lt;/h1&gt;&lt;p&gt;消息路线：生产者 -&amp;gt; 交换机 -&amp;gt; 队列 -&amp;gt; </summary>
      
    
    
    
    
    <category term="RabbitMQ" scheme="http://zswh33.github.io/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ 3  消息模式 使用场景</title>
    <link href="http://zswh33.github.io/2023/02/27/RabbitMQ-3/"/>
    <id>http://zswh33.github.io/2023/02/27/RabbitMQ-3/</id>
    <published>2023-02-27T13:40:30.000Z</published>
    <updated>2023-03-05T02:25:09.681Z</updated>
    
    <content type="html"><![CDATA[<h1 id="消息模式"><a href="#消息模式" class="headerlink" title="消息模式"></a>消息模式</h1><p><strong>Simple，Work Queue，Publish&#x2F;Subscribe，Routing，Topics</strong>，RPC；</p><p>投递消息过程中，若没有指定交换机，则使用默认的交换机。</p><h2 id="Simple简单模式"><a href="#Simple简单模式" class="headerlink" title="Simple简单模式"></a>Simple简单模式</h2><p>一个生产者，一个消费者</p><p><img src="/2023/02/27/RabbitMQ-3/Simple.svg" alt="Simple"></p><h2 id="Work-Queue工作队列"><a href="#Work-Queue工作队列" class="headerlink" title="Work Queue工作队列"></a>Work Queue工作队列</h2><p>一个生产者，多个消费者，一个消息只能消费一次。</p><p><img src="/2023/02/27/RabbitMQ-3/WorkQueue.svg" alt="WorkQueue"></p><h2 id="Publish-x2F-Subscribe"><a href="#Publish-x2F-Subscribe" class="headerlink" title="Publish&#x2F;Subscribe"></a>Publish&#x2F;Subscribe</h2><p>发布订阅模式。使用fanout交换机。</p><p>生产者首先投递消息到交换机，订阅了这个交换机的所有队列就会收到生产者投递的消息。</p><p><img src="/2023/02/27/RabbitMQ-3/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F.svg" alt="发布订阅模式"></p><h2 id="Routing路由模式"><a href="#Routing路由模式" class="headerlink" title="Routing路由模式"></a>Routing路由模式</h2><p>使用direct交换机</p><p>生产者生产消息投递到direct交换机中，交换机<strong>根据消息携带的RoutingKey匹配相应的队列</strong>。</p><ul><li>比如有三个队列：Q1，Q2，Q3；</li><li>在direct交换机中，指定<ul><li>Q1，mail</li><li>Q2，phone</li><li>Q3，Wechat</li><li>Q2，Wechat</li></ul></li><li>使用该交换机发送消息的时候，会向指定Key对应的队列中发布数据。<ul><li>比如RoutingKey为Wechat时，发布的数据会被发送到Q3和Q2.</li></ul></li></ul><p><img src="/2023/02/27/RabbitMQ-3/direct.svg" alt="路由模式"></p><h2 id="Topics"><a href="#Topics" class="headerlink" title="Topics"></a>Topics</h2><ul><li><p>生产者将消息投递到topic交换机，该交换机<strong>支持根据RoutingKey对队列进行模糊匹配</strong>；</p></li><li><p>发送到Topics消息的RoutingKey<strong>不能随意写</strong>，必须是一个单词列表，每个单词用<code>.</code>分隔开；</p><ul><li><p>如：</p><ul><li><p>com.yn.ZhangSan</p></li><li><p>asd.qwe.zxc</p></li><li><p>其中有两个替换符</p><ul><li><p><code>#</code>：可以替代0个或多个单词</p></li><li><p><code>*</code>：可以替代一个单词</p></li></ul></li></ul></li></ul></li></ul><h2 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h2><p>同时根据header和RoutingKey进行匹配；</p><p>有两种类型</p><ul><li>all：header头必须完全匹配</li><li>any：在Queue的所有键值对在消息的Headers中都能找到，就可匹配成功。</li></ul><p>Header为一个key-value键值对，默认情况下headers为any类型</p><h1 id="声明Exchange和Queue，Java示例"><a href="#声明Exchange和Queue，Java示例" class="headerlink" title="声明Exchange和Queue，Java示例"></a>声明Exchange和Queue，Java示例</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">//1. 创建连接</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">connectionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>()&#123;&#123;</span><br><span class="line">           setHost(<span class="string">&quot;192.168.227.131&quot;</span>);</span><br><span class="line">           setPort(<span class="number">5672</span>);</span><br><span class="line">           setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">           setPassword(<span class="string">&quot;admin123&quot;</span>);</span><br><span class="line">           setVirtualHost(<span class="string">&quot;/&quot;</span>);<span class="comment">//</span></span><br><span class="line">        &#125;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//2. 获取连接</span></span><br><span class="line">            connection = connectionFactory.newConnection(<span class="string">&quot;Test生产者&quot;</span>);</span><br><span class="line">            <span class="comment">//3. 通过连接获取通道Channel</span></span><br><span class="line">            channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;Queue2&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//声明队列</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@params</span>1 队列名称</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@params</span>2 是否要持久化durable</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@params</span>3 排他性，是否独占</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@params</span>4 是否自动删除，即随着最后一个消费者消息完毕后是否把队列删除</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@params</span>5 携带附属参数</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            channel.queueDeclare(<span class="string">&quot;Q1&quot;</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">            channel.queueDeclare(<span class="string">&quot;Q2&quot;</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">            channel.queueDeclare(<span class="string">&quot;Q3&quot;</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            channel.exchangeDeclare(<span class="string">&quot;Exchange1&quot;</span>,<span class="string">&quot;direct&quot;</span>);</span><br><span class="line">            channel.queueBind(<span class="string">&quot;Q1&quot;</span>,<span class="string">&quot;Exchange1&quot;</span>,<span class="string">&quot;order&quot;</span>);</span><br><span class="line">            channel.queueBind(<span class="string">&quot;Q2&quot;</span>,<span class="string">&quot;Exchange1&quot;</span>,<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">            channel.queueBind(<span class="string">&quot;Q3&quot;</span>,<span class="string">&quot;Exchange1&quot;</span>,<span class="string">&quot;pear&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//准备消息内容</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">exchange</span> <span class="operator">=</span> <span class="string">&quot;Exchange1&quot;</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">routeKey</span> <span class="operator">=</span> <span class="string">&quot;apple&quot;</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Hello declare&quot;</span>;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@params</span>1 交换机，消息订阅类型</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@params</span>2 RoutingKey</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@params</span>3 是否持久化，后续详讲</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@params</span>4 信息的二进制数据</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            channel.basicPublish(exchange,routeKey,<span class="literal">null</span>,message.getBytes());</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;消息发送成功&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//关闭通道</span></span><br><span class="line">            <span class="keyword">if</span> (channel!=<span class="literal">null</span> &amp;&amp; channel.isOpen())&#123;</span><br><span class="line">                channel.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//关闭连接</span></span><br><span class="line">            <span class="keyword">if</span> (connection!=<span class="literal">null</span> &amp;&amp; connection.isOpen())&#123;</span><br><span class="line">                connection.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="RabbitMQ消息应答"><a href="#RabbitMQ消息应答" class="headerlink" title="RabbitMQ消息应答"></a>RabbitMQ消息应答</h1><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><h3 id="自动应答"><a href="#自动应答" class="headerlink" title="自动应答"></a>自动应答</h3><p>只要消费者从队列中获取了消息，无论是否消费成功，都认为消息已被消费，队列会把该消息数据删除。</p><h3 id="手动应答"><a href="#手动应答" class="headerlink" title="手动应答"></a>手动应答</h3><h4 id="正常应答"><a href="#正常应答" class="headerlink" title="正常应答"></a>正常应答</h4><ul><li>Channel.basicAck 肯定确认<ul><li>RabbitMQ了解到消息成功处理，将消息丢弃</li></ul></li><li>Channel.basicNack 否定确认</li><li>Channel.basicReject 否定确认，相对于Nack少一个参数；<ul><li>不处理该消息了直接拒绝，可以将其丢弃。</li></ul></li></ul><h4 id="Multiple-批量应答"><a href="#Multiple-批量应答" class="headerlink" title="Multiple 批量应答"></a>Multiple 批量应答</h4><p>可以减少网络拥堵。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">channel.basicAck(deliveryTag,<span class="literal">true</span>);</span><br><span class="line"><span class="comment">//参数2，true表示批量应答</span></span><br></pre></td></tr></table></figure><p>Multiple：</p><ul><li><strong>true</strong>代表批量应答Channel上未应答的消息<ul><li>如Channel上有消息5,6,7,8，当前tag是8，那么此时5-8这些未应答的消息都会被确认应答。</li></ul></li><li><strong>false</strong><ul><li>同上面相比，不会确认5-7的数据。</li><li>一般建议，<strong>不要批量应答</strong></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">channel.basicConsume(<span class="string">&quot;q1&quot;</span>,<span class="literal">false</span>,<span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel)&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费成功：&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(body));</span><br><span class="line">        <span class="built_in">this</span>.getChannel().basicAck(envelope.getDeliveryTag(),<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="重新入队"><a href="#重新入队" class="headerlink" title="重新入队"></a>重新入队</h2><ul><li><p>如果消费者由于某些原因失去连接（其通道已关闭，连接已关闭或TCP连接丢失），导致消息未发送Ack确认，RabbitMQ将了解消息未完全处理，并将其重新排队。</p></li><li><p>若此时其他消费者可以处理，它将很快将其重新分发给另一个消费者。</p></li><li><p>这样，即使某个消费者偶然异常，也能保证不会丢失任何消息。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;消息模式&quot;&gt;&lt;a href=&quot;#消息模式&quot; class=&quot;headerlink&quot; title=&quot;消息模式&quot;&gt;&lt;/a&gt;消息模式&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;Simple，Work Queue，Publish&amp;#x2F;Subscribe，Routing，Topic</summary>
      
    
    
    
    
    <category term="RabbitMQ" scheme="http://zswh33.github.io/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ 2 RabbitMQ安装，配置  Java中使用</title>
    <link href="http://zswh33.github.io/2023/02/27/RabbitMQ-2/"/>
    <id>http://zswh33.github.io/2023/02/27/RabbitMQ-2/</id>
    <published>2023-02-27T01:38:09.000Z</published>
    <updated>2023-03-01T08:39:25.111Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><ul><li><p>新增用户</p><ul><li>&#96;&#96;&#96;bash<br>rabbitmqctl add_user admin admin<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 设置用户分配操作权限</span><br><span class="line"></span><br><span class="line">  - ```bash</span><br><span class="line">    rabbitmqctl set_user_tags admin administrator</span><br></pre></td></tr></table></figure></li></ul></li><li><p>为用户添加资源权限</p><ul><li>&#96;&#96;&#96;bash<br>rabbitmqctl set_permissions -p &#x2F; admin “.<em>“ “.</em>“ “.*”<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 命令</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line">rabbitmqctl add_user USERNAME PASSWORD  #账号密码</span><br><span class="line">rabbitmqctl set_user_tags USERNAME administrator #赋予角色</span><br><span class="line">rabbitmqctl change_password USERNAME NEWPASSWORD # 修改密码</span><br><span class="line">rabbitmqctl list_users # 查看用户清单</span><br><span class="line"></span><br><span class="line">rabbitmqctl [-p &lt;vhostpath&gt;] &lt;user&gt; &lt;conf&gt; &lt;write&gt; &lt;read&gt;</span><br><span class="line">rabbitmqctl set_permissions -p / USERNAME &quot;.*&quot; &quot;.*&quot; &quot;.*&quot; #设置所有权限</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_management <span class="comment"># 添加管理插件</span></span><br><span class="line"><span class="comment"># Web管理插件，默认端口15672.</span></span><br></pre></td></tr></table></figure><p>RabbitMQ默认用户名和密码：guest</p><h1 id="用户级别"><a href="#用户级别" class="headerlink" title="用户级别"></a>用户级别</h1><ul><li>administrator，可以登录控制台，查看所有信息，可以对rabbitmq进行管理；<ul><li>最高权限</li><li>可以创建和删除virtual hosts</li><li>可以查看，创建和删除users</li><li>查看创建permissions</li><li>关闭所有用户的connections</li></ul></li><li>monitoring监控者，登录控制台，查看所有信息<ul><li>包含management所有权限</li><li>罗列出所有的virtual hosts，包括不能登录的virtual ohsts</li><li>查看其他用户的connections和channels信息</li><li>查看节点级别的数据如clustering和memory使用情况</li><li>查看所有的virtual hosts的全局统计信息。</li></ul></li><li>policymaker策略制定者，登录控制台，制定策略<ul><li>包含management所有权限</li><li>查看、创建额删除自己的virtual hosts所属的policies和parameters信息。</li></ul></li><li>managment普通管理员，登录控制台<ul><li>列出自己可以通过AMQP登入的虚拟机</li><li>查看自己的虚拟机节点virtual hosts的queues，exchanges和bindings信息</li><li>查看和关闭自己的channels和connections</li><li>查看有关自己的虚拟机节点virtual hosts的统计信息，包括其他用户在这个节点的virtual hosts的活动信息。</li></ul></li><li>none，不能访问management plugin。</li></ul><h1 id="在Java中使用-x2F-RabbitMQ简单模式实现"><a href="#在Java中使用-x2F-RabbitMQ简单模式实现" class="headerlink" title="在Java中使用&#x2F;RabbitMQ简单模式实现"></a>在Java中使用&#x2F;RabbitMQ简单模式实现</h1><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.rabbitmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>amqp-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.14.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h2><ol><li>创建连接工厂，创建连接Connection</li><li>通过连接获取通道Channel</li><li>通过通道创建交换机，声明队列，绑定关系，路由key，发送消息，接收消息</li><li>声明队列</li><li>准备消息内容</li><li>发送消息给队列</li><li>关闭连接</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">//1. 创建连接</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">connectionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>()&#123;&#123;</span><br><span class="line">           setHost(<span class="string">&quot;192.168.227.131&quot;</span>);</span><br><span class="line">           setPort(<span class="number">5672</span>);</span><br><span class="line">           setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">           setPassword(<span class="string">&quot;admin123&quot;</span>);</span><br><span class="line">           setVirtualHost(<span class="string">&quot;/&quot;</span>);<span class="comment">//</span></span><br><span class="line">        &#125;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//2. 获取连接</span></span><br><span class="line">            connection = connectionFactory.newConnection(<span class="string">&quot;Test生产者&quot;</span>);</span><br><span class="line">            <span class="comment">//3. 通过连接获取通道Channel</span></span><br><span class="line">            channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;Queue1&quot;</span>;</span><br><span class="line">            <span class="comment">//声明队列</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@params</span>1 队列名称</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@params</span>2 是否要持久化durable，是否将队列存储到磁盘</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@params</span>3 排他性，是否只对当前Connection可见。若为true，则其他连接不可见此队列，且在连接断开时删除当前队列。</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@params</span>4 是否自动删除，在最后一个消费者断开连接后是否自动删除。</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@params</span>5 携带附属参数</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            channel.queueDeclare(queueName,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//准备消息内容</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@params</span>1 exchange，交换机</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@params</span>2 当为默认模式，则这里为队列名。其他则为RoutingKey</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@params</span>3 后续详讲</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@params</span>4 消息主体，信息的二进制数据</span></span><br><span class="line"><span class="comment">             * 可以存在没有交换机的队列吗？不可以，若没有输入交换机，则会使用一个默认的交换机</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>,queueName,<span class="literal">null</span>,message.getBytes());</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;消息发送成功&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//关闭通道</span></span><br><span class="line">            <span class="keyword">if</span> (channel!=<span class="literal">null</span> &amp;&amp; channel.isOpen())&#123;</span><br><span class="line">                channel.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//关闭连接</span></span><br><span class="line">            <span class="keyword">if</span> (connection!=<span class="literal">null</span> &amp;&amp; connection.isOpen())&#123;</span><br><span class="line">                connection.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="AMQP流程"><a href="#AMQP流程" class="headerlink" title="AMQP流程"></a>AMQP流程</h1><p>AMQP，Advanced Message Queuing Protocol（高级消息队列协议），是应用层协议的一个开发标准，为面向消息的中间件设计。</p><h2 id="生产者流程"><a href="#生产者流程" class="headerlink" title="生产者流程"></a>生产者流程</h2><ol><li>建立连接</li><li>开启通道</li><li>发送消息</li><li>释放资源（关闭通道）</li><li>关闭连接</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Producer发送          Broker服务器回应</span><br><span class="line">Protocol Header      Connection.Start</span><br><span class="line">Connection.Start-OK  Connection.Tune</span><br><span class="line">Connection.Tune-OK</span><br><span class="line">Connection.Open      Connection.Open-Ok</span><br><span class="line">Channel.Open Channel.Open-Ok</span><br><span class="line">Basic.Publish</span><br><span class="line">Channel.Close  Channel.Close-Ok</span><br><span class="line">Connection.Close     Connection.Close-Ok</span><br></pre></td></tr></table></figure><h2 id="消费者流程"><a href="#消费者流程" class="headerlink" title="消费者流程"></a>消费者流程</h2><ol><li>建立连接</li><li>开启通道</li><li>准备接收消息</li><li>Broken推送消息<ul><li>推送消息</li></ul></li><li>发送确认<ul><li>向Broker发送确认收到消费消息</li><li>Broker收到消息后，会将消息从队列中删除；</li><li>若Broker没有收到Ack，则一直发送消息，直到收到Ack为止。</li></ul></li><li>释放资源</li><li>关闭连接</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Consumer发送          Broker节点回应</span><br><span class="line">Protocol Header      Connection.Start</span><br><span class="line">Connection.Start-OK  Connection.Tune</span><br><span class="line">Connection.Tune-OK</span><br><span class="line">Connection.Open      Connection.Open-Ok</span><br><span class="line">Channel.Open Channel.Open-Ok</span><br><span class="line">Basic.Consume        Basic.Consume-Ok</span><br><span class="line">  Basic.Deliver</span><br><span class="line">Basic.Ack</span><br><span class="line">Channel.Close  Channel.Close-Ok</span><br><span class="line">Connection.Close     Connection.Close-Ok</span><br></pre></td></tr></table></figure><h1 id="RabbitMQ组件与架构"><a href="#RabbitMQ组件与架构" class="headerlink" title="RabbitMQ组件与架构"></a>RabbitMQ组件与架构</h1><p><img src="/2023/02/27/RabbitMQ-2/RabbitMQ%E6%9E%B6%E6%9E%84.svg" alt="RabbitMQ架构"></p><h1 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h1><p><img src="/2023/02/27/RabbitMQ-2/RabbitMQ%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84.svg" alt="RabbitMQ整体架构"></p><h1 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h1><p><img src="/2023/02/27/RabbitMQ-2/RabbitMQ%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B.svg" alt="RabbitMQ运行流程"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;使用&quot;&gt;&lt;a href=&quot;#使用&quot; class=&quot;headerlink&quot; title=&quot;使用&quot;&gt;&lt;/a&gt;使用&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;新增用户&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&amp;#96;&amp;#96;&amp;#96;bash&lt;br&gt;rabbitmqctl add_user</summary>
      
    
    
    
    
    <category term="RabbitMQ" scheme="http://zswh33.github.io/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ 0 中间件 消息中间件常用协议 特点</title>
    <link href="http://zswh33.github.io/2023/02/23/RabbitMQ-0/"/>
    <id>http://zswh33.github.io/2023/02/23/RabbitMQ-0/</id>
    <published>2023-02-23T07:08:52.000Z</published>
    <updated>2023-03-01T08:00:52.695Z</updated>
    
    <content type="html"><![CDATA[<h1 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h1><h2 id="分布式消息中间件"><a href="#分布式消息中间件" class="headerlink" title="分布式消息中间件"></a>分布式消息中间件</h2><h3 id="当前"><a href="#当前" class="headerlink" title="当前"></a>当前</h3><ul><li><p>ActiveMQ</p></li><li><p>RabbitMQ</p><ul><li>在AMQP基础上完成</li><li>优点：<ul><li>基于erlang语言，高并发特性</li><li>吞吐量万级</li><li>MQ功能完善</li><li>支持多种编程语言</li><li>开源管理界面完善</li><li>社区活跃度高</li></ul></li><li>缺点<ul><li>商业版收费</li><li>学习成本高</li></ul></li></ul></li><li><p>Kafka</p><ul><li>优点：性能很强，单机写入TPS约百万条&#x2F;s。</li><li>缺点：<ul><li>在单机超过64队列&#x2F;分区，Load会发生明显的飙高现象。队列越多，load越高，发送响应时间变长；</li><li>一台宕机，就会产生消息乱序。</li><li>消费失败不支持重试</li></ul></li></ul></li><li><p>RocketMQ</p><ul><li>阿里、滴滴开发的国产分布式消息中间件</li><li>优点：<ul><li>单机吞吐量十万级，</li><li>消息可以做到0丢失，</li><li>支持分布式，扩展性好。</li><li>支持10亿级别消息堆积；</li><li>支持自定义</li></ul></li><li>缺点：<ul><li>支持的客户端不多。</li></ul></li></ul></li></ul><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><ul><li>消息中间件监控数据</li><li>异步数据传输场景</li><li>削峰填谷场景</li><li>任务调度场景</li><li>海量数据同步场景</li><li>分布式事务场景</li><li>日记管理场景</li><li>大数据分析场景</li></ul><h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><ul><li>AMQP</li><li>MQTT</li><li>持久化设计</li><li>Kafka协议</li><li>消息分发设计</li><li>高可用</li><li>可靠性</li><li>容错</li></ul><h2 id="负载均衡中间件"><a href="#负载均衡中间件" class="headerlink" title="负载均衡中间件"></a>负载均衡中间件</h2><ul><li>Nginx</li><li>LVS负载均衡<ul><li>对Nginx进行集群</li></ul></li><li>KeepAlive<ul><li>保持心跳，保持高可用</li></ul></li><li>CDN<ul><li>加速</li></ul></li></ul><h2 id="缓存中间件"><a href="#缓存中间件" class="headerlink" title="缓存中间件"></a>缓存中间件</h2><ul><li>MemCache</li><li>Redis</li></ul><h2 id="数据库中间件"><a href="#数据库中间件" class="headerlink" title="数据库中间件"></a>数据库中间件</h2><p><em>Mysql不保证高可用性</em></p><p><em>数据库中间件：实现Mysql集群，高可用性</em></p><ul><li>Mycat</li><li>ShardingJdbc</li></ul><h2 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h2><ul><li>异步数据保存<ul><li>实现削峰</li></ul></li><li>订单数据的消息分发</li><li>分布式事务</li><li>消息的容错</li><li>分布式锁</li><li>分布式会话</li><li>分库分表</li></ul><h2 id="消息中间件核心组成"><a href="#消息中间件核心组成" class="headerlink" title="消息中间件核心组成"></a>消息中间件核心组成</h2><ul><li>消息的协议</li><li>消息的持久化机制</li><li>消息的分发策略</li><li>消息的高可用，高可靠</li><li>消息的容错机制</li></ul><h1 id="网络协议三要素"><a href="#网络协议三要素" class="headerlink" title="网络协议三要素"></a>网络协议三要素</h1><ul><li>语法：语法是用户数据与控制信息的结构与格式以及数据出现的顺序</li><li>语义：语义是解释控制信息的每个部分的意义。它规定了需要发出何种控制信息，以及完成的动作与做出什么样的响应</li><li>时序：时序是对事件发生顺序的详细说明。</li></ul><h1 id="面试：为什么消息中间件不直接使用http协议？"><a href="#面试：为什么消息中间件不直接使用http协议？" class="headerlink" title="面试：为什么消息中间件不直接使用http协议？"></a>面试：为什么消息中间件不直接使用http协议？</h1><ul><li>因为http请求报文头和响应报文头是比较复杂的，包含了cookie，数据的加密解密，状态码，响应码等附加功能，对于一个消息而言，不需要这些复杂的功能，，消息只需要负责数据传递，存储，分发就可以，且追求高性能，进行简洁，快速；</li><li>大部分http使用的是短连接，在实际交互过程中，一个请求到响应很有可能会中断，中断后就不会进行持久化，造成请求的丢失，这样不利于消息中间件的业务场景。消息中间件可能是一个长期获取消息的过程，出现问题和故障要对数据或消息进行持久化等，目的是为了保证消息和数据的高可靠和稳健的运行。</li></ul><h1 id="消息中间件常用协议"><a href="#消息中间件常用协议" class="headerlink" title="消息中间件常用协议"></a>消息中间件常用协议</h1><ul><li>OpenWire，<strong>AMQP，MQTT，Kafka</strong>，OpenMessage协议</li></ul><h2 id="AMQP"><a href="#AMQP" class="headerlink" title="AMQP"></a>AMQP</h2><p>全称：Advanced Message Queuing Protocol</p><p>高级消息队列协议。</p><p>特性</p><ul><li>分布式事务支持</li><li>消息持久化支持</li><li>高性能和高可靠的消息处理优势</li></ul><p>支持者</p><ul><li>RabbitMQ，ActiveMQ</li></ul><h2 id="MQTT"><a href="#MQTT" class="headerlink" title="MQTT"></a>MQTT</h2><p>Message Queuing Telemetry Transport</p><p>是IBM开放的一个即时通讯协议，物联网系统架构的重要组成部分</p><p>特点</p><ul><li>轻量</li><li>结构简单</li><li>速度快，不支持事务</li><li>没有持久化设计</li></ul><p>应用场景</p><ul><li>计算能力有限</li><li>低带宽</li><li>网络不稳定场景</li></ul><p>支持者</p><ul><li>RabbitMQ，AvtiveMQ<ul><li>默认关闭MQTT协议，需要手动打开</li></ul></li></ul><h2 id="OpenMessage"><a href="#OpenMessage" class="headerlink" title="OpenMessage"></a>OpenMessage</h2><p>Apache RocketMQ</p><p>由阿里、雅虎、滴滴、Stremalio等公司共同参与创立的分布式消息中间件、流处理领域的应用开发标准；</p><p>特点：</p><ul><li>结构简单</li><li>解析速度快</li><li>支持事务和持久化设计</li></ul><h2 id="Kafka协议"><a href="#Kafka协议" class="headerlink" title="Kafka协议"></a>Kafka协议</h2><p>Kafka</p><p>基于TCP&#x2F;IP的二进制协议，消息内部通过长度来分割，由一些基本数据类型组成</p><p>特点</p><ul><li>结构简单</li><li>解析速度快</li><li>无事务支持</li><li>有持久化设计</li></ul><h1 id="消息队列持久化"><a href="#消息队列持久化" class="headerlink" title="消息队列持久化"></a>消息队列持久化</h1><p><em>将数据存入磁盘，而不是存在内存中，使数据永久保存</em></p><h1 id="消息队列分发策略"><a href="#消息队列分发策略" class="headerlink" title="消息队列分发策略"></a>消息队列分发策略</h1><p>角色：生产者，存储消息，消费者；</p><h2 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h2><ul><li>生产者生成消息</li><li>MQ进行存储</li><li>消费者通过<strong>PUSH推或PULL拉</strong>的方式获取消息</li></ul><h2 id="多个消息中间件消息分发策略的机制和对比"><a href="#多个消息中间件消息分发策略的机制和对比" class="headerlink" title="多个消息中间件消息分发策略的机制和对比"></a>多个消息中间件消息分发策略的机制和对比</h2><table><thead><tr><th></th><th>ActiveMQ</th><th>RabbitMQ</th><th>Kafka</th><th>RocketMQ</th></tr></thead><tbody><tr><td>发布订阅</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>轮询分发</td><td>支持</td><td>支持</td><td>支持</td><td>&#x2F;</td></tr><tr><td>公平分发</td><td>&#x2F;</td><td>支持</td><td>支持</td><td>&#x2F;</td></tr><tr><td>重发</td><td>支持</td><td>支持</td><td>&#x2F;</td><td>支持</td></tr><tr><td>消息拉取</td><td>&#x2F;</td><td>支持</td><td>支持</td><td>支持</td></tr></tbody></table><ul><li><p>轮询分发：每个服务器分配到的消息数量一致</p></li><li><p>公平分发：每个服务器分配到的消息数量<strong>不一致</strong>，能者多劳 ；</p></li><li><p>消息拉取：很少使用，RPC</p></li></ul><h1 id="消息队列高可用和高可靠"><a href="#消息队列高可用和高可靠" class="headerlink" title="消息队列高可用和高可靠"></a>消息队列高可用和高可靠</h1><h2 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h2><p><em>即：集群。</em></p><p>是指产品在规定的条件和规定的时刻或时间内处于可执行规定功能状态的能力；</p><p>当业务量增加时，请求也过多，一台消息中间件服务器会触及硬件（CPU，内存，磁盘）的极限，一台消息服务器已经无法满足业务的需求，所以消息中间件必须支持集群部署，来达到高可用的目的。</p><p>集群模式1，Master-Slave主从共享数据的部署方式</p><p><img src="/2023/02/23/RabbitMQ-0/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE.drawio.svg" alt="未命名绘图.drawio"></p><p>集群模式2，Master-Slave主从同步部署模式</p><p>集群模式3，多主集群同步部署模式</p><p>集群模式4，多主集群转发部署模式</p><p>集群模式5，Master-Slave与Breok-Cluster组合方案</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>消息共享</li><li>消息同步</li><li>元数据共享</li></ol><h2 id="高可靠"><a href="#高可靠" class="headerlink" title="高可靠"></a>高可靠</h2><p><strong>指系统可以无故障持续运行</strong></p><p>比如一个系统崩溃，报错，异常等不影响线上业务的正常运行，出错率极低，就称之为：高可靠。</p><p>如何保证中间件消息的可靠性？</p><ol><li>消息的传输：通过协议来保证系统间数据解析的正确性</li><li>消息的存储可靠：通过持久化来保证消息的可靠性</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;中间件&quot;&gt;&lt;a href=&quot;#中间件&quot; class=&quot;headerlink&quot; title=&quot;中间件&quot;&gt;&lt;/a&gt;中间件&lt;/h1&gt;&lt;h2 id=&quot;分布式消息中间件&quot;&gt;&lt;a href=&quot;#分布式消息中间件&quot; class=&quot;headerlink&quot; title=&quot;分布式消息</summary>
      
    
    
    
    
    <category term="RabbitMQ" scheme="http://zswh33.github.io/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ 1 分布式消息中间件 MQ选用 RabbitMQ特点，流程，名词介绍</title>
    <link href="http://zswh33.github.io/2023/02/23/RabbitMQ-1_v2/"/>
    <id>http://zswh33.github.io/2023/02/23/RabbitMQ-1_v2/</id>
    <published>2023-02-23T07:08:52.000Z</published>
    <updated>2023-03-01T14:31:29.443Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分布式消息中间件"><a href="#分布式消息中间件" class="headerlink" title="分布式消息中间件"></a>分布式消息中间件</h1><ul><li><p>ActiveMQ</p></li><li><p>RabbitMQ</p><ul><li>在AMQP基础上完成</li><li>优点：<ul><li>基于erlang语言，高并发特性</li><li>吞吐量万级</li><li>MQ功能完善</li><li>支持多种编程语言</li><li>开源管理界面完善</li><li>社区活跃度高</li></ul></li><li>缺点<ul><li>商业版收费</li><li>学习成本高</li></ul></li></ul></li><li><p>Kafka</p><ul><li>优点：性能很强，单机写入TPS约百万条&#x2F;s。</li><li>缺点：<ul><li>在单机超过64队列&#x2F;分区，Load会发生明显的飙高现象。队列越多，load越高，发送响应时间变长；</li><li>一台宕机，就会产生消息乱序。</li><li>消费失败不支持重试</li></ul></li></ul></li><li><p>RocketMQ</p><ul><li>阿里、滴滴开发的国产分布式消息中间件</li><li>优点：<ul><li>单机吞吐量十万级，</li><li>消息可以做到0丢失，</li><li>支持分布式，扩展性好。</li><li>支持10亿级别消息堆积；</li><li>支持自定义</li></ul></li><li>缺点：<ul><li>支持的客户端不多。</li></ul></li></ul></li></ul><h1 id="MQ区别-x2F-MQ选用"><a href="#MQ区别-x2F-MQ选用" class="headerlink" title="MQ区别&#x2F;MQ选用"></a>MQ区别&#x2F;MQ选用</h1><table><thead><tr><th></th><th>ActiveMQ</th><th>RabbitMQ</th><th>Kafka</th><th>RocketMQ</th></tr></thead><tbody><tr><td>发布订阅</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>轮询分发</td><td>支持</td><td>支持</td><td>支持</td><td>&#x2F;</td></tr><tr><td>公平分发</td><td>&#x2F;</td><td>支持</td><td>支持</td><td>&#x2F;</td></tr><tr><td>重发</td><td>支持</td><td>支持</td><td>&#x2F;</td><td>支持</td></tr><tr><td>消息拉取</td><td>&#x2F;</td><td>支持</td><td>支持</td><td>支持</td></tr></tbody></table><ul><li>Kafuka<ul><li>基于Pull模式处理消息消费，追求高吞吐量</li><li><strong>适用于大量数据的互联网服务的数据收集业务</strong></li><li>场景：日志采集</li><li>适合大型公司</li></ul></li><li>RocketMQ<ul><li>适用于可靠性要求较高的场景。</li><li>场景：金融互联网。</li><li>在阿里双11经历多次考验。</li></ul></li><li>RabbitMQ<ul><li>结合erlang语言并发优势，时效性微秒级，社区活跃度高；</li><li>使用方便</li><li>场景：消息量不是那么大的场景</li><li>适合中小型公司。</li></ul></li></ul><h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><p>负责数据存储与转发。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>削峰：将访问的人员进行排队，<ul><li>若一个时间段有20000个请求，而服务器同时只能接收100个请求，RabbitMQ负责将大请求进行排队，依次进入服务器进行处理。</li></ul></li><li>应用解耦<ul><li>在一次订单过程中，订单需要经过：订单系统，库存系统，物流系统，支付系统等几个过程。若其中有任意一个出现问题，订单会执行失败。</li><li>为解决问题，RabbitMQ可以进行解耦。解耦后，任意一个系统出现问题，消息会被缓存到消息队列中，直到系统被修复，这样可以避免整个过程重新执行。</li><li>提升可用性</li></ul></li><li>异步处理<ul><li>若A要调用B且需要B的返回结果，若B需要很长时间，A需要等待B，这个效率很低；</li><li>若MQ出现后，A只需要将消息交给MQ即可，当B完成后，将结果交给MQ，MQ将消息通知给A即可。</li></ul></li></ul><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>RabbitMQ使用的是基于<strong>tcp&#x2F;ip</strong>的<strong>amqp协议</strong></p><ul><li>amqp，即Advanced Message Queuing Protocol，一个提供统一消息服务的应用层标准高级消息队列协议。</li></ul><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ul><li>生产者</li><li>MQ<ul><li>交换机<ul><li>交换机绑定队列</li></ul></li><li>队列<ul><li>队列绑定消费者</li></ul></li></ul></li><li>消费者</li></ul><h2 id="名词介绍"><a href="#名词介绍" class="headerlink" title="名词介绍"></a>名词介绍</h2><ul><li><p><strong>Broker</strong>：接收和分发消息的应用。RabbitMQ Server就是一个Broker</p></li><li><p><strong>Server</strong>：又称Broker，接收客户端的连接，实现AMQP的实体服务；</p></li><li><p><strong>Connection</strong>：连接，应用程序与Broker的TCP&#x2F;IP连接。</p></li><li><p><strong>Channel</strong>：网络信道，几乎所有的操作都在Channel中进行，Channel进行消息读写的通道，客户端可以建立多个Channel，每个Channel代表一个会话任务；</p><ul><li>如果每一次访问创建一个Connection，会建立大量的TCP连接，Connection的开销是巨大的，效率也低。Channel是在Connection内部建立的逻辑连接，若应用程序支持多线程，通常每个thread创建单独的channel进行通讯。</li><li>AMQP报文包含了Channel Id帮助客户端和message broker识别channel，所以channel之间是完全隔离的。</li></ul></li><li><p><strong>Message</strong>：消息，服务器与应用程序之间传送的数据，由Properties和Body组成，</p><ul><li>Properties对消息进行修饰，比如消息的优先级，延迟等高级特性，</li><li>Body是消息体的内容；</li></ul></li><li><p><strong>Virtual Host</strong>：虚拟地址，用于进行逻辑隔离，最上层的消息路由，一个虚拟主机里可以有若干个Exchange和Queue，同一个虚拟主机里面不能有相同名字的Exchange；</p></li><li><p><strong>Exchange</strong>：交换机，接收消息，<strong>根据分发规则</strong>，<strong>匹配Routing Key发送消息到绑定的队列</strong>（不具备消息存储能力）。</p><ul><li>常用类型：direct（point-to-point），topic（publish-subscribe）和fanout（multicast）<ul><li>direct：匹配路由键，只有完全匹配，消息才会被转发</li><li>fanout：将消息发送至所有的队列</li><li>topic：将路由进行<strong>模式匹配</strong><ul><li><code>#</code>匹配一个或多个词</li><li><code>&quot;</code>匹配不多不少一个词</li></ul></li></ul></li></ul></li><li><p><strong>Bindings</strong>：Exchange与Queue之间的虚拟连接，Binding中可以保护多个routing key。</p></li><li><p><strong>Routing key</strong>：生产者将消息发送到交换机时会携带一个key，来制定路由规则；</p></li><li><p><strong>Queue</strong>：队列，也称为Message Queue消息队列，保存消息并将它们转发给消费者。</p></li></ul><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul><li>分布式事务可靠消息的可靠生产</li><li>索引、缓存、静态化处理的数据同步</li><li>流量监控</li><li>日志监控（ELK）</li><li>下单，订单分发，抢票。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;分布式消息中间件&quot;&gt;&lt;a href=&quot;#分布式消息中间件&quot; class=&quot;headerlink&quot; title=&quot;分布式消息中间件&quot;&gt;&lt;/a&gt;分布式消息中间件&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;ActiveMQ&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;RabbitMQ&lt;/p</summary>
      
    
    
    
    
    <category term="RabbitMQ" scheme="http://zswh33.github.io/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>Redis restudy 8 缓存穿透，击穿，雪崩</title>
    <link href="http://zswh33.github.io/2023/02/13/Redis-restudy-8/"/>
    <id>http://zswh33.github.io/2023/02/13/Redis-restudy-8/</id>
    <published>2023-02-13T15:23:29.000Z</published>
    <updated>2023-03-20T14:44:53.823Z</updated>
    
    <content type="html"><![CDATA[<p>参考文献：<a href="https://www.bilibili.com/video/BV1S54y1R7SB">https://www.bilibili.com/video/BV1S54y1R7SB</a></p><h1 id="Redis缓存穿透和雪崩"><a href="#Redis缓存穿透和雪崩" class="headerlink" title="Redis缓存穿透和雪崩"></a>Redis缓存穿透和雪崩</h1><p><img src="/2023/02/13/Redis-restudy-8/%E7%BC%93%E5%AD%98.svg" alt="缓存"></p><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p><em>数据查不到</em></p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li><p>用户想要查询一个数据，发现Redis内存数据没有，也就是缓存没有命中，于是向持久层数据库查询，发现也没有，于是本次查询失败。</p><ul><li><del>有时候，查询失败时，用户会多次发送请求。</del></li></ul></li><li><p>当用户很多的时候，缓存都没有命中，于是都去请求了持久层数据库，这会给持久层数据库造成很大的压力，这时候就相当于出现了缓存穿透。</p></li></ul><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><h4 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h4><p><img src="/2023/02/13/Redis-restudy-8/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8.svg" alt="布隆过滤器"></p><p>布隆过滤器是一种数据结构，对所有可能查询的参数以Hash形式存储，在控制层先校验，不符合则丢弃，从而避免了对底层存储系统的查询压力。</p><h4 id="缓存空对象"><a href="#缓存空对象" class="headerlink" title="缓存空对象"></a>缓存空对象</h4><p><img src="/2023/02/13/Redis-restudy-8/%E7%BC%93%E5%AD%98%E7%A9%BA%E5%AF%B9%E8%B1%A1.svg" alt="缓存空对象"></p><p>当存储层不命中后，即使返回的空对象也将其缓存起来，同时会设置一个过期时间，之后再访问这个数据将会从缓存中获取，保护了后端数据源。</p><blockquote><p> 问题：</p></blockquote><ol><li>若控制能够被缓存起来，就意味着缓存需要更多的空间鵆更多的键，因为这当中可能会有很多的空值的键</li><li>即使对空值设置了过期时间，还是会存在缓存层和存储层的护具会有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响。</li></ol><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p><em>请求量太大，缓存过期</em></p><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>有一个key非常热点，收到大并发的数据访问；</p><p>当这个key失效的瞬间，持续的大并发就会穿破缓存，直接请求数据库，就像是在一个屏障上凿开了一个洞。</p><p>当某个key在过期的瞬间，有大量请求并发访问，这类数据一般是热点数据，由于缓存过期，会同时访问数据库来查询最新数据，并且回写缓存，会导致数据库瞬间压力过大。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol><li>设置热点数据永不过期</li><li>加互斥锁<ul><li>分布式锁：使用分布式锁，保证对于每个key同时只有一个线程去查询后端服务，其他线程没有获得分布式锁的权限，因此只需要等待即可。</li><li>这种方式将高并发的压力转移到了分布式锁，因此对分布式锁的考验很大。</li></ul></li></ol><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p><strong>缓存大面积失效</strong>或<strong>Redis宕机</strong>；</p><h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><ol><li><p>Redis高可用</p><p>多增设几台Redis，即搭建集群</p></li><li><p>限流</p><p>缓存失效后，通过加锁或队列来控制读数据库和写缓存的线程数量；比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。</p></li><li><p>服务降级&#x2F;服务熔断</p><ul><li><p>发生缓存雪崩时，为防止发生连锁的数据库雪崩，甚至整个系统崩溃</p><ul><li><p>服务熔断</p><ul><li>客户端不再请求Redis，直接返回预定义数据或空数据</li></ul></li><li><p>服务降级</p><ul><li><p>当业务应用访问非核心数据时，暂时停止从缓存中查询这些数据，而是直接范围预定义信息或空数据；</p></li><li><p>访问核心数据则正常执行。</p></li></ul></li></ul></li></ul></li><li><p>- </p></li><li><p>数据预热</p><p>在正式部署之前，先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。</p><p>在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间尽量均匀。</p></li><li><p>设置随机过期时间</p><p>尽量保证数据过期时间不同。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考文献：&lt;a href=&quot;https://www.bilibili.com/video/BV1S54y1R7SB&quot;&gt;https://www.bilibili.com/video/BV1S54y1R7SB&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;Redis缓存穿透和雪崩&quot;&gt;&lt;a h</summary>
      
    
    
    
    
    <category term="Redis" scheme="http://zswh33.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis restudy 7 发布订阅 主从复制 哨兵模式</title>
    <link href="http://zswh33.github.io/2023/02/13/Redis-restudy-7/"/>
    <id>http://zswh33.github.io/2023/02/13/Redis-restudy-7/</id>
    <published>2023-02-13T11:29:57.000Z</published>
    <updated>2023-03-20T14:44:45.140Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis发布订阅"><a href="#Redis发布订阅" class="headerlink" title="Redis发布订阅"></a>Redis发布订阅</h1><p><img src="/2023/02/13/Redis-restudy-7/redis_sub.svg" alt="redis_sub"></p><p>Redis可以订阅任何数量的频道。</p><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p><code>psubscribe pattern [pattern ...]</code>：订阅一个或多个符合给定模式的频道</p><p><code>pubsub subcommand [argument [argument ..]]</code>：查询订阅与发布系统状态</p><p><code>publish channel message</code>：将信息发送到指定的频道</p><p><code>punsubscribe [pattern [pattern ...]]</code>：退订所给定模式的频道</p><p><code>subscribe channel [channel ...]</code>：订阅给定的一个或多个频道的信息</p><p><code>unsubscribe [channel [channel ...]]</code>：退订给定的频道</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 订阅频道</span></span><br><span class="line">127.0.0.1:6379&gt; subscribe yn</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) <span class="string">&quot;subscribe&quot;</span></span><br><span class="line">2) <span class="string">&quot;yn&quot;</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 1</span><br><span class="line">1) <span class="string">&quot;message&quot;</span></span><br><span class="line">2) <span class="string">&quot;yn&quot;</span></span><br><span class="line">3) <span class="string">&quot;HelloWorld&quot;</span></span><br><span class="line">1) <span class="string">&quot;message&quot;</span> <span class="comment">#消息</span></span><br><span class="line">2) <span class="string">&quot;yn&quot;</span>  <span class="comment">#来自哪个频道</span></span><br><span class="line">3) <span class="string">&quot;ZhangSan&quot;</span>  <span class="comment">#消息内容</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 频道信息发布</span></span><br><span class="line">127.0.0.1:6379&gt; publish yn HelloWorld</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; publish yn ZhangSan</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>实时消息系统，实时聊天。</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>有更专业的MQ，Redis订阅可能不需要。</p><h1 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>主从复制，将一台Redis服务器的数据，复制到其他Redis服务器。</p><p>前者为主节点（Master&#x2F;leader）,后者为从节点（slave&#x2F;follower）;</p><p>数据复制是单向的，只能由主节点到从节点，Master写为主，Slave读为主。</p><p>主从复制，读写分离！80%的情况下都是在进行读操作，减缓服务器压力。</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ol><li>数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式</li><li>故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障回复，实际上是一种服务的冗余；</li><li>负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供度服务，分担服务器负载；尤其是在写少读多的场景下，通过多个节点分担读负载，可以大大提高Redis服务器并发量。</li><li>高可用基石：主从复制为哨兵和集群提供能够实施的基础，因此主从复制是Redis高可用的基础。</li></ol><p>（“高可用”名词一般用于集群）</p><h2 id="一般来说，Redis在工程项目中了，只用一台Redis是万万不能的"><a href="#一般来说，Redis在工程项目中了，只用一台Redis是万万不能的" class="headerlink" title="一般来说，Redis在工程项目中了，只用一台Redis是万万不能的"></a>一般来说，Redis在工程项目中了，只用一台Redis是万万不能的</h2><ol><li>从结构上，单个Redis服务器会发生单点故障，并且一台服务器需要处理所有的请求负载，压力较大；</li><li>从容量上，单个Redis服务器内存容量有限；一般来说，单台Redis最大使用内存不应该超过20G。</li></ol><p>只要在公司中，主从复制就是要必须使用的，在真实的项目中不可能单机使用Redis。</p><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><ul><li><p>默认情况下，每台Redis服务器都是主节点</p></li><li><p>一个主节点可以有多个从节点，一个从节点只能有一个主节点。</p></li></ul><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>只配置从库，不用配置主库。</p><h3 id="命令-1"><a href="#命令-1" class="headerlink" title="命令"></a>命令</h3><p><code>info replication</code>：查看当前库的信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master  </span><br><span class="line">connected_slaves:0</span><br><span class="line">master_replid:cf3c24d5b4964e0604f7cbc984152291c0175d35</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:0</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:0</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:0</span><br><span class="line">repl_backlog_histlen:0</span><br></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><h4 id="单机测试学习"><a href="#单机测试学习" class="headerlink" title="单机测试学习"></a>单机测试学习</h4><ul><li>准备3-4个配置文件</li></ul><ol><li><p>要进行单机测试的话，要修改的配置</p><ul><li>端口，pid，log文件，备份文件名</li></ul></li><li><p>只需配置从机，不配置主机</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#其中一个从机的信息</span></span><br><span class="line">127.0.0.1:6380&gt; slaveof 127.0.0.1 6379  <span class="comment">#认定指定服务器为主机</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6380&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:slave <span class="comment"># 当前角色：从机</span></span><br><span class="line">master_host:127.0.0.1</span><br><span class="line">master_port:6379</span><br><span class="line">master_link_status:up</span><br><span class="line">master_last_io_seconds_ago:5</span><br><span class="line">master_sync_in_progress:0</span><br><span class="line">slave_repl_offset:0</span><br><span class="line">slave_priority:100</span><br><span class="line">slave_read_only:1</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_replid:36c79b03b82a86ae900da1f1a4c8b98ad063dbdd</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:0</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:0</span><br></pre></td></tr></table></figure></li><li><p>查看结论</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 主机的信息</span></span><br><span class="line">root@yynlinux:~/yn<span class="comment"># redis-cli -p 6379</span></span><br><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:1  <span class="comment">#连接的从机</span></span><br><span class="line">slave0:ip=127.0.0.1,port=6380,state=online,offset=140,lag=0 <span class="comment">#从机的信息</span></span><br><span class="line">master_replid:36c79b03b82a86ae900da1f1a4c8b98ad063dbdd</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:140</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:14</span><br></pre></td></tr></table></figure></li></ol><h4 id="正式配置"><a href="#正式配置" class="headerlink" title="正式配置"></a>正式配置</h4><h5 id="命令配置"><a href="#命令配置" class="headerlink" title="命令配置"></a>命令配置</h5><p>在从机上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6380&gt; slaveof 127.0.0.1 6379  <span class="comment">#认定指定服务器为主机</span></span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>即可实现主从复制。</p><h5 id="配置文件配置"><a href="#配置文件配置" class="headerlink" title="配置文件配置"></a>配置文件配置</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">replicaof &lt;masterip&gt; &lt;masterport&gt; <span class="comment"># 主机ip和端口</span></span><br><span class="line">masterauth &lt;master-password&gt;  <span class="comment">#主机密码，密码和用户可以不存在</span></span><br><span class="line">masteruser &lt;username&gt; <span class="comment">#主机用户</span></span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li><p>主机可以写，从机只能读。</p></li><li><p>主机的数据会被从机自动保存</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在从机写会发生的事情</span></span><br><span class="line">127.0.0.1:6380&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">(error) READONLY You can<span class="string">&#x27;t write against a read only replica.</span></span><br></pre></td></tr></table></figure><ul><li>主机宕机后，从机依旧连接主机；主机如果恢复了，从机依旧能够获取主机的信息。</li><li>命令行配置的主从关系在从机重启后会消失，只有配置文件配置的主从能够保持。</li></ul><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>Slave启动连接后会向master发送一个sync命令，</p><p>master接到命令，启动后台的存盘进程，同时收集所有接受到的用于修改数据集的命令，在后台进程执行结束后，master将整个数据文件发送到slave，并完成一次完全同步；</p><p>全量复制：slave将收到的数据文件，将其存盘并加载到内存中；</p><p>增量复制：Master继续将新的所有收集到的修改命令依次传给slave，完成同步。</p><h2 id="主从复制形式"><a href="#主从复制形式" class="headerlink" title="主从复制形式"></a>主从复制形式</h2><ol><li><p>一个主机带多个从机</p><p><img src="/2023/02/13/Redis-restudy-7/Master-Slave.svg" alt="Master-Slave"></p></li><li><p>一个主机带多个从机，从机再带从机</p><p><img src="/2023/02/13/Redis-restudy-7/Master-Slave2.svg" alt="Master-Slave2"></p><p>（中间的节点仍是从节点，不能写入。）</p></li></ol><h2 id="取消从机模式"><a href="#取消从机模式" class="headerlink" title="取消从机模式"></a>取消从机模式</h2><p>两种方式：</p><ol><li><p>改配置文件，重启</p></li><li><p>命令：<code>slaveof no one</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6380&gt; slaveof no one</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6380&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_replid:31c0ab1d95cc58365a1c357e721646ace499ad92</span><br><span class="line">master_replid2:f7d2c0c54849a249b28c1aaaa3c19595b0b732f9</span><br><span class="line">master_repl_offset:1666</span><br><span class="line">second_repl_offset:1667</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:1666</span><br></pre></td></tr></table></figure></li></ol><h1 id="Redis哨兵模式"><a href="#Redis哨兵模式" class="headerlink" title="Redis哨兵模式"></a>Redis哨兵模式</h1><p>自动选举Master~❤</p><h2 id="传统的主从切换"><a href="#传统的主从切换" class="headerlink" title="传统的主从切换"></a>传统的主从切换</h2><p>当主服务器宕机，需要手动把一台服务器切换为主服务器，这需要人工干预，费时费力，且造成短时间服务不可用。</p><p>Redis2.8正式提供了Sentinel哨兵架构来解决这个问题。</p><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><ul><li><p>哨兵模式能够监控主机是否故障，若故障则根据投票数自动将从库转换为主库。</p></li><li><p>哨兵是一种特殊的模式，哨兵是一个独立的进程，他会独立运行。</p></li><li><p><strong>哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis示例。</strong></p></li></ul><p><img src="/2023/02/13/Redis-restudy-7/%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F.svg" alt="哨兵模式"></p><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>假设主服务器宕机，</p><ul><li>哨兵1会检测到这个结果，系统不会马上进行failover过程，仅仅是哨兵1认为主服务器不可用，这个现象称为<strong>主观下线</strong>；</li><li>当后面的哨兵也检测到主服务器不可用，并达到一定数量时，那么哨兵之间会进行一次投票，投票的结果由一个哨兵发起（这个哨兵是随机的），进行failover[故障转移]操作，切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为<strong>客观下线</strong>。</li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><ol><li><p>配置哨兵配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor 被监控的名称 地址 端口 最低投票数</span><br><span class="line">sentinel monitor r1 127.0.0.1 6379 1</span><br></pre></td></tr></table></figure><ul><li>被监控的名称自定义，不影响结果</li></ul></li><li><p>启动哨兵</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">root@yynlinux:~/yn<span class="comment"># redis-sentinel sentinel.conf</span></span><br><span class="line">63284:X 13 Feb 2023 13:34:16.343 <span class="comment"># oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span></span><br><span class="line">63284:X 13 Feb 2023 13:34:16.345 <span class="comment"># Redis version=6.0.16, bits=64, commit=00000000, modified=0, pid=63284, just started</span></span><br><span class="line">63284:X 13 Feb 2023 13:34:16.346 <span class="comment"># Configuration loaded</span></span><br><span class="line">63284:X 13 Feb 2023 13:34:16.349 * Increased maximum number of open files to 10032 (it was originally <span class="built_in">set</span> to 1024).</span><br><span class="line">                _._</span><br><span class="line">           _.-``__ <span class="string">&#x27;&#x27;</span>-._</span><br><span class="line">      _.-``    `.  `_.  <span class="string">&#x27;&#x27;</span>-._           Redis 6.0.16 (00000000/0) 64 bit</span><br><span class="line">  .-`` .-```.  ```\/    _.,_ <span class="string">&#x27;&#x27;</span>-._</span><br><span class="line"> (    <span class="string">&#x27;      ,       .-`  | `,    )     Running in sentinel mode</span></span><br><span class="line"><span class="string"> |`-._`-...-` __...-.``-._|&#x27;</span>` _.-<span class="string">&#x27;|     Port: 26379</span></span><br><span class="line"><span class="string"> |    `-._   `._    /     _.-&#x27;</span>    |     PID: 63284</span><br><span class="line">  `-._    `-._  `-./  _.-<span class="string">&#x27;    _.-&#x27;</span></span><br><span class="line"> |`-._`-._    `-.__.-<span class="string">&#x27;    _.-&#x27;</span>_.-<span class="string">&#x27;|</span></span><br><span class="line"><span class="string"> |    `-._`-._        _.-&#x27;</span>_.-<span class="string">&#x27;    |           http://redis.io</span></span><br><span class="line"><span class="string">  `-._    `-._`-.__.-&#x27;</span>_.-<span class="string">&#x27;    _.-&#x27;</span></span><br><span class="line"> |`-._`-._    `-.__.-<span class="string">&#x27;    _.-&#x27;</span>_.-<span class="string">&#x27;|</span></span><br><span class="line"><span class="string"> |    `-._`-._        _.-&#x27;</span>_.-<span class="string">&#x27;    |</span></span><br><span class="line"><span class="string">  `-._    `-._`-.__.-&#x27;</span>_.-<span class="string">&#x27;    _.-&#x27;</span></span><br><span class="line">      `-._    `-.__.-<span class="string">&#x27;    _.-&#x27;</span></span><br><span class="line">          `-._        _.-<span class="string">&#x27;</span></span><br><span class="line"><span class="string">              `-.__.-&#x27;</span></span><br><span class="line"></span><br><span class="line">63284:X 13 Feb 2023 13:34:16.371 <span class="comment"># Sentinel ID is aab9a70d6160f5ffdcbc57130a26295510730b10</span></span><br><span class="line">63284:X 13 Feb 2023 13:34:16.372 <span class="comment"># +monitor master r1 127.0.0.1 6379 quorum 1</span></span><br><span class="line">63284:X 13 Feb 2023 13:34:16.377 * +slave slave 127.0.0.1:6380 127.0.0.1 6380 @ r1 127.0.0.1 6379</span><br><span class="line">63284:X 13 Feb 2023 13:36:14.070 <span class="comment"># +sdown master r1 127.0.0.1 6379</span></span><br><span class="line">63284:X 13 Feb 2023 13:36:14.072 <span class="comment"># +odown master r1 127.0.0.1 6379 #quorum 1/1</span></span><br><span class="line">63284:X 13 Feb 2023 13:36:14.073 <span class="comment"># +new-epoch 1</span></span><br><span class="line">63284:X 13 Feb 2023 13:36:14.075 <span class="comment"># +try-failover master r1 127.0.0.1 6379</span></span><br><span class="line">63284:X 13 Feb 2023 13:36:14.084 <span class="comment"># +vote-for-leader aab9a70d6160f5ffdcbc57130a26295510730b10 1</span></span><br><span class="line">63284:X 13 Feb 2023 13:36:14.086 <span class="comment"># +elected-leader master r1 127.0.0.1 6379</span></span><br><span class="line">63284:X 13 Feb 2023 13:36:14.088 <span class="comment"># +failover-state-select-slave master r1 127.0.0.1 6379</span></span><br><span class="line">63284:X 13 Feb 2023 13:36:14.182 <span class="comment"># +selected-slave slave 127.0.0.1:6380 127.0.0.1 6380 @ r1 127.0.0.1 6379</span></span><br><span class="line">63284:X 13 Feb 2023 13:36:14.184 * +failover-state-send-slaveof-noone slave 127.0.0.1:6380 127.0.0.1 6380 @ r1 127.0.0.1 6379</span><br><span class="line">63284:X 13 Feb 2023 13:36:14.243 * +failover-state-wait-promotion slave 127.0.0.1:6380 127.0.0.1 6380 @ r1 127.0.0.1 6379</span><br><span class="line">63284:X 13 Feb 2023 13:36:14.860 <span class="comment"># +promoted-slave slave 127.0.0.1:6380 127.0.0.1 6380 @ r1 127.0.0.1 6379</span></span><br><span class="line">63284:X 13 Feb 2023 13:36:14.862 <span class="comment"># +failover-state-reconf-slaves master r1 127.0.0.1 6379</span></span><br><span class="line">63284:X 13 Feb 2023 13:36:14.938 <span class="comment"># +failover-end master r1 127.0.0.1 6379</span></span><br><span class="line">63284:X 13 Feb 2023 13:36:14.939 <span class="comment"># +switch-master r1 127.0.0.1 6379 127.0.0.1 6380</span></span><br><span class="line">63284:X 13 Feb 2023 13:36:14.942 * +slave slave 127.0.0.1:6379 127.0.0.1 6379 @ r1 127.0.0.1 6380</span><br><span class="line">63284:X 13 Feb 2023 13:36:15.208 * +slave slave 127.0.0.1:6381 127.0.0.1 6381 @ r1 127.0.0.1 6380</span><br><span class="line">63284:X 13 Feb 2023 13:36:44.969 <span class="comment"># +sdown slave 127.0.0.1:6379 127.0.0.1 6379 @ r1 127.0.0.1 6380</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h2 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h2><ul><li>若主机宕机后，哨兵会自动投票选举从机作为主机。</li><li>主机宕机恢复后，哨兵会向该主机发送命令，将该主机变为新主机的从机。</li></ul><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li>主从可以切换，故障可以转移，系统的可用性会更好；</li><li>哨兵模式就是主从模式的升级，手动到自动；</li></ol><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol><li>Redis不易扩容，集群容量一旦达到上限，在线扩容十分麻烦；</li><li>实现哨兵模式的配置麻烦。</li></ol><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bind</span> 127.0.0.1 ::1</span><br><span class="line">port 26379  <span class="comment">#如果有哨兵集群，则需要配置端口</span></span><br><span class="line">daemonize no</span><br><span class="line">pidfile <span class="string">&quot;/var/run/sentinel/redis-sentinel.pid&quot;</span></span><br><span class="line">logfile <span class="string">&quot;/var/log/redis/redis-sentinel.log&quot;</span></span><br><span class="line"><span class="comment"># 指定监听的master</span></span><br><span class="line"><span class="comment">#    quorum 有多少个哨兵认为失联了，就认定主机down了</span></span><br><span class="line"><span class="comment">#sentinel monitor 主机名   地址     端口 quorum</span></span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6379 2</span><br><span class="line"><span class="comment">#配置主机密码</span></span><br><span class="line">sentinel auto-pass &lt;master-name&gt; &lt;password&gt;</span><br><span class="line"><span class="comment"># 指定多长时间，哨兵主观认为master不可用了，单位是毫秒，默认为30秒</span></span><br><span class="line"><span class="comment"># 默认延时操作                      主机名        延时</span></span><br><span class="line">sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;</span><br><span class="line"><span class="comment">#  故障转移时，最多允许多少个从机同时从master进行数据同步。  因此，1则表示串行。设为1保证每次只有一个slave处于不能处理请求的状态</span></span><br><span class="line">sentinel parallel syncs &lt;master-name&gt; &lt;numslaves&gt;</span><br><span class="line"><span class="comment"># 故障转移 超时时间 若超过180000ms没有转移成功，则视为故障转移失败</span></span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置某一事件发生时要执行的脚本</span></span><br><span class="line"><span class="comment"># 通知型脚本：当sentinel有任何警告级别的事件发生时（比如Redis实例主管失效、客观失效等），将会去调用这个脚本，这时脚本应该通过邮件，SMS等方式通知系统管理员关于系统不正常运行的而信息；调用该脚本时，将会给脚本传递两个参数，一个是事件的类型，一个是事件的描述。若配置了这个脚本，则必须保证脚本可执行，否则sentinel无法正常启动</span></span><br><span class="line"><span class="comment"># 规则：</span></span><br><span class="line"><span class="comment"># 1. 若脚本执行后返回1，则该脚本会被再次执行，重复次数默认为10</span></span><br><span class="line"><span class="comment"># 2. 若脚本返回2或一个比2更高的值，脚本不会被重复执行</span></span><br><span class="line"><span class="comment"># 3. 若脚本执行过程中收到中断信号终止了，则同返回值为1的行为相同</span></span><br><span class="line"><span class="comment"># 4. 脚本最大执行时间为60s，超过这个时间会被一个SIGKILL信号终止，之后重新执行。</span></span><br><span class="line">sentinel notification-script mymaster /var/redis/notfiy.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当一个master由于failover而发生改变时，这个脚本将被调用，通知相关的客户端关于master地址已经发生改变的信息，以下参数将会在调用脚本时传给脚本。</span></span><br><span class="line"><span class="comment"># &lt;master-name&gt; &lt;role&gt; &lt;state&gt; &lt;from-ip&gt; &lt;from-port&gt; &lt;to-ip&gt; &lt;to-port&gt;</span></span><br><span class="line">sentinel client-reconfig-script mymaster /var/redis/reconfig.sh</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Redis发布订阅&quot;&gt;&lt;a href=&quot;#Redis发布订阅&quot; class=&quot;headerlink&quot; title=&quot;Redis发布订阅&quot;&gt;&lt;/a&gt;Redis发布订阅&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/2023/02/13/Redis-restudy-7/redi</summary>
      
    
    
    
    
    <category term="Redis" scheme="http://zswh33.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis restudy 6 conf 持久化</title>
    <link href="http://zswh33.github.io/2023/02/13/Redis-restudy-6/"/>
    <id>http://zswh33.github.io/2023/02/13/Redis-restudy-6/</id>
    <published>2023-02-13T07:54:23.000Z</published>
    <updated>2023-03-20T14:45:25.573Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis-conf"><a href="#Redis-conf" class="headerlink" title="Redis.conf"></a>Redis.conf</h1><h2 id="单位"><a href="#单位" class="headerlink" title="单位"></a>单位</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1k =&gt; 1000 bytes</span></span><br><span class="line"><span class="comment"># 1kb =&gt; 1024 bytes</span></span><br><span class="line"><span class="comment"># 1m =&gt; 1000000 bytes</span></span><br><span class="line"><span class="comment"># 1mb =&gt; 1024*1024 bytes</span></span><br><span class="line"><span class="comment"># 1g =&gt; 1000000000 bytes</span></span><br><span class="line"><span class="comment"># 1gb =&gt; 1024*1024*1024 bytes</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># units are case insensitive so 1GB 1Gb 1gB are all the same.</span></span><br></pre></td></tr></table></figure><p>在单位上，大小写不敏感。</p><h2 id="include"><a href="#include" class="headerlink" title="include"></a>include</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># include /path/to/local.conf</span></span><br><span class="line"><span class="comment"># include /path/to/other.conf</span></span><br></pre></td></tr></table></figure><p>可以包含别的配置文件。</p><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bind</span> 127.0.0.1 ::1  <span class="comment">#绑定的IP地址</span></span><br><span class="line">protected-mode <span class="built_in">yes</span> <span class="comment"># 保护模式开关</span></span><br><span class="line">port 6379 <span class="comment"># 端口</span></span><br></pre></td></tr></table></figure><h2 id="General"><a href="#General" class="headerlink" title="General"></a>General</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">daemonize <span class="built_in">yes</span> <span class="comment">#以守护进程方式运行</span></span><br><span class="line">pidfile /var/run/redis/redis-server.pid  <span class="comment">#若以后台方式运行，就需要指定一个pid文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># debug (a lot of information, useful for development/testing)</span></span><br><span class="line"><span class="comment"># verbose (many rarely useful info, but not a mess like the debug level)</span></span><br><span class="line"><span class="comment"># notice (moderately verbose, what you want in production probably) 生产环境适用</span></span><br><span class="line"><span class="comment"># warning (only very important / critical messages are logged)</span></span><br><span class="line">loglevel notice  <span class="comment">#日志级别</span></span><br><span class="line"></span><br><span class="line">logfile /var/log/redis/redis-server.log  <span class="comment">#日志的文件位置</span></span><br><span class="line">databases 16 <span class="comment"># 默认数据库数量</span></span><br><span class="line">always-show-logo <span class="built_in">yes</span>  <span class="comment">#是否总是展示logo</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="SNAPSHOTTING-快照"><a href="#SNAPSHOTTING-快照" class="headerlink" title="SNAPSHOTTING 快照"></a>SNAPSHOTTING 快照</h2><p>持久化，在规定的时间内，执行了多少次操作，则会进行一次持久化。</p><p>Redis是内存数据库，没有持久化，数据断电即失。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save 900 1     <span class="comment">#每隔900秒尝试进行保存，若修改次数&gt;=1则进行一次快照保存</span></span><br><span class="line">save 300 10    <span class="comment">#每隔300秒尝试进行保存，若修改次数&gt;=10则进行一次快照保存</span></span><br><span class="line">save 60 10000  <span class="comment">#每隔60秒尝试进行保存，若修改次数&gt;=10000则进行一次快照保存</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stop-writes-on-bgsave-error <span class="built_in">yes</span>  <span class="comment">#持久化出错，是否继续工作</span></span><br><span class="line">rdbcompression <span class="built_in">yes</span> <span class="comment"># 是否开启rdb文件压缩，需要消耗CPU资源</span></span><br><span class="line">rdbchecksum <span class="built_in">yes</span> <span class="comment">#保存rdb文件时，进行rdb文件校验</span></span><br><span class="line">dbfilename dump.rdb <span class="comment">#rdb文件保存目录</span></span><br></pre></td></tr></table></figure><h2 id="REPLICATION复制"><a href="#REPLICATION复制" class="headerlink" title="REPLICATION复制"></a>REPLICATION复制</h2><p>…</p><h2 id="SECURITY安全"><a href="#SECURITY安全" class="headerlink" title="SECURITY安全"></a>SECURITY安全</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requirepass 123456 <span class="comment"># 设置密码，默认没有密码</span></span><br></pre></td></tr></table></figure><h2 id="CLIENTS客户端"><a href="#CLIENTS客户端" class="headerlink" title="CLIENTS客户端"></a>CLIENTS客户端</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">maxclients 1000 <span class="comment">#设置redis最大客户端数量</span></span><br><span class="line">maxmemory &lt;bytes&gt; <span class="comment">#设置最大内存容量</span></span><br><span class="line">maxmemory-policy noeviction <span class="comment">#内存满了，处理策略</span></span><br><span class="line"><span class="comment">#noeviction: 不删除策略, 达到最大内存限制时, 如果需要更多内存, 直接返回错误信息。（默认值）</span></span><br><span class="line"><span class="comment">#allkeys-lru: 所有key通用; 优先删除最近最少使用(less recently used ,LRU) 的 key。</span></span><br><span class="line"><span class="comment">#volatile-lru: 只限于设置了 expire 的部分; 优先删除最近最少使用(less recently used ,LRU) 的 key。#allkeys-random: 所有key通用; 随机删除一部分 key。</span></span><br><span class="line"><span class="comment">#volatile-random: 只限于设置了 expire 的部分; 随机删除一部分 key。</span></span><br><span class="line"><span class="comment">#volatile-ttl: 只限于设置了 expire 的部分; 优先删除剩余时间(time to live,TTL) 短的key。</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure><h2 id="APPEND-ONLY-MODE-模式-aof"><a href="#APPEND-ONLY-MODE-模式-aof" class="headerlink" title="APPEND ONLY MODE 模式 aof"></a>APPEND ONLY MODE 模式 aof</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">appendonly no  <span class="comment">#默认不开启aof模式，</span></span><br><span class="line"><span class="comment">#默认使用的是rdb方式持久化，大部分情况下rdb够用。</span></span><br><span class="line">appendfilename <span class="string">&quot;appendonly.aof&quot;</span>  <span class="comment">#持久化文件名</span></span><br><span class="line">appendfsync everysec <span class="comment"># 每秒执行一次同步，可能会丢失这一秒的数据</span></span><br><span class="line"><span class="comment">#always  #每次修改值都会写入</span></span><br><span class="line"><span class="comment">#no      #不执行，这个时候操作系统自己同步数据，速度最快。</span></span><br></pre></td></tr></table></figure><h1 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h1><p>参考文献：<a href="https://www.cnblogs.com/xing1/p/16380120.html">https://www.cnblogs.com/xing1/p/16380120.html</a></p><p>Redis是内存数据库，若不将内存中数据库状态保存到磁盘，一旦服务器进程退出，服务器中数据库状态就会消失，所以Redis提供了持久化功能。</p><h2 id="RDB（Redis-Database）"><a href="#RDB（Redis-Database）" class="headerlink" title="RDB（Redis Database）"></a>RDB（Redis Database）</h2><p>指定时间间隔内将内存中数据快照写入磁盘。</p><p>Redis单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程结束了，再用这个临时文件替换上次持久化好的文件。</p><p>主进程不进行任何IO操作，确保了极高的性能。</p><p>如果要大规模进行数据恢复，且对于数据恢复的完整性不是非常敏感，那RDB的方式要比AOF方式更加高效。RDB缺点是最后一次持久化后数据可能丢失。</p><p>默认情况下使用RDB。</p><p>默认保存文件为：dump.rdb</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dbfilename: dump.rdb</span><br></pre></td></tr></table></figure><h3 id="触发条件"><a href="#触发条件" class="headerlink" title="触发条件"></a>触发条件</h3><ol><li>save规则满足</li><li>执行flushall</li><li>关闭redis服务器</li></ol><h3 id="rdb文件恢复"><a href="#rdb文件恢复" class="headerlink" title="rdb文件恢复"></a>rdb文件恢复</h3><p>将rdb文件放到Redis启动目录就可，redis启动会检查rdb文件然后恢复。</p><ul><li>&#x2F;user&#x2F;local&#x2F;bin</li></ul><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li><p>适合大规模数据恢复</p></li><li><p>对数据完成性要求不高</p></li></ol><p>缺点：</p><ol><li>需要一定的时间间隔进程操作。若redis意外宕机了，最后一次修改数据就没有了</li><li>fork进程的时候，会占用一定的内存空间。</li></ol><p>有时候在生产环境我们会对这个文件进行备份。</p><h2 id="AOF（Append-Only-File）"><a href="#AOF（Append-Only-File）" class="headerlink" title="AOF（Append Only File）"></a>AOF（Append Only File）</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>将所有命令都记录下来，恢复的时候就把这个文件再全部执行一遍；</p><p>以日志的形式记录每个写操作，将Redis执行过的所有指令记录下来（不记录读操作），只可追加文件不可改写文件，Redis启动之初会读取该文件重新构建数据，Redis重启的话就根据日志文件的内容将所有指令执行一次以完成数据恢复操作。</p><h3 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h3><p>AOF追加文件会越来越大，这样不合理；</p><p>为了解决这个问题，当文件大到一定程度，会触发<strong>AOF重写</strong>；</p><p>AOF重写会将内存中的数据库用命令的方式重写一个aof文件，来为AOF文件<strong>减肥</strong>。</p><ul><li>当AOF文件体积变得过大时，会fork出一条新进程来将文件重写（先写临时文件，然后rename），遍历新进程的内存数据，每条记录有一条set语句。重写aof文件操作，没有读取旧的aof文件，而是将<strong>整个内存中的数据库内容用命令的方式重写一个新的aof文件</strong>（与快照类似）。</li><li>在子进程重写期间，服务端正常对外服务，服务端会将在重写期间收到的数据缓存到aof_rewrite_buf中，也就是单独开辟一块缓存来存储重写期间收到的命令，在子进程重写完成后，再把缓存的数据追加到新的aof文件中。</li><li>重写期间写出的aof文件是一个临时文件，不是旧文件，在重写结束后会删除旧的aof文件，然后临时文件会rename，成为当前使用的aof文件。</li></ul><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>AOF默认文件：appendonly.aof</p><p><strong>AOF默认不开启</strong>，需要手动开启</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">appendonly no <span class="comment">#no表示关闭 yes表示开启</span></span><br><span class="line">appendfilename <span class="string">&quot;appendonly.aof&quot;</span></span><br><span class="line">no-appendfsync-on-rewrite no <span class="comment">#在执行AOF重写期间是否进行AOF文件同步</span></span><br><span class="line">auto-aof-rewrite-percentage 100 <span class="comment">#目前AOF文件超过上次重写文件的百分之多少时候再次重写，这里指上次重写文件的1倍</span></span><br><span class="line">auto-aof-rewrite-min-size 64mb  <span class="comment">#设置允许重写的最小文件大小，防止文件本身就小还要重写。</span></span><br><span class="line"></span><br><span class="line">aof-use-rdb-preamble no <span class="comment">#Redis4.0新增的RDB-AOF混合持久化方式，其中RDB负责记录已有数据，AOF负责记录最近发生变化的数据。这样就同时兼有AOF和RDB的优点：既能够快速生成重写文件，也能在出现问题时，快速地载入数据。</span></span><br></pre></td></tr></table></figure><h3 id="AOF文件修复"><a href="#AOF文件修复" class="headerlink" title="AOF文件修复"></a>AOF文件修复</h3><p>当aof文件有错误，Redis则无法启动，就需要修复这个aof文件；</p><p>redis提供了一个工具<code>redis-check-aof</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-check-aof --fix appendonly.aof</span><br></pre></td></tr></table></figure><p><code>redis-check-aof</code>修复会删除错误的指令，将错误的数据删除。</p><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ol><li>每次修改都同步，文件完整性更高</li></ol><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li>数据文件大，</li><li>修复速度慢</li><li>AOF运行效率比rdb低</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Redis-conf&quot;&gt;&lt;a href=&quot;#Redis-conf&quot; class=&quot;headerlink&quot; title=&quot;Redis.conf&quot;&gt;&lt;/a&gt;Redis.conf&lt;/h1&gt;&lt;h2 id=&quot;单位&quot;&gt;&lt;a href=&quot;#单位&quot; class=&quot;headerli</summary>
      
    
    
    
    
    <category term="Redis" scheme="http://zswh33.github.io/tags/Redis/"/>
    
  </entry>
  
</feed>
