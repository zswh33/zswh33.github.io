{"meta":{"title":"uwupu Blog","subtitle":"学习日志","description":"一个包含有学习日记的博客","author":"YN","url":"http://zswh33.github.io","root":"/"},"pages":[{"title":"","date":"2023-03-27T16:34:02.939Z","updated":"2023-03-27T16:34:02.939Z","comments":true,"path":"manifest.json","permalink":"http://zswh33.github.io/manifest.json","excerpt":"","text":"{\"name\":\"string\",\"short_name\":\"Junzhou\",\"theme_color\":\"#49b1f5\",\"background_color\":\"#49b1f5\",\"display\":\"standalone\",\"scope\":\"/\",\"start_url\":\"/\",\"icons\":[{\"src\":\"images/pwaicons/512.png\",\"sizes\":\"512x512\",\"type\":\"image/png\"}],\"splash_pages\":\"/\"}"},{"title":"about","date":"2022-08-31T09:25:35.000Z","updated":"2022-08-31T09:27:32.089Z","comments":true,"path":"about/index.html","permalink":"http://zswh33.github.io/about/index.html","excerpt":"","text":"这是一个记录个人学习日志的博客。 嗯 如此.. 联系方式：&#x79;&#x79;&#x6e;&#51;&#x33;&#64;&#x71;&#113;&#46;&#x63;&#111;&#x6d; 其他： 基于hexo 基于fluid的主题"},{"title":"404","date":"2023-03-27T15:39:23.000Z","updated":"2023-03-27T15:39:43.491Z","comments":true,"path":"/404.html","permalink":"http://zswh33.github.io/404.html","excerpt":"","text":""},{"title":"tags","date":"2023-03-27T14:00:26.000Z","updated":"2023-03-27T15:36:48.785Z","comments":true,"path":"tags/index.html","permalink":"http://zswh33.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2023-03-27T14:00:47.000Z","updated":"2023-03-27T15:37:11.002Z","comments":true,"path":"categories/index.html","permalink":"http://zswh33.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"为jar包签名，并验证签名。","slug":"为jar包签名，并验证签名。","date":"2023-05-11T15:26:37.000Z","updated":"2023-05-11T15:49:02.028Z","comments":true,"path":"2023/05/11/为jar包签名，并验证签名。/","link":"","permalink":"http://zswh33.github.io/2023/05/11/%E4%B8%BAjar%E5%8C%85%E7%AD%BE%E5%90%8D%EF%BC%8C%E5%B9%B6%E9%AA%8C%E8%AF%81%E7%AD%BE%E5%90%8D%E3%80%82/","excerpt":"","text":"keytool生成密钥对1keytool -genkeypair -alias KEYALIAS -keyalg RSA -keysize 2048 -validity 36500 -keystore FILE.jks alias 指定密钥对别名 keyalg 指定算法 keysize 指定密钥大小 validity 证书有效期 keystore 密钥库文件名称 jarsigner数字签名以及验证 进行数字签名 1jarsigner -keystore FILE.jks JARFILE.jar KEYALIAS keystore 指定密钥库文件名 JARFILE.jar 指定要签名的Jar文件名称 KEYALIAS 是密钥库中密钥对的别称 验证数字签名 1jarsigner -verify JARFILE.jar -keystore FILE.jks Java中使用Security API对jar文件进行验证","categories":[],"tags":[{"name":"jar","slug":"jar","permalink":"http://zswh33.github.io/tags/jar/"},{"name":"java","slug":"java","permalink":"http://zswh33.github.io/tags/java/"},{"name":"加密","slug":"加密","permalink":"http://zswh33.github.io/tags/%E5%8A%A0%E5%AF%86/"}]},{"title":"SpringCloud 1","slug":"SpringCloud-1","date":"2023-05-10T15:20:57.000Z","updated":"2023-05-10T15:20:57.446Z","comments":true,"path":"2023/05/10/SpringCloud-1/","link":"","permalink":"http://zswh33.github.io/2023/05/10/SpringCloud-1/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Job Study 3 String","slug":"Job-Study-3-String","date":"2023-04-29T08:37:36.000Z","updated":"2023-04-29T09:40:53.960Z","comments":true,"path":"2023/04/29/Job-Study-3-String/","link":"","permalink":"http://zswh33.github.io/2023/04/29/Job-Study-3-String/","excerpt":"","text":"参考文献[1] https://juejin.cn/post/7226157821708648509 [2] https://blog.csdn.net/hl_java/article/details/104352925 final修饰String类123public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence, Constable, ConstantDesc final：表示String类不可被继承 String字符串是常量，一旦被创建，不可改变 String字符串缓冲区支持可变字符串 因为String不可变，即String可共享。 final修饰的value[]1private final char[] value; value是一个私有的字符数组，String通过这个value保存字符串内容。 由final修饰，不可修改。 存储Java中使用字符串常量池存储字符串字面量。 由于JDK版本不同，常量池位置也不同 JDK6及以下字符串常量池在方法区（perm Gen）中，此时常量池存储字符串对象。 在JDK8中，方法区（永久代被元空间取代）。 JDK7，8中，字符串常量池被转移到堆中，此时常量池存储字符串对象的引用，而不是字符串对象本身。 不可变性的优点 只有当字符串不可变，字符串池才可实现。字符串池可以节省很多heap空间，因为不同的字符串引用都可以指向池中同一个字符串。 （存疑）如果字符串可变，可能会引起严重的安全问题。 字符串不可变，使得同一个字符串实例可以被多个线程共享。 字符串不可变，在字符串对象创建的时候，hashCode就被执行并把结果缓存，每次使用hashCode不需要重新计算。字符串变得很容易去成为Map的键。 缺点 丧失灵活性。可以通过StringBuilder弥补这个缺点。 脆弱的不可变性。String可以通过JNI或反射来改变其不可变性。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://zswh33.github.io/tags/Java/"}]},{"title":"Job Study 2","slug":"Job-Study-2","date":"2023-04-29T07:05:55.000Z","updated":"2023-04-29T10:58:41.360Z","comments":true,"path":"2023/04/29/Job-Study-2/","link":"","permalink":"http://zswh33.github.io/2023/04/29/Job-Study-2/","excerpt":"","text":"参考文献[1] https://cloud.tencent.com/developer/article/1872211 Java语言特点 纯面向对象的语言。 具有平台无关性。 解释型语言。（相对的是编译型语言） 很多内置类库，如多线程支持，网络通信支持，垃圾回收器。 较好的安全性和健壮性。提供异常处理和垃圾回收机制。 JDK和JRE区别 JDK：Java Development Kit，开发工具包，提供开发环境和运行环境。 JRE：Java Runtime Environment，Java运行环境。 JDK包含了JRE。 Java数据类型 基本数据类型 整数类型 byte，1字节，-128 ~ 127。 short，2字节，-32768 ~ 32767。 int，4字节，-2^31 ~ 2^31-1 long，8字节，-2^63 ~ 2^63-1 浮点数 float，浮点数，32位，4字节 double，浮点数，64位，8字节 布尔类型 boolean：布尔，占用大小依据虚拟机不同有差异。 在规范上，没有要求boolean占用多大内存。 在遵循规范的基础上，如果boolean是单独使用，boolean占用4字节。如果boolean以数组使用，则一个boolean占用1字节。 字符类型 char：2字节，16位。 引用数据类型 数组 对象 自动装箱拆箱对于Java基础数据类型，都有其对象的包装类。 装箱就是把基本数组类型封装为包装器类型。 拆箱就是自动将包装器类型转换为基础数据类型。 访问修饰符 default：默认修饰符，同一包内可见。 private：同一类内可见 protected：同一包内的类和所有子类可见，不能修饰类。 public：所有类可见。 构造方法，成员变量初始化以及静态成员变量三者初始化顺序先后顺序：静态成员变量，成员变量，构造方法。 详细先后顺序： 父类静态变量， 父类静态代码块， 子类静态变量， 子类静态代码块， 父类成员变量，父类构造方法，子类成员变量，子类构造方法。 面向对象三大特征 继承：对象新类可以从现有的类中派生，派生类可以从它的基类那继承方法和实例变量，且派生类可以修改或新增新的方法使之更适合特殊的需求。 封装：将客观事物抽象成类，每个类可以把自身数据和方法只让可信的类或对象操作，对不可信的类进行信息隐藏。 多态：允许不同类的对象对同一消息做出响应，不同对象调用相同方法即使参数也相同，最终表现行为是不一样的。 Java多态Java多态分为编译时多态和运行时多态。 编译时多态主要指方法的重载，即通过参数列表的不同来区分不同的方法。 运行时多态主要指继承父类和实现接口时，可以使用父类引用指向子类对象。 运行时多态表现：主要依靠方法表，放发表最先存放Object类的方法，接下来是该类父类的方法，最后是该类本身的方法。若子类改写了父类的方法，则子类和父类同名方法共享一个方法表项，都被认作是父类的方法。因此可以实现运行时多态。 Java提供多态机制重载，同一个类有多个同名的方法，方法有不同的参数，在编译期间可以确定调用哪个方法。 覆盖：派生类重写基类的方法。父类引用指向子类对象，在运行时可以确定要调用的方法。 重载和重写的区别 重写是父类与子类的关系。重载是同一类中方法之间的关系。 接口和抽象类的区别 相同 都不能被实例化 接口的实现类或抽象类的子类需实现接口或抽象类中相应的方法才能被实例化。 不同 接口只能有方法定义，不能有方法实现。抽象类可以有方法的定义和实现。 实现接口implement，继承抽象类使用extends。只能“单继承，多实现“。 对于应用 抽象类：当子类和父类之间存在逻辑上的层次接口，建议用抽象类。 接口类：当功能不需要，希望支持差别较大的两个或更多对象间的特定交互行为。 内部类及其作用 成员内部类： 成员内部类可以访问private及以上外部类的属性和方法。 外部类想要访问内部类属性或方法时，必须创建一个内部类对象，然后通过该对象访问内部类的属性或方法。 外部类也可以访问private修饰的内部类属性。 局部内部类： 存在于放啊中的内部类，访问权限类似局部变量，只能访问外部类的final变量。 匿名内部类： 只能用一次，没有类名，只能访问外部类的final变量。 静态内部类 类似类的静态成员变量。 Java的static 修饰成员变量 修饰常用方法 修饰代码块 修饰内部类 为什么String被设计为不可变 节省空间：字符串常量存储在JVM的字符串池中可以被用户共享。 提高效率：String可以被不同线程共享，是线程安全的。在涉及多线程操作中不需要同步操作。 安全：String常用于用户名，密码，文件名使用，由于其不可变，可避免黑客行为对其恶意修改（什么胡言乱语） String，StringBuffer，StringBuilderString类：不可变。 StringBuilder：采用无final修饰的字符数组保存，可变，效率高，线程不安全。 StringBuffer：采用无final修饰的字符数组保存，可变，效率低，线程安全。 StringBuilder和StringBuffer原理上的区别：StringBuffer的所有方法都有synchronized修饰，所以线程安全。 Object类常用方法 hashCode：通过对象计算散列码。常用于map和equals。 equals：判断两个对象是否一致。若equals相同，则hashCode也必须相同。 toString：用String表示该对象。 clone：深拷贝一个对象。 Java一维数组和二维数组声明方式一维数组 12type[] arrayName;type arrayName[]; 二维数组 123type[][] arrayName;type arrayName[][];type[] arrayName[]; Java异常的分类Error：程序无法处理的错误 Exception：程序可以处理的异常 Error常见的有StackOverFlowError，OutOfMemoryError。 Exception分为运行时异常和非运行时异常。对于运行时异常，可以用try，catch处理，也可不处理。对于非运行时异常，则无法通过编译。 throw和throws的区别 throw一般用在方法体内部，用于抛出异常 throws用在方法声明上，代表该方法可能会抛出异常的列表。 finally是否一定会执行 在try语句之前出现异常。 程序在try中出现程序强制退出，如System.exit(0)等方法，finally不会执行。 其他 当try&#x2F;catch&#x2F;finally时，若try中存在return，finally语句会在return之前执行。若try&#x2F;catch&#x2F;finally中都有return语句，finally语句中的return语句会覆盖try&#x2F;catch中的return语句。 final，finally和finalize区别 final，用于声明属性、方法和类，分别表示属性不可变，方法不可重写，类不可继承。 finally作为异常处理的一部分，只能在try&#x2F;catch中使用，finally语句在try&#x2F;catch后一定会被执行，一般用于释放资源。 finalize时Object类的一个方法，在垃圾收集器要回收对象时，会先调用finalize方法，并在下次垃圾回收动作时真正回收对象占用的内存。 泛型即“参数化类型”，解决不确定对象具体类型的问题。 在编译阶段有效，操作的数据类型被指定为一个参数，这种参数类型在类中成为泛型类，接口中称为泛型接口，方法称为泛型方法。 泛型擦除Java编译器生成的字节码不包含泛型西悉尼，泛型类型信息将在编译处理阶段擦除。 注解Java注解用于为Java代码提供元数据。作为元数据，注解不直接影响代码执行，有些类型的注解可以用于这个目的。 可以用于提供信息给编译器，在编译阶段时给软件提供信息进行相关的处理，在运行时处理写相应代码，做对应操作。 元注解元注解可以理解为注解的注解，即在注解中使用，实现想要的功能，具体有： @Retention：表示注解存在阶段。包括：保留在源码，在字节码（类加载），还是在运行期间。 @Target，注解作用范围。 @Document，将注解元素包含到Javadoc中。 @Inherited：一个被@Inherited注解了的注解修饰一个父类，若子类没有被其他注解修饰，则子类继承父类注解。 @Repeatable：被这个元注解修饰的注解可以同时作用一个对象多次，但每次作用注解又可以表示不同的含义。 Java的Class对象Jav中对象可分为实例对象和Class对象，每个类都有一个Class对象，其包含了与该类相关的信息。 获取Class对象的方法。 123Class.forName(&quot;类的全限定名&quot;);实例对象.getClass();类名.class Java反射机制Java反射机制是指程序在运行过程中可以构造任意一个类的对象，获取任意一个类的成员变量和成员方法，获取任意一个对象所属的类信息，调用任意一个对象的属性和方法。反射机制使得Java具有动态获取程序信息和动态调用对象放啊的能力。可以通过以下类调用反射API。 Class类：可以获得类属性方法 Field：可以获得类的成员信息 Method：类的方法信息 Construct：类的构造方法等信息。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://zswh33.github.io/tags/Java/"},{"name":"Job","slug":"Job","permalink":"http://zswh33.github.io/tags/Job/"}]},{"title":"Job Study 1 Java","slug":"Job-Study-1","date":"2023-04-28T15:44:08.000Z","updated":"2023-04-29T07:05:33.171Z","comments":true,"path":"2023/04/28/Job-Study-1/","link":"","permalink":"http://zswh33.github.io/2023/04/28/Job-Study-1/","excerpt":"","text":"Java接口类和抽象类的区别 实现方式不同 抽象类是一个普通的类，使用abstract修饰，可以包含普通方法和抽象方法 接口类是一种特殊的抽象类，使用interface修饰，只能包含抽象方法、常量和默认方法。 继承方式不同 子类只能继承一个抽象类，子类可以实现多个接口。（单继承，多实现） 实现方法不同 抽象类抽象方法可以具体实现代码 接口类抽象方法必须由实现类提供具体实现。 设计目的 抽象类：被继承，提供一些通用的功能和属性，让子类实现自己特有的功能。 接口类：被实现，定义一组规范，规定实现类要实现哪些方法。 重载和重写的区别 重载发生在同一个类中，方法名相同；参数列表，返回类型，权限修饰符可以不同 重写发生在子类中，方法名、参数列表和返回类型都相同，权限修饰符要大于父类方法，声明异常范围要小于弗雷方法，但final和private修饰的方法都不可重写。 &#x3D;&#x3D;和equals的区别&#x3D;&#x3D;用于比较两个对象的引用是否相同。对于基本数据类型，比较两个值是否相等。 equals比较两个对象在逻辑上是否相等，通常需要根据对象的属性值来判断。 异常处理机制Java异常处理机制是一种在程序运行时检测和处理错误的方式。 当出现异常情况，JVM会生成一个异常对象，描述异常的类型和发生的位置。 关键字： try：包裹可能会抛出异常的代码块 catch：捕获try块中抛出的异常，并执行相应的处理逻辑。 finally：无论是否发生异常，都会执行的代码块。常用于资源释放。 throws：声明方法可能抛出的异常类型。 HashMap扩容机制HashMap实现原理HashMap存取原理线程安全的HashMapHashTable与HashMap区别ArrayList和LinkedList区别","categories":[],"tags":[{"name":"Job","slug":"Job","permalink":"http://zswh33.github.io/tags/Job/"}]},{"title":"Openssl 1","slug":"OpenSSL-1","date":"2023-03-27T06:04:02.000Z","updated":"2023-03-27T07:35:43.889Z","comments":true,"path":"2023/03/27/OpenSSL-1/","link":"","permalink":"http://zswh33.github.io/2023/03/27/OpenSSL-1/","excerpt":"","text":"子命令 ca：对整数办法机构CA相关操作的子命令，可用于签发证书，吊销证书 genrsa：生成RSA密钥， genkey：生成密钥的通用子命令 passwd：修改私钥密码的命令 rsa：进行RSA算法相关操作的子命令 x509：与X.509证书操作相关的命令，可以生成证书，查看证书信息。 genrsa用于生成RSA密钥对。 openssl genrsa [options] [-out filename] [numbits] numbits: 密钥长度 -out filename: 输出文件名 -des | -des3 | -aes128 | -aes192 | -aes256：指定加密私钥使用的算法 -passout pass:&quot;123456&quot;：指定加密私钥的密码，这里可以是一个字符串，也可以是一个文件名 -f4：使用F4作为RSA密钥生成器的指数值，F4是一个公认的安全值。 -rand filename：用于提供额外的熵，增加RSA密钥的强度，用于提高RSA密钥对的随机性。 1openssl genrsa -rand /dev/random -out key.pem 2048 -outform format：指定生成文件的格式。可以是pem，der，net等其他格式； rsa用于RSA算法相关的操作 openssl rsa [options] -in filename：输入文件名，必须是一个pem格式的RSA密钥文件，若未指定该参数，则从标准输入流中读取密钥 -out filenmae：指定输出的文件名，未指定则到标准输出流中 -inform 输入文件格式：der, net, pem -outform 输出文件格式：der, net, pem -des | -des3 | -aes128 | -aes192 | -aes256：加密方式 -pubin：指定输入文件为公钥文件，若未指定，默认输入文件为私钥文件 -pubout：指定输出的公钥部分，若指定参数，输出公钥，默认输出私钥 -text：输出密钥的详细信息，则输出RSA密钥的详细信息，包括模数，指数，系数等 -noout：不打印密钥key数据 -passin：指定输入文件的密码； -passout：指定输出文件的密码 dgst 文件签名openssl dgst [options] [filename] filename: 操作的文件 -sign PRIKEY：使用私钥生成一个文件的签名 -verify PUBKEY：使用公钥对一个文件进行验证 --passin pass:&quot;123456&quot;：指定私钥的密码 enc 对文件进行密码加密openssl enc -e ：对文件进行加密操作 -d：对文件进行解密操作 -in FILENAME：输入文件 -out FILENAME：输出文件 -aes256：指定加密方式 rsautl 使用密钥进行文件加密 -encrypt：文件加密 -decrypt：文件解密 -inkey KEY：输入密钥文件 -pubin：指定输入文件为公钥 -in FILENAME：输入文件 -out FILENAME：输出文件","categories":[],"tags":[{"name":"openssl","slug":"openssl","permalink":"http://zswh33.github.io/tags/openssl/"}]},{"title":"RabbitMQ 7","slug":"RabbitMQ-7","date":"2023-03-20T15:53:18.000Z","updated":"2023-03-21T16:16:38.065Z","comments":true,"path":"2023/03/20/RabbitMQ-7/","link":"","permalink":"http://zswh33.github.io/2023/03/20/RabbitMQ-7/","excerpt":"","text":"优先级队列在消息消费时，消息会根据优先级进行排序，优先级高的消息会被最先被消费。 使用队列配置x-max-priority可以配置队列的优先级数。 1return ExchangeBuilder.directExchange(EXCHANGE).withArgument(&quot;x-max-priority&quot;,10).build(); 消息配置发送消息的时候要为消息配置优先级。 1234template.convertAndSend(RabbitMQConfig.EXCHANGE,RabbitMQConfig.QUEUE_KEY,&quot;当前是消息&quot;+i, message -&gt; &#123; message.getMessageProperties().setPriority(7); return message;&#125;); 注意在测试过程中，要为消费者设置较小的basicQos，否则由于消费者一次获取多个消息，无法达到优先队列的效果。 原理RabbitMQ使用堆排序。 惰性队列介绍 惰性队列可以将消息尽可能多地存储在磁盘中，而不是驻留在内存中，直到消费者需要消费相应消息时才会被加载到内存中。 默认情况下，队列会尽可能地将消息存储在内存中，这样可以更快地将消息发给消费者。 即使是持久化队列，也会在内存中驻留一份备份。 当需要释放内存时，RabbitMQ会将消息换页到磁盘中，这个操作会消耗大量时间，并且造成阻塞队列，无法收到新的消息 在惰性队列中， 持久化队列会将收到的消息直接存入文件系统，减少内存消耗，增加I&#x2F;O使用， 若是非持久化消息，将不会发生变化。 配置惰性队列 通过配置arguments来配置惰性队列 12345678@Beanpublic Queue lazyQueue()&#123; return QueueBuilder.durable(&quot;lazyQueue_Study_1030&quot;).withArgument(&quot;x-queue-mode&quot;,&quot;lazy&quot;).build();&#125;@Beanpublic Queue lazyQueue2()&#123; return QueueBuilder.durable(&quot;lazyQueue_Study_10302&quot;).lazy().build();&#125; 通过配置Policy的方式配置惰性队列 hole… RabbitMQ集群配置 1234rabbitmqctl stop_app #停止当前RabbitMQrabbitmqctl reset # 重置RabbitMQrabbitmqctl join_cluster rabbitmq@192.168.x.x:port #加入集群rabbitmqctl start_app # 开启服务 其他命令查看集群状态：rabbitmqctl cluster_status 从集群中删除节点1rabbitmqctl forget_cluster_node rabbitmq@node2 #在集群的任意节点执行 镜像队列镜像队列配置在Policy中，具体配置三个参数 ha-mode：配置镜像队列的复制模式 exactly：队列复制到指定数量的节点 nodes：将队列复制到所有具有相同名称的节点 all：将队列复制到所有节点 ha-params：ha-mode指定后的参数 exactly模式，这里表示要复制的节点数量 nodes模式，这里表示要复制到的节点的名称，如：[&quot;rabbitmq@node1&quot;,&quot;rabbitmq@node2&quot;] ha-sync-mode：表示镜像的同步方式， automatic：异步模式进行同步 manual：需要显式调用API进行同步操作 Haproxy，keepalive实现RabbitMQ的高可用，负载均衡。 Federation插件Federation联邦，用于为用户优选RabbitMQ主机。 使用12rabbitmq-plugins enable rabbitmq_federation #开启插件rabbitmq-plugins enable rabbitmq_federation_management #开启插件","categories":[],"tags":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"http://zswh33.github.io/tags/RabbitMQ/"}]},{"title":"RabbitMQ 6 交换机确认回调 消息回退 备份交换机 幂等性","slug":"RabbitMQ-6","date":"2023-03-20T12:34:28.000Z","updated":"2023-03-20T15:59:12.206Z","comments":true,"path":"2023/03/20/RabbitMQ-6/","link":"","permalink":"http://zswh33.github.io/2023/03/20/RabbitMQ-6/","excerpt":"","text":"发布确认回调通过实现RabbitTemplate.ConfirmCallback接口，可以实现当消息向交换机传递失败时，触发回调方法。 配置文件1spring.rabbitmq.publisher-confirm-type=correlated 该配置用于设置消息从程序传递到交换机，交换机是否响应结果； 参数 CORRELATED：关联模式，消息发送到交换机会触发回调方法 NONE：禁用发布确认，是默认模式。 SIMPLE： 像CORRELATED一样会触发回调方法 发布消息成功后使用rabbitTemplate调用waitForConfirms或waitForConfirmsOrDie方法等待broker节点返回发送结果，根据返回结果来判定下一步的逻辑，要注意的点是waitForConfirmsOrDie方法如果返回false则会关闭channel，则接下来无法发送消息到broker; CORRELATED发布消息12template.convertAndSend(RabbitMQConfig.EXCHANGE,RabbitMQConfig.QUEUE_KEY,m,new CorrelationData(&quot;这是ID&quot;));//new CorrelationData(&quot;这是ID&quot;)，这个参数会在回调函数中获得，一般用于在回调函数中区分被回调的消息。 接收回调123456789101112131415161718192021@Componentpublic class FailedMessageConfig implements RabbitTemplate.ConfirmCallback &#123; @Autowired RabbitTemplate template; @PostConstruct public void init()&#123; template.setConfirmCallback(this); &#125; @Override public void confirm(CorrelationData correlationData, boolean ack, String cause) &#123; String m = &quot;&quot;; if (correlationData!=null)m = correlationData.getId();//这里获取消息的ID if (ack)&#123; System.out.println(&quot;成功发送消息：&quot;+m); &#125;else &#123; System.out.println(&quot;发送消息失败，原因：&quot;+cause); &#125; &#125;&#125; 1发送消息失败，原因：channel error; protocol method: #method&lt;channel.close&gt;(reply-code=404, reply-text=NOT_FOUND - no exchange &#x27;exchange_study_2131q&#x27; in vhost &#x27;/&#x27;, class-id=60, method-id=40) 消息回退 当仅开启了生产者确认机制的情况下，交换机接收到消息后，会直接给消息生产者发送确认消息，如果发现消息该消息不可路由，消息会被直接丢弃。 解决方法 设置mandatory参数，当消息不可到达目的地时将消息返回给生产者。 配置12#当消息不可被路由，回退消息给生产者spring.rabbitmq.publisher-returns=true 使用1234567891011121314151617181920@Componentpublic class FailedMessageConfig implements RabbitTemplate.ReturnsCallback &#123; @Autowired RabbitTemplate template; @PostConstruct public void init()&#123; template.setReturnsCallback(this); &#125; //可以当消息传递过程中，消息不可达目的地，则返回给生产者 @Override public void returnedMessage(ReturnedMessage returned) &#123; System.out.printf(&quot;消息%s,被交换机%s退回，退回原因%s,路由key:%s&quot;, returned.getMessage(), returned.getExchange(), returned.getReplyText(), returned.getRoutingKey()); &#125;&#125; 1消息 你好 ,被交换机 exchange_study_2131 退回，退回原因 NO_ROUTE ,路由key: queue_key_study_2131qwe 备份交换机当交换机无法将消息传递给队列，会将消息传递给备份交换机。 可以在交换机中配置参数：alternate-exchange值为备份交换机的名字。 1234@Beanpublic Exchange directExchange2131()&#123; return ExchangeBuilder.directExchange(EXCHANGE).withArgument(&quot;alternate-exchange&quot;,BACKUP_EXCHANGE).build();&#125; 消息回退与备份交换机当消息回退和备份交换机同时开启时，备份交换机优先级更高。 死信队列和备份交换机的区别使用 死信队列：x-dead-letter-exchange设置死信交换机，x-dead-letter-routing-key设置使用的路由key。 备份交换机：alternate-exchange指定备份交换机的名字。 场景 死信队列：负责处理交换机的消息无法到达队列的情况，消息被拒绝/队列达最大长度/TTL过期。 备份交换机：当消息无法到达交换机时，消息将尝试到达备份交换机。 其他幂等性介绍 要求用户对于同一操作发起的一次或多次请求的结果是一致的，不会因多次请求产生副作用。 解决的问题如：支付，用户购买商品支付，扣款成功，但网络异常，导致二次扣款。 如何出现 消费者在MQ消费消息， 当MQ向消费者发送消息，消费者要返回ACK时，网络中断， 此时MQ没有收到确认消息， 这个消息会被发送给其他消费者， 或在网络恢复后将消息重新发给消费者 产生重复消费。 解决思路 为消息标记一个全局ID或一个唯一标识，每次消费消息前判断该消息是否被消费过。 主流解决方案 唯一ID+指纹码机制 利用数据库主键去重 指纹码：为消息添加唯一标志。 优势：简单 劣势：在高并发时，会出现性能问题。 分布式锁，如利用Redis原子性实现（推荐的方式） 使用Redis的setnx命令。","categories":[],"tags":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"http://zswh33.github.io/tags/RabbitMQ/"}]},{"title":"RabbitMQ 基础知识 1","slug":"RabbitMQ-基础知识-1","date":"2023-03-18T07:00:10.000Z","updated":"2023-03-21T16:06:14.447Z","comments":true,"path":"2023/03/18/RabbitMQ-基础知识-1/","link":"","permalink":"http://zswh33.github.io/2023/03/18/RabbitMQ-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-1/","excerpt":"","text":"为队列设置arguments1234channel.queueDeclare(NORMAL_QUEUE,false,false,false,new HashMap&lt;String,Object&gt;()&#123;&#123; put(&quot;x-dead-letter-exchange&quot;,DEAD_EXCHANGE);//设置死信要送达的交换机 put(&quot;x-dead-letter-routing-key&quot;,&quot;lisi&quot;);//设置死信送达使用的RoutingKey&#125;&#125;); x-dead-letter-exchange：设置死信要送达的交换机 x-dead-letter-routing-key：设置死信送达使用的RoutingKey x-max-length：队列的最大长度 x-message-ttl：设置消息过期时间，单位毫秒 x-max-priority：设置队列支持的消息的优先级级数，默认为10个级数，最大允许255； x-expires：设置队列的自动删除，单位毫秒 x-queue-mode：可以设置队列模式 对于持久化队列，消息会被存储到磁盘中，并在内存不吃紧的情况下，在内存中创建一个备份，这个备份包含队列的部分消息； 默认情况下，内存中的备份会尽可能多的存储消息。 lazy惰性队列：若设置了惰性队列，持久化队列将不在内存中设置备份，只有当被消费者消费的时候才会读入内存。 classic经典：消息会被直接保存在内存中 quorum仲裁：需要安装插件。在多个节点间复制队列，使得队列有更好的可靠性和可扩展性，但会带来一定的性能损失。 ha-mode：集群节点的复制模式。 all：队列将复制到所有的集群节点，并且在从节点不可用时，主节点不再接收新的消息； exactly：队列将在特定数量的节点上进行复制。 ha-params可以指定在多少个节点上进行复制，若不指定，则默认为所有节点。 nodes：队列将复制到指定节点上，通过ha-params指定要复制的节点。 发布消息指定配置原生配置方式12345channel.basicPublish( Consumer.NORMAL_EXCHANGE, &quot;zhangsan&quot;, new AMQP.BasicProperties().builder().expiration(&quot;10000&quot;).build(),//设置发布消息的配置，这里设置消息过期时间10秒 message.getBytes()); SpringBoot配置方式12345678template.convertAndSend( MQUtils.NORMAL_EXCHANGE, MQUtils.NORMAL_QUEUE_1_ROUTINGKEY, message,(msg)-&gt;&#123; msg.getMessageProperties().setExpiration(&quot;10000&quot;); return msg; &#125;); 配置列表 contentType：消息体编码方式，如application/json contentEncoding：消息体的字符集，如UTF-8 deliveryMode：消息持久化，1表示持久化，0表示不持久化。 priority：消息的优先级，默认可以为0-9的整数 correlationId：关联Id，用于关联RPC请求和响应 replyTo：指定回复的队列名称 expiration：过期时间，单位毫秒 若与为队列设置的消息过期时间ttl同时存在，则以值较小的那个为准。 messageId：消息Id headers：存储自定义键值对，可以在不同服务之间传递消息 type：消息类型，可以用于标识消息的目的，如”order_create”或”payment_success”等 timestamp：消息的时间戳，表示消息的创建时间 userId：标识发送消息的用户 appId：应用程序Id，标识发送消息的应用程序 clusterId：集群Id，标识所属集群 Policy配置可以在RabbitMQ的控制台的Admin中配置Policies 配置Policy的参数 Name：Policy的名称 Pattern：配置队列名称的正则表达式 如：^mirror表示以mirror为前缀的队列。mirror_hello Definition：一个JSON对象，包含要为队列设置的属性和选项 message-ttl：消息过期时间 maxlength：队列最大消息数 ha-mode：队列镜像模式 ha-sync-mode：队列的复制模式 ha-params：镜像模式的参数","categories":[],"tags":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"http://zswh33.github.io/tags/RabbitMQ/"}]},{"title":"RabbitMQ 4","slug":"RabbitMQ-4","date":"2023-03-01T15:33:03.000Z","updated":"2023-03-06T06:50:34.622Z","comments":true,"path":"2023/03/01/RabbitMQ-4/","link":"","permalink":"http://zswh33.github.io/2023/03/01/RabbitMQ-4/","excerpt":"","text":"RabbitMQ持久化队列持久化介绍使用在queueDeclare方法上将durable设为true来实现持久化。 12channel.queueDeclare(MQUtils.KEY,true,false,true,null); ^ 消息持久化介绍Hole,… 使用修改basicPublish的参数props为MessageProperties.PERSISTENT_TEXT_PLAIN。 1channel.basicPublish(&quot;&quot;,MQUtils.KEY,MessageProperties.PERSISTENT_TEXT_PLAIN,scanner.next().getBytes()); 消息分发模式注：该模式并非RabbitMQ原本的模式，而是依据RabbitMQ使用方式来衍生出来的使用策略。 默认为轮询模式。 轮询模式：一个消费者一条，按均分配； 公平分发：根据消费者消费能力进行公平分发，处理快的处理的多，处理慢的处理的少。 在Java中，通过设置是否进行自动应答和Qos来进行公平分发模式的实现。 轮询模式 Round-Robin特点：当有多个消费者接入时，消息的分配模式是一个消费者分配一条，直到消费者消费完成 若有2个消费者，1个生产者，不论两个消费者速度快慢，两个消费者收到的消息数量一致。 12345678910111213141516channel.basicConsume(&quot;Queue1&quot;, true, new DeliverCallback() &#123; @Override public void handle(String consumerTag, Delivery message) throws IOException &#123; System.out.println(&quot;收到消息：&quot; + new String( message.getBody())); try &#123; TimeUnit.MILLISECONDS.sleep(1000); &#125; catch (InterruptedException e) &#123; throw new RuntimeException(e); &#125; &#125;&#125;, new CancelCallback() &#123; @Override public void handle(String consumerTag) throws IOException &#123; System.out.println(&quot;消息接受失败。&quot;); &#125;&#125;); 不公平分发能者多劳。 在消费者的channel设置参数Qos为1，即可实现公平分发。 Qos为0则表示轮询模式。 channel.basicQos(1); 12345678910111213channel.basicQos(1);channel.basicConsume(&quot;Queue1&quot;,false,new DefaultConsumer(channel)&#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; System.out.println(&quot;消费成功：&quot;+new String(body)); try &#123; TimeUnit.MILLISECONDS.sleep(500); &#125; catch (InterruptedException e) &#123; throw new RuntimeException(e); &#125; this.getChannel().basicAck(envelope.getDeliveryTag(),false); &#125;&#125;); 预取值prefetch 信道缓存区的大小，通过basic.qos来设置消费者“预取计数”值来完成； 定义通道上允许的未确认消息的最大数量，一旦达到配置的数量，RabbitMQ将停止在通道上传递更多消息，直到至少有1个未处理的消息被确认。 1channel.basicQos(prefetchSize); 发布确认介绍 信道的confirm模式； 在信道confirm模式下，生产者向Broker发送消息后，都会收到来自Broker的反馈； 若生产者要求消息持久化，Broker会在将消息持久化之后向生产者发送反馈； 原理：在confirm模式下，所有在该信道上面发布的消息都会被指派一个唯一的ID，一旦消息被投递到所有匹配的队列后，Broker会向生产者发送一条确认通知（包含消息的ID），这样生产者就会了解到消息是否成功送达队列。若消息是可持久化的，则确认通知会在消息写入磁盘后发出； Broker的确认通知中delivery-tag域包含了消息是否已送达和消息的确认序列号； 若RabbitMQ因内部原因导致消息丢失，就会发送一条nack消息表示消息出错。 Broker可以设置basic.ack的multiple域，表示这个序列号之前的所有消息都已经得到处理。 confirm是异步的，生产者在等待确认通知的同时也可以继续发送下一跳消息；生产者在收到nack消息后可以在回调方法中处理该nack消息。 开启confirm模式在信道上使用confirmSelect()方法开启confirm模式。 channel.confirmSelect() 确认发布模式单个确认发布 一种简单的确认方式，它是一种同步确认发布的方式， 发布一个消息后，只有这个消息被确认，后续的消息才能继续发布 waitForConfirmDie(long)，在指定时间内收到确认则返回，若在时间范围内未确认则抛出异常。 缺点 发布速度特别慢 场景：每秒不超过数百条发布消息吞吐量，有些应用程序是可以用的。 使用： 123456789101112//开启发布确认channel.confirmSelect();//批量发消息for (int i = 0; i &lt; MessageCount; i++) &#123; String message = i + &quot;&quot;; channel.basicPublish(&quot;&quot;,queueName,null,message.getBytes()); //单个消息，发布后马上确认 boolean b = channel.waitForConfirms(); if (b)&#123; System.out.println(i+&quot;消息发送成功&quot;); &#125;&#125; 批量 先发一批消息，然后一起确认； 优点：速度快 缺点：不能确定是哪条消息出错 使用： 12345678910111213//开启发布确认channel.confirmSelect();//批量多少开确认一次int batchSize = 100;//批量发消息for (int i = 0; i &lt; MessageCount; i++) &#123; String message = i + &quot;&quot;; channel.basicPublish(&quot;&quot;,queueName,null,message.getBytes()); //到100条消息时候，批量确认一次 if ((1+i)%batchSize ==0)&#123; channel.waitForConfirms(); &#125;&#125; 异步 hole… 使用 1234567891011121314//消息监听器channel.addConfirmListener((tag,multi)-&gt;&#123; //监听 成功 ack System.out.println(&quot;确认成功的消息：&quot;+tag);&#125;,(tag,multi)-&gt;&#123; //监听 失败 nack System.out.println(&quot;确认表示失败的消息：&quot;+tag);&#125;);//批量发消息for (int i = 0; i &lt; MessageCount; i++) &#123; String message = i + &quot;&quot;; channel.basicPublish(&quot;&quot;,queueName,null,message.getBytes());&#125;","categories":[],"tags":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"http://zswh33.github.io/tags/RabbitMQ/"}]},{"title":"RabbitMQ 4.9 SpringBoot与RabbitMQ","slug":"RabbitMQ-5","date":"2023-02-28T14:18:09.000Z","updated":"2023-03-20T12:33:41.479Z","comments":true,"path":"2023/02/28/RabbitMQ-5/","link":"","permalink":"http://zswh33.github.io/2023/02/28/RabbitMQ-5/","excerpt":"","text":"SpringBoot整合RabbitMQ依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;&lt;/dependency&gt; Fanout生产者示例 使用RabbitMQConfiguration初始化Exchange、Queue以及进行队列交换机绑定； 12345678910111213141516171819202122232425262728293031323334@Configurationpublic class RabbitMQConfiguration &#123; //声明注册fanout模式的交换机 @Bean public FanoutExchange fanoutExchange()&#123; return new FanoutExchange(&quot;fanoutExchange&quot;,true,false); &#125; //声明队列：save, sms, email, notice @Bean public Queue saveQueue()&#123; return new Queue(&quot;save.fanout.queue&quot;,true); &#125; @Bean public Queue smsQueue()&#123; return new Queue(&quot;sms.fanout.queue&quot;,true); &#125; @Bean public Queue emailQueue()&#123; return new Queue(&quot;email.fanout.queue&quot;,true); &#125; @Bean public Queue noticeQueue()&#123; return new Queue(&quot;notice.fanout.queue&quot;,true); &#125; //完成绑定关系（队列和交换机完成绑定关系） @Bean public Binding saveBinding()&#123;return BindingBuilder.bind(saveQueue()).to(fanoutExchange());&#125; @Bean public Binding smsBinding()&#123;return BindingBuilder.bind(smsQueue()).to(fanoutExchange());&#125; @Bean public Binding emailBinding()&#123;return BindingBuilder.bind(emailQueue()).to(fanoutExchange());&#125; @Bean public Binding noticeBinding()&#123;return BindingBuilder.bind(noticeQueue()).to(fanoutExchange());&#125;&#125; 使用rabbitTemplate进行消息发送 1234567891011121314151617181920212223@Servicepublic class OrderService &#123; @Autowired private RabbitTemplate rabbitTemplate; /** * 模拟用户下单 * @param uid x * @param pid x * @param num x */ public void makeOrder(String uid,String pid,int num)&#123; //生成订单 String orderId = UUID.randomUUID().toString(); System.out.println(&quot;生成订单：&quot;+orderId); //通过MQ发送消息 String exchangeName = &quot;fanoutExchange&quot;; String routingKey = &quot;&quot;; // 交换机 ， 路由Key或队列名称， 消息内容 rabbitTemplate.convertAndSend(exchangeName,routingKey,orderId); &#125;&#125; 1234567@AutowiredOrderService orderService;@Testvoid contextLoads() &#123; orderService.makeOrder(&quot;1&quot;,&quot;1&quot;,123);&#125; 消费者示例创建一个Consumer类，使用@Service注解和@RabbitListener注解 其中：@RabbitListener(queues = &#123;&quot;email.fanout.queue&quot;,&quot;队列名&quot;&#125;)，表示要监听指定队列的消息信息 然后在类的方法中加注解@RabbitHandler表示该方法负责处理收到的消息。 12345678@RabbitListener(queues = &#123;&quot;email.fanout.queue&quot;&#125;)@Servicepublic class EmailConsumer &#123; @RabbitHandler public void recevieMessage(String message)&#123; System.out.println(&quot;email 收到订单信息：&quot;+message); &#125;&#125; DirectExchange生产者示例与Fanout不同的是，直接将Bean Exchange的类型改为DirectExchange，然后键Binding Bean的添加方法with绑定RoutingKey即可。 123456789101112131415161718192021222324252627282930313233@Configurationpublic class DirectRabbitMQConfiguration &#123; //声明注册fanout模式的注册机 @Bean public DirectExchange directExchange()&#123; return new DirectExchange(&quot;directExchange&quot;,true,false); &#125; //声明队列：save, sms, email, notice @Bean public Queue saveQueue_testInDirect()&#123; return new Queue(&quot;save.direct.queue&quot;,true); &#125; @Bean public Queue smsQueue_testInDirect()&#123; return new Queue(&quot;sms.direct.queue&quot;,true); &#125; @Bean public Queue emailQueue_testInDirect()&#123; return new Queue(&quot;email.direct.queue&quot;,true); &#125; @Bean public Queue noticeQueue_testInDirect()&#123; return new Queue(&quot;notice.direct.queue&quot;,true); &#125; //完成绑定关系（队列和交换机完成绑定关系） @Bean public Binding saveBindingInDirect()&#123;return BindingBuilder.bind(saveQueue_testInDirect()).to(directExchange()).with(&quot;save&quot;);&#125; @Bean public Binding smsBindingInDirect()&#123;return BindingBuilder.bind(smsQueue_testInDirect()).to(directExchange()).with(&quot;sms&quot;);&#125; @Bean public Binding emailBindingInDirect()&#123;return BindingBuilder.bind(emailQueue_testInDirect()).to(directExchange()).with(&quot;email&quot;);&#125; @Bean public Binding noticeBindingInDirect()&#123;return BindingBuilder.bind(noticeQueue_testInDirect()).to(directExchange()).with(&quot;notice&quot;);&#125;&#125; TopicExchange注解方式消费者示例这个没有可以学到的内容，建议先学@QueueBinding注解 1234567891011121314@RabbitListener( bindings = @QueueBinding( value = @Queue(value = &quot;email.topic.queue&quot;,durable = &quot;true&quot;,autoDelete = &quot;false&quot;), exchange = @Exchange(value = &quot;topicExchange&quot;,type = ExchangeTypes.TOPIC), key = &quot;#.email.*&quot; ))@Servicepublic class EmailConsumerTopic &#123; @RabbitHandler public void recevieMessage(String message)&#123; System.out.println(&quot;email topic 收到订单信息：&quot;+message); &#125;&#125; 一些SpringBoot的配置配置连接名，集群，地址连接方式1234567891011121314151617/* 配置连接名 */@Beanpublic SimplePropertyValueConnectionNameStrategy cns()&#123; return new SimplePropertyValueConnectionNameStrategy(&quot;自定义连接Rabbit的名字&quot;);&#125;@BeanConnectionFactory rabbitConnectionFactory(ConnectionNameStrategy cns)&#123; CachingConnectionFactory cachingConnectionFactory = new CachingConnectionFactory(); //配置连接名 cachingConnectionFactory.setConnectionNameStrategy(cns);; //配置集群，多地址 cachingConnectionFactory.setAddresses(&quot;host1:5672,host2:5672,host3:5672&quot;); //设置地址连接方式，默认情况下会随机选择一个地址，若不可用，则从前往后依次连接。 cachingConnectionFactory.setAddressShuffleMode(AbstractConnectionFactory.AddressShuffleMode.RANDOM); return cachingConnectionFactory;&#125;","categories":[],"tags":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"http://zswh33.github.io/tags/RabbitMQ/"}]},{"title":"RabbitMQ 5 交换机 死信队列 延时队列","slug":"RabbitMQ-5_v2","date":"2023-02-28T14:18:09.000Z","updated":"2023-03-20T15:27:23.830Z","comments":true,"path":"2023/02/28/RabbitMQ-5_v2/","link":"","permalink":"http://zswh33.github.io/2023/02/28/RabbitMQ-5_v2/","excerpt":"","text":"RabbitMQ交换机消息路线：生产者 -&gt; 交换机 -&gt; 队列 -&gt; 消费者 交换机接收生产者的消息，依据routingKey按照指定规则将消息转交给队列。 类型： ，direct，topic，headers，fanout 默认交换机即： 使用queueName代替routingKey，可以直接向队列中插入数据。 绑定关系除了默认交换机，其他交换机都可将队列和RoutingKey进行绑定。 交换机通过RoutingKey来匹配队列，将消息投递。 1channel.queueBind(queueName,Exchange,RoutingKey) Fanout交换机将接收到的所有消息广播。 队列与该交换机绑定不需要RoutingKey， 只要绑定了该交换机，该交换机收到的消息都会被传递给绑定的队列。 12345678/** exchangeName：交换机的名字* typeName：交换机类型，fanout等* public enum BuiltinExchangeType &#123;* DIRECT(&quot;direct&quot;),FANOUT(&quot;fanout&quot;),TOPIC(&quot;topic&quot;), * HEADERS(&quot;headers&quot;);* &#125;*/channel.exchangeDeclare(exchangeName,BuiltinExchangeType.FANOUT); Direct交换机将接收到的消息，按照RoutingKey完全匹配的队列进行消息投递。 Topic交换机支持RoutingKey模糊匹配。 Topic交换机的RoutingKey不能随意写，必须是：一个单词列表，用.分割。 如：quick.orange.rabbit 其他规则： *可以代替一个单词 #可以代替0个或多个单词 若匹配RoutingKey使用#，则匹配任意队列。 临时队列可以指定让服务器创建一个临时队列， 临时队列是一个随机名称的队列， 一旦断开了消费者的连接，队列将被自动删除。 1String queueName = channel.queueDeclare().getQueue() 这种队列有AD标志。AD，即AutoDelete。 死信队列死信，即无法被消费的信息。 当Consumer从Queue取出消息进行消费，但由于某些原因使得消费没有被消费，若没有后续的处理，这些消息就变成了死信。 使用RabbitMQ的死信队列机制，当消息发生异常，消息会进入到死信队列中。 死信的出现 消息TTL过期 队列达最大长度，多余添加到 消息被拒绝 basic.reject或basci.nack并且requeue&#x3D;false 流程 生产者生产消息 消息被拒绝&#x2F;队列达最大长度&#x2F;TTL过期 进入dead_exchange死信交换机 进入死信队列 使用 在需要进行死信处理的队列上添加死信arguments 1234channel.queueDeclare(NORMAL_QUEUE,false,false,false,new HashMap&lt;String,Object&gt;()&#123;&#123; put(&quot;x-dead-letter-exchange&quot;,DEAD_EXCHANGE); //死信提交的交换机 put(&quot;x-dead-letter-routing-key&quot;,&quot;lisi&quot;); //死信&#125;&#125;); 实战1 消息TTL过期 消费者 123456789101112131415161718192021222324252627282930313233343536373839public class Consumer &#123; //普通交换机 public static final String NORMAL_EXCHANGE = &quot;normal_exchange&quot;; //死信交换机 public static final String DEAD_EXCHANGE = &quot;dead_exchange&quot;; //普通队列名称 public static final String NORMAL_QUEUE = &quot;normal_queue&quot;; //死信队列 public static final String DEAD_QUEUE = &quot;dead_queue&quot;; public static void main(String[] args) throws Exception&#123; Channel channel = MQUtils.getChannel(); //声明交换机 channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);//普通交换机 channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);//死信交换机 //声明队列 channel.queueDeclare(NORMAL_QUEUE,false,false,false,new HashMap&lt;String,Object&gt;()&#123;&#123; put(&quot;x-dead-letter-exchange&quot;,DEAD_EXCHANGE);//为普通队列添加死信队列 put(&quot;x-dead-letter-routing-key&quot;,&quot;lisi&quot;);//添加死信使用的key &#125;&#125;); channel.queueDeclare(DEAD_QUEUE,false,false,false,null);//声明死信队列 channel.queueBind(NORMAL_QUEUE,NORMAL_EXCHANGE,&quot;zhangsan&quot;);//绑定队列 channel.queueBind(DEAD_QUEUE,DEAD_EXCHANGE,&quot;lisi&quot;); System.out.println(); channel.basicConsume(NORMAL_QUEUE,true,(String consumerTag, Delivery message)-&gt;&#123; System.out.println(&quot;Consumer1接收到消息：&quot;+new String(message.getBody(), StandardCharsets.UTF_8)); &#125;,(String consumerTag)-&gt;&#123; &#125;); &#125;&#125; 生产者 123456789101112131415public class Producer &#123; public static void main(String[] args) throws IOException, TimeoutException &#123; Channel channel = MQUtils.getChannel(); for (int i = 1; i &lt; 11; i++) &#123; String message = &quot;info&quot;+i; channel.basicPublish( Consumer.NORMAL_EXCHANGE, &quot;zhangsan&quot;, new AMQP.BasicProperties().builder().expiration(&quot;10000&quot;).build(), message.getBytes());//生产信息，配置信息的过期时间为10000毫秒 &#125; &#125;&#125; 实战2 消息队列溢出在声明队列的时候，设置队列最大长度，就可实现消息队列消息溢出，消息溢出后即为死信； 若配置了死信队列，消息会被转移到死信队列中。 12345channel.queueDeclare(NORMAL_QUEUE,false,false,false,new HashMap&lt;String,Object&gt;()&#123;&#123; put(&quot;x-dead-letter-exchange&quot;,DEAD_EXCHANGE); put(&quot;x-dead-letter-routing-key&quot;,&quot;lisi&quot;); put(&quot;x-max-length&quot;,6);//设置队列最大长度&#125;&#125;); 实战3 消息拒绝对消息进行nack，即拒绝消息，并设置不自动回到队列，即可实现消息拒绝，消息会被定为死信。 1234567/*p1：消息的Tagp2：是否批量p3：是否回到队列，这里为false。*/channel.basicNack(message.getEnvelope().getDeliveryTag(),false,false); 基于死信实现的延迟队列为队列设置消息的ttl过期，即延时队列。 延时队列并非RabbitMQ原生队列，而是在基础上衍生出来的一种使用方式。 在RabbitMQ中为队列设置ttl，并设置死信队列，消费者在死信队列进行消费，即延时队列。 注意：RabbitMQ只会检测第一个消息的过期时间，不会检测后面的消息是否过期。 弥补：插件解决 使用场景 订单在十分钟内未支付则自动取消 新创建的店铺，若10天内没有上传商品，则自动发送消息提醒 用户注册成功，若3天内未登录自动提醒 真正的延时队列交换机安装rabbitmq_delayed_message_exchange插件实现 安装后会增加延时交换机类型x-delayed-message。 使用该交换机的消息，可以增加x-delay属性来支持消息的延时传递，单位毫秒，若未设置x-delay属性，消息会被立即传递。 该交换机遇上带有x-delay属性的消息后，会将该消息缓存，直到指定的时间结束后，消息会进入到指定的队列中。 使用创建交换机 需要设交换机类型为x-delayed-message 添加参数x-delayed-type为交换机类型，比如direct 123public Exchange exchange()&#123; return new ExchangeBuilder(DELAY_EXCHANGE,&quot;x-delayed-message&quot;).withArgument(&quot;x-delayed-type&quot;,&quot;direct&quot;).build();&#125; 向交换机发送消息 添加参数x-delay为要进行延时的长度，单位毫秒 123456public void send3(String message,Integer delay)&#123; template.convertAndSend(&quot;delay_exchange_study&quot;,&quot;delay_message_queue_key&quot;,message,(msg)-&gt;&#123; msg.getMessageProperties().setDelay(delay); return msg; &#125;);&#125; 原理机制安装插件后会生成新的Exchange类型x-delayed-message，该类型消息支持延迟投递机制,接收到消息后并未立即将消息投递至目标队列中，而是存储在mnesia(一个分布式数据系统)表中，并且当前节点是磁盘节点，那么节点重启后，消息还能保留。检测消息延迟时间，如达到可投递时间时并将其通过x-delayed-type类型标记的交换机类型投递至目标队列。但是要注意的是，如果集群中只有一个磁盘节点，如果说磁盘节点丢失，或者节点上的插件失效。意味着消息将会丢失。 延迟队列总结其他选择 Java的DelayQueue Redis的Zset Quartz 或Kafka的时间轮。","categories":[],"tags":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"http://zswh33.github.io/tags/RabbitMQ/"}]},{"title":"RabbitMQ 3  消息模式 使用场景","slug":"RabbitMQ-3","date":"2023-02-27T13:40:30.000Z","updated":"2023-03-05T02:25:09.681Z","comments":true,"path":"2023/02/27/RabbitMQ-3/","link":"","permalink":"http://zswh33.github.io/2023/02/27/RabbitMQ-3/","excerpt":"","text":"消息模式Simple，Work Queue，Publish&#x2F;Subscribe，Routing，Topics，RPC； 投递消息过程中，若没有指定交换机，则使用默认的交换机。 Simple简单模式一个生产者，一个消费者 Work Queue工作队列一个生产者，多个消费者，一个消息只能消费一次。 Publish&#x2F;Subscribe发布订阅模式。使用fanout交换机。 生产者首先投递消息到交换机，订阅了这个交换机的所有队列就会收到生产者投递的消息。 Routing路由模式使用direct交换机 生产者生产消息投递到direct交换机中，交换机根据消息携带的RoutingKey匹配相应的队列。 比如有三个队列：Q1，Q2，Q3； 在direct交换机中，指定 Q1，mail Q2，phone Q3，Wechat Q2，Wechat 使用该交换机发送消息的时候，会向指定Key对应的队列中发布数据。 比如RoutingKey为Wechat时，发布的数据会被发送到Q3和Q2. Topics 生产者将消息投递到topic交换机，该交换机支持根据RoutingKey对队列进行模糊匹配； 发送到Topics消息的RoutingKey不能随意写，必须是一个单词列表，每个单词用.分隔开； 如： com.yn.ZhangSan asd.qwe.zxc 其中有两个替换符 #：可以替代0个或多个单词 *：可以替代一个单词 Header同时根据header和RoutingKey进行匹配； 有两种类型 all：header头必须完全匹配 any：在Queue的所有键值对在消息的Headers中都能找到，就可匹配成功。 Header为一个key-value键值对，默认情况下headers为any类型 声明Exchange和Queue，Java示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class Producer &#123; public static void main(String[] args) throws IOException, TimeoutException &#123; //1. 创建连接 ConnectionFactory connectionFactory = new ConnectionFactory()&#123;&#123; setHost(&quot;192.168.227.131&quot;); setPort(5672); setUsername(&quot;admin&quot;); setPassword(&quot;admin123&quot;); setVirtualHost(&quot;/&quot;);// &#125;&#125;; Connection connection = null; Channel channel = null; try &#123; //2. 获取连接 connection = connectionFactory.newConnection(&quot;Test生产者&quot;); //3. 通过连接获取通道Channel channel = connection.createChannel(); String queueName = &quot;Queue2&quot;; //声明队列 /** * @params1 队列名称 * @params2 是否要持久化durable * @params3 排他性，是否独占 * @params4 是否自动删除，即随着最后一个消费者消息完毕后是否把队列删除 * @params5 携带附属参数 */ channel.queueDeclare(&quot;Q1&quot;,false,false,false,null); channel.queueDeclare(&quot;Q2&quot;,false,false,false,null); channel.queueDeclare(&quot;Q3&quot;,false,false,false,null); channel.exchangeDeclare(&quot;Exchange1&quot;,&quot;direct&quot;); channel.queueBind(&quot;Q1&quot;,&quot;Exchange1&quot;,&quot;order&quot;); channel.queueBind(&quot;Q2&quot;,&quot;Exchange1&quot;,&quot;apple&quot;); channel.queueBind(&quot;Q3&quot;,&quot;Exchange1&quot;,&quot;pear&quot;); //准备消息内容 String exchange = &quot;Exchange1&quot;; String routeKey = &quot;apple&quot;; String message = &quot;Hello declare&quot;; /** * @params1 交换机，消息订阅类型 * @params2 RoutingKey * @params3 是否持久化，后续详讲 * @params4 信息的二进制数据 */ channel.basicPublish(exchange,routeKey,null,message.getBytes()); System.out.println(&quot;消息发送成功&quot;); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125;finally &#123; //关闭通道 if (channel!=null &amp;&amp; channel.isOpen())&#123; channel.close(); &#125; //关闭连接 if (connection!=null &amp;&amp; connection.isOpen())&#123; connection.close(); &#125; &#125; &#125;&#125; RabbitMQ消息应答类型自动应答只要消费者从队列中获取了消息，无论是否消费成功，都认为消息已被消费，队列会把该消息数据删除。 手动应答正常应答 Channel.basicAck 肯定确认 RabbitMQ了解到消息成功处理，将消息丢弃 Channel.basicNack 否定确认 Channel.basicReject 否定确认，相对于Nack少一个参数； 不处理该消息了直接拒绝，可以将其丢弃。 Multiple 批量应答可以减少网络拥堵。 12channel.basicAck(deliveryTag,true);//参数2，true表示批量应答 Multiple： true代表批量应答Channel上未应答的消息 如Channel上有消息5,6,7,8，当前tag是8，那么此时5-8这些未应答的消息都会被确认应答。 false 同上面相比，不会确认5-7的数据。 一般建议，不要批量应答 1234567channel.basicConsume(&quot;q1&quot;,false,new DefaultConsumer(channel)&#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; System.out.println(&quot;消费成功：&quot;+new String(body)); this.getChannel().basicAck(envelope.getDeliveryTag(),false); &#125;&#125;); 重新入队 如果消费者由于某些原因失去连接（其通道已关闭，连接已关闭或TCP连接丢失），导致消息未发送Ack确认，RabbitMQ将了解消息未完全处理，并将其重新排队。 若此时其他消费者可以处理，它将很快将其重新分发给另一个消费者。 这样，即使某个消费者偶然异常，也能保证不会丢失任何消息。","categories":[],"tags":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"http://zswh33.github.io/tags/RabbitMQ/"}]},{"title":"RabbitMQ 2 RabbitMQ安装，配置  Java中使用","slug":"RabbitMQ-2","date":"2023-02-27T01:38:09.000Z","updated":"2023-03-01T08:39:25.111Z","comments":true,"path":"2023/02/27/RabbitMQ-2/","link":"","permalink":"http://zswh33.github.io/2023/02/27/RabbitMQ-2/","excerpt":"","text":"使用 新增用户 &#96;&#96;&#96;bashrabbitmqctl add_user admin admin12345- 设置用户分配操作权限 - ```bash rabbitmqctl set_user_tags admin administrator 为用户添加资源权限 &#96;&#96;&#96;bashrabbitmqctl set_permissions -p &#x2F; admin “.“ “.“ “.*”1234567891011# 命令```bashrabbitmqctl add_user USERNAME PASSWORD #账号密码rabbitmqctl set_user_tags USERNAME administrator #赋予角色rabbitmqctl change_password USERNAME NEWPASSWORD # 修改密码rabbitmqctl list_users # 查看用户清单rabbitmqctl [-p &lt;vhostpath&gt;] &lt;user&gt; &lt;conf&gt; &lt;write&gt; &lt;read&gt;rabbitmqctl set_permissions -p / USERNAME &quot;.*&quot; &quot;.*&quot; &quot;.*&quot; #设置所有权限 其他12rabbitmq-plugins enable rabbitmq_management # 添加管理插件# Web管理插件，默认端口15672. RabbitMQ默认用户名和密码：guest 用户级别 administrator，可以登录控制台，查看所有信息，可以对rabbitmq进行管理； 最高权限 可以创建和删除virtual hosts 可以查看，创建和删除users 查看创建permissions 关闭所有用户的connections monitoring监控者，登录控制台，查看所有信息 包含management所有权限 罗列出所有的virtual hosts，包括不能登录的virtual ohsts 查看其他用户的connections和channels信息 查看节点级别的数据如clustering和memory使用情况 查看所有的virtual hosts的全局统计信息。 policymaker策略制定者，登录控制台，制定策略 包含management所有权限 查看、创建额删除自己的virtual hosts所属的policies和parameters信息。 managment普通管理员，登录控制台 列出自己可以通过AMQP登入的虚拟机 查看自己的虚拟机节点virtual hosts的queues，exchanges和bindings信息 查看和关闭自己的channels和connections 查看有关自己的虚拟机节点virtual hosts的统计信息，包括其他用户在这个节点的virtual hosts的活动信息。 none，不能访问management plugin。 在Java中使用&#x2F;RabbitMQ简单模式实现依赖12345&lt;dependency&gt; &lt;groupId&gt;com.rabbitmq&lt;/groupId&gt; &lt;artifactId&gt;amqp-client&lt;/artifactId&gt; &lt;version&gt;5.14.2&lt;/version&gt;&lt;/dependency&gt; 使用 创建连接工厂，创建连接Connection 通过连接获取通道Channel 通过通道创建交换机，声明队列，绑定关系，路由key，发送消息，接收消息 声明队列 准备消息内容 发送消息给队列 关闭连接 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class Producer &#123; public static void main(String[] args) throws IOException, TimeoutException &#123; //1. 创建连接 ConnectionFactory connectionFactory = new ConnectionFactory()&#123;&#123; setHost(&quot;192.168.227.131&quot;); setPort(5672); setUsername(&quot;admin&quot;); setPassword(&quot;admin123&quot;); setVirtualHost(&quot;/&quot;);// &#125;&#125;; Connection connection = null; Channel channel = null; try &#123; //2. 获取连接 connection = connectionFactory.newConnection(&quot;Test生产者&quot;); //3. 通过连接获取通道Channel channel = connection.createChannel(); String queueName = &quot;Queue1&quot;; //声明队列 /** * @params1 队列名称 * @params2 是否要持久化durable，是否将队列存储到磁盘 * @params3 排他性，是否只对当前Connection可见。若为true，则其他连接不可见此队列，且在连接断开时删除当前队列。 * @params4 是否自动删除，在最后一个消费者断开连接后是否自动删除。 * @params5 携带附属参数 */ channel.queueDeclare(queueName,false,false,false,null); //准备消息内容 String message = &quot;Hello World&quot;; /** * @params1 exchange，交换机 * @params2 当为默认模式，则这里为队列名。其他则为RoutingKey * @params3 后续详讲 * @params4 消息主体，信息的二进制数据 * 可以存在没有交换机的队列吗？不可以，若没有输入交换机，则会使用一个默认的交换机 */ channel.basicPublish(&quot;&quot;,queueName,null,message.getBytes()); System.out.println(&quot;消息发送成功&quot;); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125;finally &#123; //关闭通道 if (channel!=null &amp;&amp; channel.isOpen())&#123; channel.close(); &#125; //关闭连接 if (connection!=null &amp;&amp; connection.isOpen())&#123; connection.close(); &#125; &#125; &#125;&#125; AMQP流程AMQP，Advanced Message Queuing Protocol（高级消息队列协议），是应用层协议的一个开发标准，为面向消息的中间件设计。 生产者流程 建立连接 开启通道 发送消息 释放资源（关闭通道） 关闭连接 123456789Producer发送 Broker服务器回应Protocol Header Connection.StartConnection.Start-OK Connection.TuneConnection.Tune-OKConnection.Open Connection.Open-OkChannel.Open Channel.Open-OkBasic.PublishChannel.Close Channel.Close-OkConnection.Close Connection.Close-Ok 消费者流程 建立连接 开启通道 准备接收消息 Broken推送消息 推送消息 发送确认 向Broker发送确认收到消费消息 Broker收到消息后，会将消息从队列中删除； 若Broker没有收到Ack，则一直发送消息，直到收到Ack为止。 释放资源 关闭连接 1234567891011Consumer发送 Broker节点回应Protocol Header Connection.StartConnection.Start-OK Connection.TuneConnection.Tune-OKConnection.Open Connection.Open-OkChannel.Open Channel.Open-OkBasic.Consume Basic.Consume-Ok Basic.DeliverBasic.AckChannel.Close Channel.Close-OkConnection.Close Connection.Close-Ok RabbitMQ组件与架构 整体架构 运行流程","categories":[],"tags":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"http://zswh33.github.io/tags/RabbitMQ/"}]},{"title":"RabbitMQ 0 中间件 消息中间件常用协议 特点","slug":"RabbitMQ-0","date":"2023-02-23T07:08:52.000Z","updated":"2023-03-01T08:00:52.695Z","comments":true,"path":"2023/02/23/RabbitMQ-0/","link":"","permalink":"http://zswh33.github.io/2023/02/23/RabbitMQ-0/","excerpt":"","text":"中间件分布式消息中间件当前 ActiveMQ RabbitMQ 在AMQP基础上完成 优点： 基于erlang语言，高并发特性 吞吐量万级 MQ功能完善 支持多种编程语言 开源管理界面完善 社区活跃度高 缺点 商业版收费 学习成本高 Kafka 优点：性能很强，单机写入TPS约百万条&#x2F;s。 缺点： 在单机超过64队列&#x2F;分区，Load会发生明显的飙高现象。队列越多，load越高，发送响应时间变长； 一台宕机，就会产生消息乱序。 消费失败不支持重试 RocketMQ 阿里、滴滴开发的国产分布式消息中间件 优点： 单机吞吐量十万级， 消息可以做到0丢失， 支持分布式，扩展性好。 支持10亿级别消息堆积； 支持自定义 缺点： 支持的客户端不多。 场景 消息中间件监控数据 异步数据传输场景 削峰填谷场景 任务调度场景 海量数据同步场景 分布式事务场景 日记管理场景 大数据分析场景 要求 AMQP MQTT 持久化设计 Kafka协议 消息分发设计 高可用 可靠性 容错 负载均衡中间件 Nginx LVS负载均衡 对Nginx进行集群 KeepAlive 保持心跳，保持高可用 CDN 加速 缓存中间件 MemCache Redis 数据库中间件Mysql不保证高可用性 数据库中间件：实现Mysql集群，高可用性 Mycat ShardingJdbc 使用案例 异步数据保存 实现削峰 订单数据的消息分发 分布式事务 消息的容错 分布式锁 分布式会话 分库分表 消息中间件核心组成 消息的协议 消息的持久化机制 消息的分发策略 消息的高可用，高可靠 消息的容错机制 网络协议三要素 语法：语法是用户数据与控制信息的结构与格式以及数据出现的顺序 语义：语义是解释控制信息的每个部分的意义。它规定了需要发出何种控制信息，以及完成的动作与做出什么样的响应 时序：时序是对事件发生顺序的详细说明。 面试：为什么消息中间件不直接使用http协议？ 因为http请求报文头和响应报文头是比较复杂的，包含了cookie，数据的加密解密，状态码，响应码等附加功能，对于一个消息而言，不需要这些复杂的功能，，消息只需要负责数据传递，存储，分发就可以，且追求高性能，进行简洁，快速； 大部分http使用的是短连接，在实际交互过程中，一个请求到响应很有可能会中断，中断后就不会进行持久化，造成请求的丢失，这样不利于消息中间件的业务场景。消息中间件可能是一个长期获取消息的过程，出现问题和故障要对数据或消息进行持久化等，目的是为了保证消息和数据的高可靠和稳健的运行。 消息中间件常用协议 OpenWire，AMQP，MQTT，Kafka，OpenMessage协议 AMQP全称：Advanced Message Queuing Protocol 高级消息队列协议。 特性 分布式事务支持 消息持久化支持 高性能和高可靠的消息处理优势 支持者 RabbitMQ，ActiveMQ MQTTMessage Queuing Telemetry Transport 是IBM开放的一个即时通讯协议，物联网系统架构的重要组成部分 特点 轻量 结构简单 速度快，不支持事务 没有持久化设计 应用场景 计算能力有限 低带宽 网络不稳定场景 支持者 RabbitMQ，AvtiveMQ 默认关闭MQTT协议，需要手动打开 OpenMessageApache RocketMQ 由阿里、雅虎、滴滴、Stremalio等公司共同参与创立的分布式消息中间件、流处理领域的应用开发标准； 特点： 结构简单 解析速度快 支持事务和持久化设计 Kafka协议Kafka 基于TCP&#x2F;IP的二进制协议，消息内部通过长度来分割，由一些基本数据类型组成 特点 结构简单 解析速度快 无事务支持 有持久化设计 消息队列持久化将数据存入磁盘，而不是存在内存中，使数据永久保存 消息队列分发策略角色：生产者，存储消息，消费者； 执行过程 生产者生成消息 MQ进行存储 消费者通过PUSH推或PULL拉的方式获取消息 多个消息中间件消息分发策略的机制和对比 ActiveMQ RabbitMQ Kafka RocketMQ 发布订阅 支持 支持 支持 支持 轮询分发 支持 支持 支持 &#x2F; 公平分发 &#x2F; 支持 支持 &#x2F; 重发 支持 支持 &#x2F; 支持 消息拉取 &#x2F; 支持 支持 支持 轮询分发：每个服务器分配到的消息数量一致 公平分发：每个服务器分配到的消息数量不一致，能者多劳 ； 消息拉取：很少使用，RPC 消息队列高可用和高可靠高可用即：集群。 是指产品在规定的条件和规定的时刻或时间内处于可执行规定功能状态的能力； 当业务量增加时，请求也过多，一台消息中间件服务器会触及硬件（CPU，内存，磁盘）的极限，一台消息服务器已经无法满足业务的需求，所以消息中间件必须支持集群部署，来达到高可用的目的。 集群模式1，Master-Slave主从共享数据的部署方式 集群模式2，Master-Slave主从同步部署模式 集群模式3，多主集群同步部署模式 集群模式4，多主集群转发部署模式 集群模式5，Master-Slave与Breok-Cluster组合方案 总结 消息共享 消息同步 元数据共享 高可靠指系统可以无故障持续运行 比如一个系统崩溃，报错，异常等不影响线上业务的正常运行，出错率极低，就称之为：高可靠。 如何保证中间件消息的可靠性？ 消息的传输：通过协议来保证系统间数据解析的正确性 消息的存储可靠：通过持久化来保证消息的可靠性","categories":[],"tags":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"http://zswh33.github.io/tags/RabbitMQ/"}]},{"title":"RabbitMQ 1 分布式消息中间件 MQ选用 RabbitMQ特点，流程，名词介绍","slug":"RabbitMQ-1_v2","date":"2023-02-23T07:08:52.000Z","updated":"2023-03-01T14:31:29.443Z","comments":true,"path":"2023/02/23/RabbitMQ-1_v2/","link":"","permalink":"http://zswh33.github.io/2023/02/23/RabbitMQ-1_v2/","excerpt":"","text":"分布式消息中间件 ActiveMQ RabbitMQ 在AMQP基础上完成 优点： 基于erlang语言，高并发特性 吞吐量万级 MQ功能完善 支持多种编程语言 开源管理界面完善 社区活跃度高 缺点 商业版收费 学习成本高 Kafka 优点：性能很强，单机写入TPS约百万条&#x2F;s。 缺点： 在单机超过64队列&#x2F;分区，Load会发生明显的飙高现象。队列越多，load越高，发送响应时间变长； 一台宕机，就会产生消息乱序。 消费失败不支持重试 RocketMQ 阿里、滴滴开发的国产分布式消息中间件 优点： 单机吞吐量十万级， 消息可以做到0丢失， 支持分布式，扩展性好。 支持10亿级别消息堆积； 支持自定义 缺点： 支持的客户端不多。 MQ区别&#x2F;MQ选用 ActiveMQ RabbitMQ Kafka RocketMQ 发布订阅 支持 支持 支持 支持 轮询分发 支持 支持 支持 &#x2F; 公平分发 &#x2F; 支持 支持 &#x2F; 重发 支持 支持 &#x2F; 支持 消息拉取 &#x2F; 支持 支持 支持 Kafuka 基于Pull模式处理消息消费，追求高吞吐量 适用于大量数据的互联网服务的数据收集业务 场景：日志采集 适合大型公司 RocketMQ 适用于可靠性要求较高的场景。 场景：金融互联网。 在阿里双11经历多次考验。 RabbitMQ 结合erlang语言并发优势，时效性微秒级，社区活跃度高； 使用方便 场景：消息量不是那么大的场景 适合中小型公司。 RabbitMQ负责数据存储与转发。 特点 削峰：将访问的人员进行排队， 若一个时间段有20000个请求，而服务器同时只能接收100个请求，RabbitMQ负责将大请求进行排队，依次进入服务器进行处理。 应用解耦 在一次订单过程中，订单需要经过：订单系统，库存系统，物流系统，支付系统等几个过程。若其中有任意一个出现问题，订单会执行失败。 为解决问题，RabbitMQ可以进行解耦。解耦后，任意一个系统出现问题，消息会被缓存到消息队列中，直到系统被修复，这样可以避免整个过程重新执行。 提升可用性 异步处理 若A要调用B且需要B的返回结果，若B需要很长时间，A需要等待B，这个效率很低； 若MQ出现后，A只需要将消息交给MQ即可，当B完成后，将结果交给MQ，MQ将消息通知给A即可。 原理RabbitMQ使用的是基于tcp&#x2F;ip的amqp协议 amqp，即Advanced Message Queuing Protocol，一个提供统一消息服务的应用层标准高级消息队列协议。 流程 生产者 MQ 交换机 交换机绑定队列 队列 队列绑定消费者 消费者 名词介绍 Broker：接收和分发消息的应用。RabbitMQ Server就是一个Broker Server：又称Broker，接收客户端的连接，实现AMQP的实体服务； Connection：连接，应用程序与Broker的TCP&#x2F;IP连接。 Channel：网络信道，几乎所有的操作都在Channel中进行，Channel进行消息读写的通道，客户端可以建立多个Channel，每个Channel代表一个会话任务； 如果每一次访问创建一个Connection，会建立大量的TCP连接，Connection的开销是巨大的，效率也低。Channel是在Connection内部建立的逻辑连接，若应用程序支持多线程，通常每个thread创建单独的channel进行通讯。 AMQP报文包含了Channel Id帮助客户端和message broker识别channel，所以channel之间是完全隔离的。 Message：消息，服务器与应用程序之间传送的数据，由Properties和Body组成， Properties对消息进行修饰，比如消息的优先级，延迟等高级特性， Body是消息体的内容； Virtual Host：虚拟地址，用于进行逻辑隔离，最上层的消息路由，一个虚拟主机里可以有若干个Exchange和Queue，同一个虚拟主机里面不能有相同名字的Exchange； Exchange：交换机，接收消息，根据分发规则，匹配Routing Key发送消息到绑定的队列（不具备消息存储能力）。 常用类型：direct（point-to-point），topic（publish-subscribe）和fanout（multicast） direct：匹配路由键，只有完全匹配，消息才会被转发 fanout：将消息发送至所有的队列 topic：将路由进行模式匹配 #匹配一个或多个词 &quot;匹配不多不少一个词 Bindings：Exchange与Queue之间的虚拟连接，Binding中可以保护多个routing key。 Routing key：生产者将消息发送到交换机时会携带一个key，来制定路由规则； Queue：队列，也称为Message Queue消息队列，保存消息并将它们转发给消费者。 使用场景 分布式事务可靠消息的可靠生产 索引、缓存、静态化处理的数据同步 流量监控 日志监控（ELK） 下单，订单分发，抢票。","categories":[],"tags":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"http://zswh33.github.io/tags/RabbitMQ/"}]},{"title":"Redis restudy 8 缓存穿透，击穿，雪崩","slug":"Redis-restudy-8","date":"2023-02-13T15:23:29.000Z","updated":"2023-03-20T14:44:53.823Z","comments":true,"path":"2023/02/13/Redis-restudy-8/","link":"","permalink":"http://zswh33.github.io/2023/02/13/Redis-restudy-8/","excerpt":"","text":"参考文献：https://www.bilibili.com/video/BV1S54y1R7SB Redis缓存穿透和雪崩 缓存穿透数据查不到 概念 用户想要查询一个数据，发现Redis内存数据没有，也就是缓存没有命中，于是向持久层数据库查询，发现也没有，于是本次查询失败。 有时候，查询失败时，用户会多次发送请求。 当用户很多的时候，缓存都没有命中，于是都去请求了持久层数据库，这会给持久层数据库造成很大的压力，这时候就相当于出现了缓存穿透。 解决布隆过滤器 布隆过滤器是一种数据结构，对所有可能查询的参数以Hash形式存储，在控制层先校验，不符合则丢弃，从而避免了对底层存储系统的查询压力。 缓存空对象 当存储层不命中后，即使返回的空对象也将其缓存起来，同时会设置一个过期时间，之后再访问这个数据将会从缓存中获取，保护了后端数据源。 问题： 若控制能够被缓存起来，就意味着缓存需要更多的空间鵆更多的键，因为这当中可能会有很多的空值的键 即使对空值设置了过期时间，还是会存在缓存层和存储层的护具会有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响。 缓存击穿请求量太大，缓存过期 概念有一个key非常热点，收到大并发的数据访问； 当这个key失效的瞬间，持续的大并发就会穿破缓存，直接请求数据库，就像是在一个屏障上凿开了一个洞。 当某个key在过期的瞬间，有大量请求并发访问，这类数据一般是热点数据，由于缓存过期，会同时访问数据库来查询最新数据，并且回写缓存，会导致数据库瞬间压力过大。 解决方案 设置热点数据永不过期 加互斥锁 分布式锁：使用分布式锁，保证对于每个key同时只有一个线程去查询后端服务，其他线程没有获得分布式锁的权限，因此只需要等待即可。 这种方式将高并发的压力转移到了分布式锁，因此对分布式锁的考验很大。 缓存雪崩缓存大面积失效或Redis宕机； 解决方案 Redis高可用 多增设几台Redis，即搭建集群 限流 缓存失效后，通过加锁或队列来控制读数据库和写缓存的线程数量；比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。 服务降级&#x2F;服务熔断 发生缓存雪崩时，为防止发生连锁的数据库雪崩，甚至整个系统崩溃 服务熔断 客户端不再请求Redis，直接返回预定义数据或空数据 服务降级 当业务应用访问非核心数据时，暂时停止从缓存中查询这些数据，而是直接范围预定义信息或空数据； 访问核心数据则正常执行。 - 数据预热 在正式部署之前，先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。 在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间尽量均匀。 设置随机过期时间 尽量保证数据过期时间不同。","categories":[],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://zswh33.github.io/tags/Redis/"}]},{"title":"Redis restudy 7 发布订阅 主从复制 哨兵模式","slug":"Redis-restudy-7","date":"2023-02-13T11:29:57.000Z","updated":"2023-03-20T14:44:45.140Z","comments":true,"path":"2023/02/13/Redis-restudy-7/","link":"","permalink":"http://zswh33.github.io/2023/02/13/Redis-restudy-7/","excerpt":"","text":"Redis发布订阅 Redis可以订阅任何数量的频道。 命令psubscribe pattern [pattern ...]：订阅一个或多个符合给定模式的频道 pubsub subcommand [argument [argument ..]]：查询订阅与发布系统状态 publish channel message：将信息发送到指定的频道 punsubscribe [pattern [pattern ...]]：退订所给定模式的频道 subscribe channel [channel ...]：订阅给定的一个或多个频道的信息 unsubscribe [channel [channel ...]]：退订给定的频道 123456789101112# 订阅频道127.0.0.1:6379&gt; subscribe ynReading messages... (press Ctrl-C to quit)1) &quot;subscribe&quot;2) &quot;yn&quot;3) (integer) 11) &quot;message&quot;2) &quot;yn&quot;3) &quot;HelloWorld&quot;1) &quot;message&quot; #消息2) &quot;yn&quot; #来自哪个频道3) &quot;ZhangSan&quot; #消息内容 12345# 频道信息发布127.0.0.1:6379&gt; publish yn HelloWorld(integer) 1127.0.0.1:6379&gt; publish yn ZhangSan(integer) 1 使用场景实时消息系统，实时聊天。 应用有更专业的MQ，Redis订阅可能不需要。 Redis主从复制介绍主从复制，将一台Redis服务器的数据，复制到其他Redis服务器。 前者为主节点（Master&#x2F;leader）,后者为从节点（slave&#x2F;follower）; 数据复制是单向的，只能由主节点到从节点，Master写为主，Slave读为主。 主从复制，读写分离！80%的情况下都是在进行读操作，减缓服务器压力。 作用 数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式 故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障回复，实际上是一种服务的冗余； 负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供度服务，分担服务器负载；尤其是在写少读多的场景下，通过多个节点分担读负载，可以大大提高Redis服务器并发量。 高可用基石：主从复制为哨兵和集群提供能够实施的基础，因此主从复制是Redis高可用的基础。 （“高可用”名词一般用于集群） 一般来说，Redis在工程项目中了，只用一台Redis是万万不能的 从结构上，单个Redis服务器会发生单点故障，并且一台服务器需要处理所有的请求负载，压力较大； 从容量上，单个Redis服务器内存容量有限；一般来说，单台Redis最大使用内存不应该超过20G。 只要在公司中，主从复制就是要必须使用的，在真实的项目中不可能单机使用Redis。 性质 默认情况下，每台Redis服务器都是主节点 一个主节点可以有多个从节点，一个从节点只能有一个主节点。 环境配置只配置从库，不用配置主库。 命令info replication：查看当前库的信息 123456789101112127.0.0.1:6379&gt; info replication# Replicationrole:master connected_slaves:0master_replid:cf3c24d5b4964e0604f7cbc984152291c0175d35master_replid2:0000000000000000000000000000000000000000master_repl_offset:0second_repl_offset:-1repl_backlog_active:0repl_backlog_size:1048576repl_backlog_first_byte_offset:0repl_backlog_histlen:0 配置单机测试学习 准备3-4个配置文件 要进行单机测试的话，要修改的配置 端口，pid，log文件，备份文件名 只需配置从机，不配置主机 1234567891011121314151617181920212223#其中一个从机的信息127.0.0.1:6380&gt; slaveof 127.0.0.1 6379 #认定指定服务器为主机OK127.0.0.1:6380&gt; info replication# Replicationrole:slave # 当前角色：从机master_host:127.0.0.1master_port:6379master_link_status:upmaster_last_io_seconds_ago:5master_sync_in_progress:0slave_repl_offset:0slave_priority:100slave_read_only:1connected_slaves:0master_replid:36c79b03b82a86ae900da1f1a4c8b98ad063dbddmaster_replid2:0000000000000000000000000000000000000000master_repl_offset:0second_repl_offset:-1repl_backlog_active:1repl_backlog_size:1048576repl_backlog_first_byte_offset:1repl_backlog_histlen:0 查看结论 123456789101112131415# 主机的信息root@yynlinux:~/yn# redis-cli -p 6379127.0.0.1:6379&gt; info replication# Replicationrole:masterconnected_slaves:1 #连接的从机slave0:ip=127.0.0.1,port=6380,state=online,offset=140,lag=0 #从机的信息master_replid:36c79b03b82a86ae900da1f1a4c8b98ad063dbddmaster_replid2:0000000000000000000000000000000000000000master_repl_offset:140second_repl_offset:-1repl_backlog_active:1repl_backlog_size:1048576repl_backlog_first_byte_offset:1repl_backlog_histlen:14 正式配置命令配置在从机上 12127.0.0.1:6380&gt; slaveof 127.0.0.1 6379 #认定指定服务器为主机OK 即可实现主从复制。 配置文件配置123replicaof &lt;masterip&gt; &lt;masterport&gt; # 主机ip和端口masterauth &lt;master-password&gt; #主机密码，密码和用户可以不存在masteruser &lt;username&gt; #主机用户 其他 主机可以写，从机只能读。 主机的数据会被从机自动保存 123#在从机写会发生的事情127.0.0.1:6380&gt; set k2 v2(error) READONLY You can&#x27;t write against a read only replica. 主机宕机后，从机依旧连接主机；主机如果恢复了，从机依旧能够获取主机的信息。 命令行配置的主从关系在从机重启后会消失，只有配置文件配置的主从能够保持。 原理Slave启动连接后会向master发送一个sync命令， master接到命令，启动后台的存盘进程，同时收集所有接受到的用于修改数据集的命令，在后台进程执行结束后，master将整个数据文件发送到slave，并完成一次完全同步； 全量复制：slave将收到的数据文件，将其存盘并加载到内存中； 增量复制：Master继续将新的所有收集到的修改命令依次传给slave，完成同步。 主从复制形式 一个主机带多个从机 一个主机带多个从机，从机再带从机 （中间的节点仍是从节点，不能写入。） 取消从机模式两种方式： 改配置文件，重启 命令：slaveof no one 1234567891011121314127.0.0.1:6380&gt; slaveof no oneOK127.0.0.1:6380&gt; info replication# Replicationrole:masterconnected_slaves:0master_replid:31c0ab1d95cc58365a1c357e721646ace499ad92master_replid2:f7d2c0c54849a249b28c1aaaa3c19595b0b732f9master_repl_offset:1666second_repl_offset:1667repl_backlog_active:1repl_backlog_size:1048576repl_backlog_first_byte_offset:1repl_backlog_histlen:1666 Redis哨兵模式自动选举Master~❤ 传统的主从切换当主服务器宕机，需要手动把一台服务器切换为主服务器，这需要人工干预，费时费力，且造成短时间服务不可用。 Redis2.8正式提供了Sentinel哨兵架构来解决这个问题。 介绍 哨兵模式能够监控主机是否故障，若故障则根据投票数自动将从库转换为主库。 哨兵是一种特殊的模式，哨兵是一个独立的进程，他会独立运行。 哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis示例。 原理假设主服务器宕机， 哨兵1会检测到这个结果，系统不会马上进行failover过程，仅仅是哨兵1认为主服务器不可用，这个现象称为主观下线； 当后面的哨兵也检测到主服务器不可用，并达到一定数量时，那么哨兵之间会进行一次投票，投票的结果由一个哨兵发起（这个哨兵是随机的），进行failover[故障转移]操作，切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为客观下线。 示例 配置哨兵配置文件 12sentinel monitor 被监控的名称 地址 端口 最低投票数sentinel monitor r1 127.0.0.1 6379 1 被监控的名称自定义，不影响结果 启动哨兵 1234567891011121314151617181920212223242526272829303132333435363738394041424344root@yynlinux:~/yn# redis-sentinel sentinel.conf63284:X 13 Feb 2023 13:34:16.343 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo63284:X 13 Feb 2023 13:34:16.345 # Redis version=6.0.16, bits=64, commit=00000000, modified=0, pid=63284, just started63284:X 13 Feb 2023 13:34:16.346 # Configuration loaded63284:X 13 Feb 2023 13:34:16.349 * Increased maximum number of open files to 10032 (it was originally set to 1024). _._ _.-``__ &#x27;&#x27;-._ _.-`` `. `_. &#x27;&#x27;-._ Redis 6.0.16 (00000000/0) 64 bit .-`` .-```. ```\\/ _.,_ &#x27;&#x27;-._ ( &#x27; , .-` | `, ) Running in sentinel mode |`-._`-...-` __...-.``-._|&#x27;` _.-&#x27;| Port: 26379 | `-._ `._ / _.-&#x27; | PID: 63284 `-._ `-._ `-./ _.-&#x27; _.-&#x27; |`-._`-._ `-.__.-&#x27; _.-&#x27;_.-&#x27;| | `-._`-._ _.-&#x27;_.-&#x27; | http://redis.io `-._ `-._`-.__.-&#x27;_.-&#x27; _.-&#x27; |`-._`-._ `-.__.-&#x27; _.-&#x27;_.-&#x27;| | `-._`-._ _.-&#x27;_.-&#x27; | `-._ `-._`-.__.-&#x27;_.-&#x27; _.-&#x27; `-._ `-.__.-&#x27; _.-&#x27; `-._ _.-&#x27; `-.__.-&#x27;63284:X 13 Feb 2023 13:34:16.371 # Sentinel ID is aab9a70d6160f5ffdcbc57130a26295510730b1063284:X 13 Feb 2023 13:34:16.372 # +monitor master r1 127.0.0.1 6379 quorum 163284:X 13 Feb 2023 13:34:16.377 * +slave slave 127.0.0.1:6380 127.0.0.1 6380 @ r1 127.0.0.1 637963284:X 13 Feb 2023 13:36:14.070 # +sdown master r1 127.0.0.1 637963284:X 13 Feb 2023 13:36:14.072 # +odown master r1 127.0.0.1 6379 #quorum 1/163284:X 13 Feb 2023 13:36:14.073 # +new-epoch 163284:X 13 Feb 2023 13:36:14.075 # +try-failover master r1 127.0.0.1 637963284:X 13 Feb 2023 13:36:14.084 # +vote-for-leader aab9a70d6160f5ffdcbc57130a26295510730b10 163284:X 13 Feb 2023 13:36:14.086 # +elected-leader master r1 127.0.0.1 637963284:X 13 Feb 2023 13:36:14.088 # +failover-state-select-slave master r1 127.0.0.1 637963284:X 13 Feb 2023 13:36:14.182 # +selected-slave slave 127.0.0.1:6380 127.0.0.1 6380 @ r1 127.0.0.1 637963284:X 13 Feb 2023 13:36:14.184 * +failover-state-send-slaveof-noone slave 127.0.0.1:6380 127.0.0.1 6380 @ r1 127.0.0.1 637963284:X 13 Feb 2023 13:36:14.243 * +failover-state-wait-promotion slave 127.0.0.1:6380 127.0.0.1 6380 @ r1 127.0.0.1 637963284:X 13 Feb 2023 13:36:14.860 # +promoted-slave slave 127.0.0.1:6380 127.0.0.1 6380 @ r1 127.0.0.1 637963284:X 13 Feb 2023 13:36:14.862 # +failover-state-reconf-slaves master r1 127.0.0.1 637963284:X 13 Feb 2023 13:36:14.938 # +failover-end master r1 127.0.0.1 637963284:X 13 Feb 2023 13:36:14.939 # +switch-master r1 127.0.0.1 6379 127.0.0.1 638063284:X 13 Feb 2023 13:36:14.942 * +slave slave 127.0.0.1:6379 127.0.0.1 6379 @ r1 127.0.0.1 638063284:X 13 Feb 2023 13:36:15.208 * +slave slave 127.0.0.1:6381 127.0.0.1 6381 @ r1 127.0.0.1 638063284:X 13 Feb 2023 13:36:44.969 # +sdown slave 127.0.0.1:6379 127.0.0.1 6379 @ r1 127.0.0.1 6380 其他 若主机宕机后，哨兵会自动投票选举从机作为主机。 主机宕机恢复后，哨兵会向该主机发送命令，将该主机变为新主机的从机。 优点 主从可以切换，故障可以转移，系统的可用性会更好； 哨兵模式就是主从模式的升级，手动到自动； 缺点 Redis不易扩容，集群容量一旦达到上限，在线扩容十分麻烦； 实现哨兵模式的配置麻烦。 配置文件12345678910111213141516171819202122232425262728293031323334bind 127.0.0.1 ::1port 26379 #如果有哨兵集群，则需要配置端口daemonize nopidfile &quot;/var/run/sentinel/redis-sentinel.pid&quot;logfile &quot;/var/log/redis/redis-sentinel.log&quot;# 指定监听的master# quorum 有多少个哨兵认为失联了，就认定主机down了#sentinel monitor 主机名 地址 端口 quorumsentinel monitor mymaster 127.0.0.1 6379 2#配置主机密码sentinel auto-pass &lt;master-name&gt; &lt;password&gt;# 指定多长时间，哨兵主观认为master不可用了，单位是毫秒，默认为30秒# 默认延时操作 主机名 延时sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;# 故障转移时，最多允许多少个从机同时从master进行数据同步。 因此，1则表示串行。设为1保证每次只有一个slave处于不能处理请求的状态sentinel parallel syncs &lt;master-name&gt; &lt;numslaves&gt;# 故障转移 超时时间 若超过180000ms没有转移成功，则视为故障转移失败sentinel failover-timeout mymaster 180000# 配置某一事件发生时要执行的脚本# 通知型脚本：当sentinel有任何警告级别的事件发生时（比如Redis实例主管失效、客观失效等），将会去调用这个脚本，这时脚本应该通过邮件，SMS等方式通知系统管理员关于系统不正常运行的而信息；调用该脚本时，将会给脚本传递两个参数，一个是事件的类型，一个是事件的描述。若配置了这个脚本，则必须保证脚本可执行，否则sentinel无法正常启动# 规则：# 1. 若脚本执行后返回1，则该脚本会被再次执行，重复次数默认为10# 2. 若脚本返回2或一个比2更高的值，脚本不会被重复执行# 3. 若脚本执行过程中收到中断信号终止了，则同返回值为1的行为相同# 4. 脚本最大执行时间为60s，超过这个时间会被一个SIGKILL信号终止，之后重新执行。sentinel notification-script mymaster /var/redis/notfiy.sh# 当一个master由于failover而发生改变时，这个脚本将被调用，通知相关的客户端关于master地址已经发生改变的信息，以下参数将会在调用脚本时传给脚本。# &lt;master-name&gt; &lt;role&gt; &lt;state&gt; &lt;from-ip&gt; &lt;from-port&gt; &lt;to-ip&gt; &lt;to-port&gt;sentinel client-reconfig-script mymaster /var/redis/reconfig.sh...","categories":[],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://zswh33.github.io/tags/Redis/"}]},{"title":"Redis restudy 6 conf 持久化","slug":"Redis-restudy-6","date":"2023-02-13T07:54:23.000Z","updated":"2023-03-20T14:45:25.573Z","comments":true,"path":"2023/02/13/Redis-restudy-6/","link":"","permalink":"http://zswh33.github.io/2023/02/13/Redis-restudy-6/","excerpt":"","text":"Redis.conf单位12345678# 1k =&gt; 1000 bytes# 1kb =&gt; 1024 bytes# 1m =&gt; 1000000 bytes# 1mb =&gt; 1024*1024 bytes# 1g =&gt; 1000000000 bytes# 1gb =&gt; 1024*1024*1024 bytes## units are case insensitive so 1GB 1Gb 1gB are all the same. 在单位上，大小写不敏感。 include12# include /path/to/local.conf# include /path/to/other.conf 可以包含别的配置文件。 网络123bind 127.0.0.1 ::1 #绑定的IP地址protected-mode yes # 保护模式开关port 6379 # 端口 General12345678910111213daemonize yes #以守护进程方式运行pidfile /var/run/redis/redis-server.pid #若以后台方式运行，就需要指定一个pid文件# debug (a lot of information, useful for development/testing)# verbose (many rarely useful info, but not a mess like the debug level)# notice (moderately verbose, what you want in production probably) 生产环境适用# warning (only very important / critical messages are logged)loglevel notice #日志级别logfile /var/log/redis/redis-server.log #日志的文件位置databases 16 # 默认数据库数量always-show-logo yes #是否总是展示logo SNAPSHOTTING 快照持久化，在规定的时间内，执行了多少次操作，则会进行一次持久化。 Redis是内存数据库，没有持久化，数据断电即失。 123save 900 1 #每隔900秒尝试进行保存，若修改次数&gt;=1则进行一次快照保存save 300 10 #每隔300秒尝试进行保存，若修改次数&gt;=10则进行一次快照保存save 60 10000 #每隔60秒尝试进行保存，若修改次数&gt;=10000则进行一次快照保存 1234stop-writes-on-bgsave-error yes #持久化出错，是否继续工作rdbcompression yes # 是否开启rdb文件压缩，需要消耗CPU资源rdbchecksum yes #保存rdb文件时，进行rdb文件校验dbfilename dump.rdb #rdb文件保存目录 REPLICATION复制… SECURITY安全1requirepass 123456 # 设置密码，默认没有密码 CLIENTS客户端123456789maxclients 1000 #设置redis最大客户端数量maxmemory &lt;bytes&gt; #设置最大内存容量maxmemory-policy noeviction #内存满了，处理策略 #noeviction: 不删除策略, 达到最大内存限制时, 如果需要更多内存, 直接返回错误信息。（默认值） #allkeys-lru: 所有key通用; 优先删除最近最少使用(less recently used ,LRU) 的 key。 #volatile-lru: 只限于设置了 expire 的部分; 优先删除最近最少使用(less recently used ,LRU) 的 key。 #allkeys-random: 所有key通用; 随机删除一部分 key。 #volatile-random: 只限于设置了 expire 的部分; 随机删除一部分 key。 #volatile-ttl: 只限于设置了 expire 的部分; 优先删除剩余时间(time to live,TTL) 短的key。 APPEND ONLY MODE 模式 aof123456appendonly no #默认不开启aof模式， #默认使用的是rdb方式持久化，大部分情况下rdb够用。appendfilename &quot;appendonly.aof&quot; #持久化文件名appendfsync everysec # 每秒执行一次同步，可能会丢失这一秒的数据 #always #每次修改值都会写入 #no #不执行，这个时候操作系统自己同步数据，速度最快。 Redis持久化参考文献：https://www.cnblogs.com/xing1/p/16380120.html Redis是内存数据库，若不将内存中数据库状态保存到磁盘，一旦服务器进程退出，服务器中数据库状态就会消失，所以Redis提供了持久化功能。 RDB（Redis Database）指定时间间隔内将内存中数据快照写入磁盘。 Redis单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程结束了，再用这个临时文件替换上次持久化好的文件。 主进程不进行任何IO操作，确保了极高的性能。 如果要大规模进行数据恢复，且对于数据恢复的完整性不是非常敏感，那RDB的方式要比AOF方式更加高效。RDB缺点是最后一次持久化后数据可能丢失。 默认情况下使用RDB。 默认保存文件为：dump.rdb 1dbfilename: dump.rdb 触发条件 save规则满足 执行flushall 关闭redis服务器 rdb文件恢复将rdb文件放到Redis启动目录就可，redis启动会检查rdb文件然后恢复。 &#x2F;user&#x2F;local&#x2F;bin 优点 适合大规模数据恢复 对数据完成性要求不高 缺点： 需要一定的时间间隔进程操作。若redis意外宕机了，最后一次修改数据就没有了 fork进程的时候，会占用一定的内存空间。 有时候在生产环境我们会对这个文件进行备份。 AOF（Append Only File）介绍将所有命令都记录下来，恢复的时候就把这个文件再全部执行一遍； 以日志的形式记录每个写操作，将Redis执行过的所有指令记录下来（不记录读操作），只可追加文件不可改写文件，Redis启动之初会读取该文件重新构建数据，Redis重启的话就根据日志文件的内容将所有指令执行一次以完成数据恢复操作。 AOF重写AOF追加文件会越来越大，这样不合理； 为了解决这个问题，当文件大到一定程度，会触发AOF重写； AOF重写会将内存中的数据库用命令的方式重写一个aof文件，来为AOF文件减肥。 当AOF文件体积变得过大时，会fork出一条新进程来将文件重写（先写临时文件，然后rename），遍历新进程的内存数据，每条记录有一条set语句。重写aof文件操作，没有读取旧的aof文件，而是将整个内存中的数据库内容用命令的方式重写一个新的aof文件（与快照类似）。 在子进程重写期间，服务端正常对外服务，服务端会将在重写期间收到的数据缓存到aof_rewrite_buf中，也就是单独开辟一块缓存来存储重写期间收到的命令，在子进程重写完成后，再把缓存的数据追加到新的aof文件中。 重写期间写出的aof文件是一个临时文件，不是旧文件，在重写结束后会删除旧的aof文件，然后临时文件会rename，成为当前使用的aof文件。 配置文件AOF默认文件：appendonly.aof AOF默认不开启，需要手动开启 1234567appendonly no #no表示关闭 yes表示开启appendfilename &quot;appendonly.aof&quot;no-appendfsync-on-rewrite no #在执行AOF重写期间是否进行AOF文件同步auto-aof-rewrite-percentage 100 #目前AOF文件超过上次重写文件的百分之多少时候再次重写，这里指上次重写文件的1倍auto-aof-rewrite-min-size 64mb #设置允许重写的最小文件大小，防止文件本身就小还要重写。aof-use-rdb-preamble no #Redis4.0新增的RDB-AOF混合持久化方式，其中RDB负责记录已有数据，AOF负责记录最近发生变化的数据。这样就同时兼有AOF和RDB的优点：既能够快速生成重写文件，也能在出现问题时，快速地载入数据。 AOF文件修复当aof文件有错误，Redis则无法启动，就需要修复这个aof文件； redis提供了一个工具redis-check-aof 1redis-check-aof --fix appendonly.aof redis-check-aof修复会删除错误的指令，将错误的数据删除。 优点 每次修改都同步，文件完整性更高 缺点 数据文件大， 修复速度慢 AOF运行效率比rdb低","categories":[],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://zswh33.github.io/tags/Redis/"}]},{"title":"Redis restudy 5 事务 监视Jedis SpringBootRedis","slug":"Redis-restudy-5","date":"2023-02-13T04:36:14.000Z","updated":"2023-03-20T14:45:02.522Z","comments":true,"path":"2023/02/13/Redis-restudy-5/","link":"","permalink":"http://zswh33.github.io/2023/02/13/Redis-restudy-5/","excerpt":"","text":"事务要么同时成功，要么同时失败：原子性。 Redis单条命令保证原子性，但事务不保证原子性。 Redis没有事务隔离级别的概念 Redis事务：一组命令的集合。 一个事务的所有命令都会被序列化，在事务执行过程中，会按照顺序执行 所有命令在事务中，不会被直接执行！只有发起执行命令的时候才会执行！ 先创建事务，然后发起执行命令，然后开始执行。 一次性，顺序性，排他性。 执行流程 开启事务 multi 命令入队 执行事务 exec 示例123456789101112131415161718127.0.0.1:6379&gt; multi #开启事务OK127.0.0.1:6379&gt; set k1 v1 #命令入队QUEUED127.0.0.1:6379&gt; set k2 v2QUEUED127.0.0.1:6379&gt; get k2QUEUED127.0.0.1:6379&gt; set k3 v3QUEUED127.0.0.1:6379&gt; get k1QUEUED127.0.0.1:6379&gt; exec #执行1) OK2) OK3) &quot;v2&quot;4) OK5) &quot;v1&quot; 命令multi：开启事务 exec：执行事务 discard：取消事务 12345678127.0.0.1:6379&gt; multi #开启事务OK127.0.0.1:6379&gt; set k5 qweasdQUEUED127.0.0.1:6379&gt; discard #取消事务OK127.0.0.1:6379&gt; get k5 # 事务队列命令不会被执行(nil) 特性 若事务中出现错误命令，exec后事务中所有命令都不会被执行； 若事务队列中出现“运行时异常”，在事务执行过程中，其他命令可以被正常执行。 错误命令抛出异常 编译时异常一个命令出现错误，事务中所有命令都不会被执行 123456789101112131415161718127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt;127.0.0.1:6379&gt; set k1 v1QUEUED127.0.0.1:6379&gt; set k2 v2QUEUED127.0.0.1:6379&gt; set k3 v3QUEUED127.0.0.1:6379&gt; getset k3 #错误的命令(error) ERR wrong number of arguments for &#x27;getset&#x27; command #报错后事务没有停止127.0.0.1:6379&gt; set k4 v4QUEUED127.0.0.1:6379&gt; set k5 v4QUEUED127.0.0.1:6379&gt; exec(error) EXECABORT Transaction discarded because of previous errors.#所有的命令都不会被执行 运行时异常所有的命令中，除了报错的，都正常执行。 12345678910111213141516171819127.0.0.1:6379&gt; set k1 v1OK127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; incr k1 #k1是一个字符串，不能进行incr，所以是一个会报错的命令QUEUED127.0.0.1:6379&gt; set k2 v2QUEUED127.0.0.1:6379&gt; set k3 v3QUEUED127.0.0.1:6379&gt; get k3QUEUED127.0.0.1:6379&gt; exec1) (error) ERR value is not an integer or out of range2) OK3) OK4) &quot;v3&quot;127.0.0.1:6379&gt; get k3&quot;v3&quot; Redis监视&#x2F;Redis乐观锁介绍watch key：监视某个key，在后面事务创建过程中，若另一个线程修改了key对应的值，那个这个事务执行会失败。 正常执行 123456789101112131415127.0.0.1:6379&gt; set money 100OK127.0.0.1:6379&gt; set out 0OK127.0.0.1:6379&gt; watch moneyOK127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; decrby money 20QUEUED127.0.0.1:6379&gt; incrby out 20QUEUED127.0.0.1:6379&gt; exec1) (integer) 802) (integer) 20 执行失败示例 123456789101112127.0.0.1:6379&gt; set money 10OK127.0.0.1:6379&gt; watch moneyOK127.0.0.1:6379&gt; multi OK #在这里，另一个线程执行了set money 100127.0.0.1:6379&gt; incrby money 20QUEUED127.0.0.1:6379&gt; exec(nil) #由于money值被另一个线程修改，这里执行失败127.0.0.1:6379&gt; get money&quot;100&quot; 其他解决：重新执行流程。 命令 watch key：监视某个元素 unwatch：放弃监视 exec和discard后会自动执行这个命令。 JedisRedis官方推荐的Java连接开发工具。使用Java操作Redis的一个中间件。 Jedis的API与Redis的命令完全一致。 使用 导入依赖 123456789101112&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;3.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.fastjson2&lt;/groupId&gt; &lt;artifactId&gt;fastjson2&lt;/artifactId&gt; &lt;version&gt;2.0.16&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 执行 连接数据库 操作命令 断开连接 1234567public class RedisTest &#123; public static void main(String[] args) &#123; // 1. new Jedis 对象 Jedis jedis = new Jedis(&quot;127.0.0.1&quot;, 6379); System.out.println(jedis.ping()); &#125;&#125; 1PONG 事务12345678910111213141516171819202122232425public class RedisTest_TX &#123; public static void main(String[] args) &#123; Jedis jedis = null; jedis = new Jedis(&quot;127.0.0.1&quot;, 6379); jedis.flushDB(); //开启事务 Transaction multi = jedis.multi(); try &#123; //输入事务指令 String s = &quot;qweasd&quot;; multi.set(&quot;user:1&quot;,s);// int i = 1/0;//代码抛出异常，事务执行失败 //执行事务 List&lt;Object&gt; exec = multi.exec(); System.out.println(exec); &#125; catch (Exception e) &#123; System.out.println(multi.discard()); throw new RuntimeException(e); &#125; finally &#123; System.out.println(jedis.get(&quot;user:1&quot;)); jedis.close(); &#125; &#125;&#125; SpringBoot整合RedisJedis和Lettuce历史在SpringBoot2.x之后，原来使用的Jedis被替换为lettuce。 区别 Jedis：采用直连的方式，多线程操作，是不安全的。（BIO） 使用Jedis Pool连接池解决。 lettuce：采用netty，实例可以在多个线程中共享，不存在线程不安全的情况，可以减少线程数量。（更像NIO模式） 原理通过SpringData访问数据 （在Spring访问数据库数据，都是通过SpringData执行。jdbc，redis，JPA等） SpringBoot1234567891011121314151617181920212223242526@Configuration(proxyBeanMethods = false)@ConditionalOnClass(RedisOperations.class)@EnableConfigurationProperties(RedisProperties.class)@Import(&#123; LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class &#125;)public class RedisAutoConfiguration &#123; @Bean @ConditionalOnMissingBean(name = &quot;redisTemplate&quot;) // 当不存在redisTemplate时，则使用这个配置，可以自定义一个redisTemplate来替换 @ConditionalOnSingleCandidate(RedisConnectionFactory.class) public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) &#123; //默认的RedisTemplate没有过多的设置， //两个泛型都是Object，后面使用需要强制转换 RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate&lt;&gt;(); template.setConnectionFactory(redisConnectionFactory); return template; &#125; @Bean @ConditionalOnMissingBean // 由于String是redis中最常使用的类型，所以有单独一个Bean @ConditionalOnSingleCandidate(RedisConnectionFactory.class) public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory redisConnectionFactory) &#123; return new StringRedisTemplate(redisConnectionFactory); &#125;&#125; 使用示例 导入依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 配置连接 12spring.redis.url=127.0.0.1spring.redis.port=6379 测试 12345678@AutowiredRedisTemplate&lt;Object,Object&gt; redisTemplate;@Testvoid contextLoads() &#123; redisTemplate.opsForValue().set(&quot;name&quot;,&quot;yn&quot;); System.out.println(redisTemplate.opsForValue().get(&quot;name&quot;));&#125; 基本使用 1.先注入一个RedisTemplate 12@AutowiredRedisTemplate&lt;Object,Object&gt; redisTemplate; 然后选择操作方式 Value：字符串 Cluster：集群 Geo：地理位置信息 Hash：哈希 List：列表 HyperLogLog：基数统计 Set：集合 Stream：流 … 对于结果 与Redis基本一致，直接使用就可。 其他API redisTemplate ops**** set get … multi 事务 discard delete watch redisTemplate.getConnectionFactory().getConnection() 获取连接对象 flushAll 清除所有 flushDb 清除数据库 关于中文乱码解决原理在RedisTemplate.class下，默认使用的是Jdk序列化方式，Jdk序列化方式会对中文进行编码。 123if (this.defaultSerializer == null) &#123; this.defaultSerializer = new JdkSerializationRedisSerializer(this.classLoader != null ? this.classLoader : this.getClass().getClassLoader()); &#125; 解决自己定义一个redisTemplate。 自定义RedisTemplate一般情况下关于对象的保存JSON 12345678@Testpublic void test() throws JsonProcessingException &#123; //真实开发一般使用Json传递对象 User user = new User(&quot;yn&quot;, 22); String s = new ObjectMapper().writeValueAsString(user);//将对象转换为Json redisTemplate.opsForValue().set(&quot;user&quot;,s); System.out.println(redisTemplate.opsForValue().get(&quot;user&quot;));&#125; 自定义RedisTemplate123456789101112131415161718192021222324252627282930313233@Configurationpublic class RedisConfig &#123; //编写自己的redisTemplate @Bean// @ConditionalOnMissingBean(name = &quot;redisTemplate&quot;)// @ConditionalOnSingleCandidate(RedisConnectionFactory.class) public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) &#123; //为了开发方便，一般直接使用StringObject类型 RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;(); //序列化配置 Jackson2JsonRedisSerializer&lt;Object&gt; objectJackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer&lt;Object&gt;(Object.class); ObjectMapper om = new ObjectMapper(); om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); objectJackson2JsonRedisSerializer.setObjectMapper(om); StringRedisSerializer stringRedisSerializer = new StringRedisSerializer(); //key使用String序列化方式 template.setKeySerializer(stringRedisSerializer); //hashKey也使用String序列化方式 template.setHashKeySerializer(stringRedisSerializer); //value使用jackson template.setValueSerializer(objectJackson2JsonRedisSerializer); //hashValue使用Jackson template.setHashValueSerializer(objectJackson2JsonRedisSerializer); template.setConnectionFactory(redisConnectionFactory); template.afterPropertiesSet(); return template; &#125;&#125;","categories":[],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://zswh33.github.io/tags/Redis/"}]},{"title":"Redis restudy 4 Zset Geospatial Hyperloglog Bitmaps","slug":"Redis-restudy-4","date":"2023-02-13T02:00:28.000Z","updated":"2023-03-06T05:11:39.555Z","comments":true,"path":"2023/02/13/Redis-restudy-4/","link":"","permalink":"http://zswh33.github.io/2023/02/13/Redis-restudy-4/","excerpt":"","text":"Zset（有序集合）与set基本一致，在zset里，元素是有序的； 对于每一个元素，都有一个score，来表现其排序先后。 zadd, zrangezadd key score member [score member ...]：score为优先级，会影响排序顺序。 zrange key start stop：查询索引为start-stop的所有值 12345678127.0.0.1:6379&gt; zadd z1 1 one # 添加值(integer) 1127.0.0.1:6379&gt; zadd z1 3 three 2 two #添加多个值(integer) 2127.0.0.1:6379&gt; zrange z1 0 -1 #查询范围1) &quot;one&quot;2) &quot;two&quot;3) &quot;three&quot; zrangebyscore, zrevrangezrangebyscore key min max [WITHSCORES] [LIMIT offset count]：排序查询set内值，升序排序 min，max：最小值，最大值 可以为 -inf +inf，无穷小，无穷大 WITHSCORES：返回结果包含score LIMIT offset count：获取从指定位置开始的指定数量。 123456789101112131415161718127.0.0.1:6379&gt; zadd salary 2500 ZhangSan(integer) 1127.0.0.1:6379&gt; zadd salary 5000 Lisi(integer) 1127.0.0.1:6379&gt; zadd salary 1234 yn(integer) 1127.0.0.1:6379&gt; zrangebyscore salary -inf +inf withscores # 查询salary在-inf到+inf之间的值 并返回score1) &quot;yn&quot;2) &quot;1234&quot;3) &quot;ZhangSan&quot;4) &quot;2500&quot;5) &quot;Lisi&quot;6) &quot;5000&quot;127.0.0.1:6379&gt; zrangebyscore salary -inf 2600 withscores # 查询salary在-inf到2600之间的值 并返回score1) &quot;yn&quot;2) &quot;1234&quot;3) &quot;ZhangSan&quot;4) &quot;2500&quot; zrevrange key start stop [WITHSCORES]：查询有序集合中，降序排序之后，元素索引在start-stop之间的值。 123456789101112127.0.0.1:6379&gt; ZREVRANGE salary 0 -1 withscores1) &quot;Lisi&quot;2) &quot;5000&quot;3) &quot;ZhangSan&quot;4) &quot;2500&quot;5) &quot;yn&quot;6) &quot;1234&quot;127.0.0.1:6379&gt; ZREVRANGE salary 1 -1 withscores1) &quot;ZhangSan&quot;2) &quot;2500&quot;3) &quot;yn&quot;4) &quot;1234&quot; zremzrem salary value：移除有序集合的指定元素 1234567891011121314127.0.0.1:6379&gt; zrange salary 0 -1 withscores1) &quot;yn&quot;2) &quot;1234&quot;3) &quot;ZhangSan&quot;4) &quot;2500&quot;5) &quot;Lisi&quot;6) &quot;5000&quot;127.0.0.1:6379&gt; zrem salary yn(integer) 1127.0.0.1:6379&gt; zrange salary 0 -1 withscores1) &quot;ZhangSan&quot;2) &quot;2500&quot;3) &quot;Lisi&quot;4) &quot;5000&quot; zcardzcard key：获取有序集合元素个数 12127.0.0.1:6379&gt; zcard salary(integer) 2 zcountzcount key min max：获取score在min-max之间的值的数量。 1234127.0.0.1:6379&gt; zcount salary 2400 2600(integer) 1127.0.0.1:6379&gt; zcount salary 2400 6000(integer) 2 应用场景班级成绩表，工资表排序 带权重消息列表 排行榜 geospatial 地理位置Redis 的 Geo 特性：两级无法直接添加 可以进行地理位置信息的计算，如两地之间的距离，方圆几里的人 有效经度：-180~+180 有效纬度：-85.05112878~+85.05112878 geoadd, geodist, geohash, geopos, georaduis, georadiusbymember geo的底层实现是zset，可以使用zset的方式修改geo的元素。 geoaddgeoadd key longitude latitude member [longitude latitude member ...]：添加地理位置 longitude，latitude：经度，纬度 member：成员 12345678910127.0.0.1:6379&gt; geoadd china:city 116.40 39.90 BeiJing(integer) 1127.0.0.1:6379&gt; geoadd china:city 121.47 31.23 ShangHai(integer) 1127.0.0.1:6379&gt; geoadd china:city 106.50 29.53 ChongQing 114.05 22.52 ShenZhen(integer) 2127.0.0.1:6379&gt; geoadd china:city 120.15 30.28 ZheJiang(integer) 1127.0.0.1:6379&gt; geoadd china:city 108.96 34.26 XiAn(integer) 1 geoposgeopos key member [member ...]：查询值 12345127.0.0.1:6379&gt; geopos china:city BeiJing ChongQing1) 1) &quot;116.39999896287918091&quot; 2) &quot;39.90000009167092543&quot;2) 1) &quot;106.49999767541885376&quot; 2) &quot;29.52999957900659211&quot; geodistgeodist key member1 member2 [m|km|ft|mi] 获取两地之间距离 m 米；km千米；ft英尺；mi英里 1234127.0.0.1:6379&gt; geodist china:city BeiJing ChongQing km #BeiJing到ChongQing距离&quot;1464.0708&quot;127.0.0.1:6379&gt; geodist china:city ShangHai ShenZhen km&quot;1215.9224&quot; georadius在指定的经度和纬度对应位置上，查询指定半径上的成员 georadius key longitude latitude radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] radius，半径 WITHCOORD：包含经度纬度 WITHDIST：包含距离 WITHHASH：包含hash值 COUNT count：数量 12345127.0.0.1:6379&gt; georadius china:city 110 30 1000 km #获取以经纬度为110,30位置为中心，查询1000km附近的城市1) &quot;ChongQing&quot;2) &quot;XiAn&quot;3) &quot;ShenZhen&quot;4) &quot;ZheJiang&quot; 123456127.0.0.1:6379&gt; georadius china:city 110 30 500 km WITHCOORD WITHDIST WITHHASH count 1 #获取500km，返回包含经纬度，距离和Hash，数量指定1.1) 1) &quot;ChongQing&quot; 2) &quot;341.9374&quot; 3) (integer) 4026042091628984 4) 1) &quot;106.49999767541885376&quot; 2) &quot;29.52999957900659211&quot; georadiusbymembergeoradiusbymember key member radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] 以member为中心，查询指定半径范围内的其他member。 123127.0.0.1:6379&gt; georadiusbymember china:city ChongQing 1000 km1) &quot;ChongQing&quot;2) &quot;XiAn&quot; geohashgeohash key member [member ...]：查询member的geohash。 123127.0.0.1:6379&gt; geohash china:city ChongQing BeiJing1) &quot;wm5xzrybty0&quot; #11位2) &quot;wx4fbxxfke0&quot; 将二维的经纬度转换为一维的字符串。 zset相关123456789101112131415127.0.0.1:6379&gt; zrange china:city 0 -11) &quot;ChongQing&quot;2) &quot;XiAn&quot;3) &quot;ShenZhen&quot;4) &quot;ZheJiang&quot;5) &quot;ShangHai&quot;6) &quot;BeiJing&quot;127.0.0.1:6379&gt; zrem china:city BeiJing(integer) 1127.0.0.1:6379&gt; zrange china:city 0 -11) &quot;ChongQing&quot;2) &quot;XiAn&quot;3) &quot;ShenZhen&quot;4) &quot;ZheJiang&quot;5) &quot;ShangHai&quot; Hyperloglog基数统计基数不重复的元素数量 应用场景不重复用户访问量 为什么使用Hyperloglog网站UV：一个用户访问算作一个访问量，UV指的是访问过的人数； 在传统的实现方式中，使用set集合存放用户的id，然后以set集合的元素数量作为判断。 但是，这个方法不好！因为这个功能的目的是为了实现计数，而不是保存用户ID； 基数统计，统计的结果不一定准确，但不需要保存用户ID。 优点 占用内存固定 如2^63不同的元素，这里只需要12KB内存； 特性 误差0.81% 若统计一些允许这样误差的信息，则是可以的。 最大数量2^63，占用内容12KB。 使用pfadd key element [element ...]：向Hyperloglog的key中添加元素。 pfcount key：查询数量 12345678127.0.0.1:6379&gt; pfadd p1 a b c d e f g h i j k l m n(integer) 1127.0.0.1:6379&gt; pfcount p1(integer) 14127.0.0.1:6379&gt; pfadd p1 a b c d e o p q(integer) 1127.0.0.1:6379&gt; pfcount p1(integer) 17 pfmerge destkey sourcekey [sourcekey ...]：合并两个基数统计集合 123456789101112127.0.0.1:6379&gt; pfadd p1 a b c d(integer) 1127.0.0.1:6379&gt; pfadd p2 c d e f(integer) 1127.0.0.1:6379&gt; pfmerge p3 p1 p2 # 合并p1和p2，存放到p3OK127.0.0.1:6379&gt; pfcount p1(integer) 4127.0.0.1:6379&gt; pfcount p2(integer) 4127.0.0.1:6379&gt; pfcount p3(integer) 6 Bitmaps位存储 操作二进制位记录，只有0和1两个状态。 使用setbit key offset value：设置key的offset位置的值为value； value只可以是0或1； 123456127.0.0.1:6379&gt; setbit sign 0 1(integer) 0127.0.0.1:6379&gt; setbit sign 1 0(integer) 0127.0.0.1:6379&gt; setbit sign 2 1(integer) 0 getbit key offset：获取key的offset位置的值； 123456127.0.0.1:6379&gt; getbit sign 0(integer) 1127.0.0.1:6379&gt; getbit sign 1(integer) 0127.0.0.1:6379&gt; getbit sign 2(integer) 1 bitcount key [start end]：查询位为start-end中1的数量 12127.0.0.1:6379&gt; bitcount sign(integer) 2 应用场景统计打卡天数； 设sign为 010，表示 周一没打卡，周二打卡了，周三没打卡 bitcount sign：统计打卡天数。","categories":[],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://zswh33.github.io/tags/Redis/"}]},{"title":"Redis restudy 3 List Set Hash","slug":"Redis-restudy-3","date":"2023-02-11T10:39:09.000Z","updated":"2023-02-13T02:00:56.252Z","comments":true,"path":"2023/02/11/Redis-restudy-3/","link":"","permalink":"http://zswh33.github.io/2023/02/11/Redis-restudy-3/","excerpt":"","text":"List列表。 应用场景栈，队列，阻塞队列。 消息队列。 命令lpush, rpush, lrangelpush key value [value ...]：向key列表的头部插入值； rpush key value [value ...]：向key列表的尾部插入值 lrange key a b：查询key列表a-b的值， 1234567891011121314151617181920212223127.0.0.1:6379&gt; lpush l1 one #在列表头部插入值(integer) 1127.0.0.1:6379&gt; lpush l1 two(integer) 2127.0.0.1:6379&gt; lpush l1 three four(integer) 4127.0.0.1:6379&gt; lrange l1 0 -1 #查询列表中所有值1) &quot;four&quot;2) &quot;three&quot;3) &quot;two&quot;4) &quot;one&quot;127.0.0.1:6379&gt; lrange l1 0 1 # 查询列表中0-1的值1) &quot;four&quot;2) &quot;three&quot;127.0.0.1:6379&gt; rpush l1 five # 列表尾部插入值(integer) 5127.0.0.1:6379&gt; lrange l1 0 -11) &quot;four&quot;2) &quot;three&quot;3) &quot;two&quot;4) &quot;one&quot;5) &quot;five&quot; lpop, rpoplpop key：移除列表头部的元素 rpop key：移除列表尾部的元素 1234567891011121314127.0.0.1:6379&gt; lrange l1 0 -11) &quot;four&quot;2) &quot;three&quot;3) &quot;two&quot;4) &quot;one&quot;5) &quot;five&quot;127.0.0.1:6379&gt; lpop l1&quot;four&quot;127.0.0.1:6379&gt; rpop l1&quot;five&quot;127.0.0.1:6379&gt; lrange l1 0 -11) &quot;three&quot;2) &quot;two&quot;3) &quot;one&quot; lindex, llenlindex key index：获取key中index位置的值。 llen key：获取列表的长度。 123456789127.0.0.1:6379&gt; lrange l1 0 -11) &quot;three&quot;2) &quot;two&quot;3) &quot;one&quot;127.0.0.1:6379&gt; lindex l1 2 # 获取index为2的值&quot;one&quot;127.0.0.1:6379&gt; llen l1 # 获取列表长度(integer) 3 lremlrem key count value ：移除指定数量的value值。精确匹配。 123456789101112131415127.0.0.1:6379&gt; lpush l1 one two three one one # 向列表l1插入值(integer) 5127.0.0.1:6379&gt; lrange l1 0 -1 # 获取值1) &quot;one&quot;2) &quot;one&quot;3) &quot;three&quot;4) &quot;two&quot;5) &quot;one&quot;127.0.0.1:6379&gt; lrem l1 1 three #移除1个three(integer) 1127.0.0.1:6379&gt; lrem l1 2 one # 移除2个one(integer) 2127.0.0.1:6379&gt; lrange l1 0 -11) &quot;two&quot;2) &quot;one&quot; ltrim key start stop：裁剪列表，保留start-stop中的元素； 1234567891011121314127.0.0.1:6379&gt; lpush l1 one two three four five(integer) 5127.0.0.1:6379&gt; lrange l1 0 -11) &quot;five&quot;2) &quot;four&quot;3) &quot;three&quot;4) &quot;two&quot;5) &quot;one&quot;127.0.0.1:6379&gt; ltrim l1 1 3 # 裁剪列表，留下index为1-3的元素OK127.0.0.1:6379&gt; lrange l1 0 -11) &quot;four&quot;2) &quot;three&quot;3) &quot;two&quot; rpoplpushrpoplpush source destination：从列表source的尾部取出元素，插入到列表destination列表的尾部； 1234567891011127.0.0.1:6379&gt; lrange l1 0 -11) &quot;four&quot;2) &quot;three&quot;3) &quot;two&quot;127.0.0.1:6379&gt; rpoplpush l1 l2&quot;two&quot;127.0.0.1:6379&gt; lrange l1 0 -11) &quot;four&quot;2) &quot;three&quot;127.0.0.1:6379&gt; lrange l2 0 -11) &quot;two&quot; lsetlset key index value ：设置index位置的值为value 只能设置key存在的列表，若key不存在则报错 (error) ERR no such key 不返回原值。 123456789101112127.0.0.1:6379&gt; lpush l1 one two three(integer) 3127.0.0.1:6379&gt; lrange l1 0 -11) &quot;three&quot;2) &quot;two&quot;3) &quot;one&quot;127.0.0.1:6379&gt; lset l1 1 four # 设置index为1的值为fourOK127.0.0.1:6379&gt; lrange l1 0 -11) &quot;three&quot;2) &quot;four&quot;3) &quot;one&quot; linsertlinsert key BEFORE|AFTER pivot element 向值为pivot的位置的前面或后面插入值element。 1234567891011127.0.0.1:6379&gt; lrange l1 0 -11) &quot;three&quot;2) &quot;four&quot;3) &quot;one&quot;127.0.0.1:6379&gt; linsert l1 before four other # 向four的前面插入other(integer) 4127.0.0.1:6379&gt; lrange l1 0 -11) &quot;three&quot;2) &quot;other&quot;3) &quot;four&quot;4) &quot;one&quot; 其他 本质为一个“链表” 在两边插入或改动值，效率最高！ Set集合 set中的值不能重复。 sadd, smembers, sismember, scardsadd key value [value ...]：向集合添加元素 smembers key：查看元素成员列表 sismember key value：查询value是否为key集合的成员 scard key：获取集合中成员数量 12345678910111213141516127.0.0.1:6379&gt; sadd s1 hello # 向集合添加元素(integer) 1127.0.0.1:6379&gt; sadd s1 yn(integer) 1127.0.0.1:6379&gt; sadd s1 llllyn(integer) 1127.0.0.1:6379&gt; smembers s1 # 查询集合成员1) &quot;yn&quot;2) &quot;llllyn&quot;3) &quot;hello&quot;127.0.0.1:6379&gt; sismember s1 hello # 查看集合中是否存在某个值(integer) 1127.0.0.1:6379&gt; sismember s1 word(integer) 0127.0.0.1:6379&gt; scard s1 #获取s1集合中成员数量(integer) 3 sremsrem key value：移除指定值 srandmember key count：随机取出集合中元素，count为数量，count默认为1 123456789101112131415161718127.0.0.1:6379&gt; smembers s1 #获取集合s1成员1) &quot;yn&quot;2) &quot;llllyn&quot;3) &quot;hello&quot;127.0.0.1:6379&gt; srem s1 yn # 移除s1中值为yn的成员(integer) 1127.0.0.1:6379&gt; smembers s1 #获取集合s1中成员1) &quot;llllyn&quot;2) &quot;hello&quot;127.0.0.1:6379&gt; SRANDMEMBER s1 # 在集合s1中随机取出元素&quot;llllyn&quot;127.0.0.1:6379&gt; SRANDMEMBER s1&quot;llllyn&quot;127.0.0.1:6379&gt; SRANDMEMBER s1&quot;hello&quot;127.0.0.1:6379&gt; SRANDMEMBER s1 21) &quot;llllyn&quot;2) &quot;hello&quot; spopspop key [count]：随机弹出元素，count为数量 1234567891011121314127.0.0.1:6379&gt; smembers s11) &quot;llllyn&quot;2) &quot;one&quot;3) &quot;hello&quot;4) &quot;four&quot;5) &quot;three&quot;6) &quot;two&quot;127.0.0.1:6379&gt; spop s1 # 随机删除元素&quot;hello&quot;127.0.0.1:6379&gt; spop s1&quot;three&quot;127.0.0.1:6379&gt; spop s1 21) &quot;two&quot;2) &quot;four&quot; smovesmove key1 key2 value：将一个集合中指定的值移动到另一个集合中。 123456789101112127.0.0.1:6379&gt; smembers s1 # s1集合中1) &quot;one&quot;2) &quot;two&quot;127.0.0.1:6379&gt; smembers s2 # s2集合中1) &quot;three&quot;127.0.0.1:6379&gt; smove s1 s2 two #将s1集合中two移动到s2集合中(integer) 1127.0.0.1:6379&gt; smembers s1 1) &quot;one&quot;127.0.0.1:6379&gt; smembers s21) &quot;two&quot;2) &quot;three&quot; sdiff, sinter, sunionsdiff set1 set2：获得set1与set2的差集 sinter s1 s2：查询s1和s2的交集 sunion s1 s2：查询s1和s2的并集 123456789101112131415127.0.0.1:6379&gt; sadd s1 a b c(integer) 3127.0.0.1:6379&gt; sadd s2 c d e(integer) 3127.0.0.1:6379&gt; sdiff s1 s2 # 差集1) &quot;b&quot;2) &quot;a&quot;127.0.0.1:6379&gt; sinter s1 s2 # 交集1) &quot;c&quot;127.0.0.1:6379&gt; sunion s1 s2 #并集1) &quot;b&quot;2) &quot;c&quot;3) &quot;e&quot;4) &quot;a&quot;5) &quot;d&quot; Hash（哈希）key-&lt;key-value&gt; key-Map 值为map集合； hset, hget, hmget, hmset, hgetallhset key field value：设置值 hget key field：获取值 hmset key field value [field value ...]：设置多个值 hmget key field [field...]：获取多个值 hgetall key：获取所有值 1234567891011121314151617181920127.0.0.1:6379&gt; hset h1 f1 hello #设置h1哈希的f1值为hello(integer) 1127.0.0.1:6379&gt; hget h1 f1 #获取h1哈希的f1值&quot;hello&quot;127.0.0.1:6379&gt; hmset h1 f2 world f3 one f4 two #设置多个值OK127.0.0.1:6379&gt; hmget h1 f1 f2 f3 f4 #获取多个值1) &quot;hello&quot;2) &quot;world&quot;3) &quot;one&quot;4) &quot;two&quot;127.0.0.1:6379&gt; hgetall h1 #获取所有值1) &quot;f1&quot;2) &quot;hello&quot;3) &quot;f2&quot;4) &quot;world&quot;5) &quot;f3&quot;6) &quot;one&quot;7) &quot;f4&quot;8) &quot;two&quot; hdel, hlenhdel key field [field ...]：删除指定key的field，对应value同时会消失 hlen key：获取hash长度 1234567891011127.0.0.1:6379&gt; hdel h1 f1 f2 f3 #删除h1的f1，f2，f3(integer) 3127.0.0.1:6379&gt; hgetall h1 #获取h1的所有字段1) &quot;f4&quot;2) &quot;two&quot;127.0.0.1:6379&gt; hlen h1 #获取h1的长度(integer) 1127.0.0.1:6379&gt; hset h1 f1 one f2 three #添加字段(integer) 2127.0.0.1:6379&gt; hlen h1(integer) 3 hexists key field：判断key的field是否存在 hkeys key：获取所有field hvals key：获取所有values 12345678910111213141516171819127.0.0.1:6379&gt; hgetall h11) &quot;f4&quot;2) &quot;two&quot;3) &quot;f1&quot;4) &quot;one&quot;5) &quot;f2&quot;6) &quot;three&quot;127.0.0.1:6379&gt; hexists h1 f1 #查看f1是否存在(integer) 1127.0.0.1:6379&gt; hexists h1 f5 #查看f5是否存在(integer) 0127.0.0.1:6379&gt; hkeys h1 #获取h1的所有field1) &quot;f4&quot;2) &quot;f1&quot;3) &quot;f2&quot;127.0.0.1:6379&gt; hvals h1 #获取h1的所有value1) &quot;two&quot;2) &quot;one&quot;3) &quot;three&quot; hincrby, hsetnxhincrby key field increment：执行自增，可以指定增量 hsetnx key field value：与set一致，不同的是仅用于“key值不存在”时，若存在则不进行 12345678910127.0.0.1:6379&gt; hset h2 f1 3 # 设置值(integer) 1127.0.0.1:6379&gt; hincrby h2 f1 10 #值自增，指定增量为10(integer) 13127.0.0.1:6379&gt; hget h2 f1 #获取值&quot;13&quot;127.0.0.1:6379&gt; hsetnx h2 f2 4 #若f2不存在，则进行(integer) 1 #进行成功127.0.0.1:6379&gt; hsetnx h2 f2 10 #上面有f2了(integer) 0 #失败 技巧对象存储设置user的id为1的用户，name为ZhangSan，age为16。 123456789127.0.0.1:6379&gt; hset user:1 name ZhangSan(integer) 1127.0.0.1:6379&gt; hset user:1 age 16(integer) 1127.0.0.1:6379&gt; hgetall user:11) &quot;name&quot;2) &quot;ZhangSan&quot;3) &quot;age&quot;4) &quot;16&quot;","categories":[],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://zswh33.github.io/tags/Redis/"}]},{"title":"Redis restudy 2 基础 Redis-key String","slug":"Redis-restudy-2","date":"2023-02-11T09:27:06.000Z","updated":"2023-02-12T03:59:15.544Z","comments":true,"path":"2023/02/11/Redis-restudy-2/","link":"","permalink":"http://zswh33.github.io/2023/02/11/Redis-restudy-2/","excerpt":"","text":"RedisRedis,Remote Dictionary Server，远程字典服务 6379 概述是什么是一个开源的使用ANSI C语言编写、支持网络，可基于内存亦可持久化的日志型、Key-Value数据库，并提供给多种语言的API。 当下最热门的NoSQL技术之一，也被人们称为结构化数据库。 能做什么 内存存储、持久化，内存中是断电即逝的，持久化很重要 持久化，即rdb，aof 效率高，可以用于高速缓存 发布订阅系统 地图信息分析 计时器，计数器（浏览量） … 特性 多样的数据类型 持久化 集群 事务 … 使用1234567127.0.0.1:6379&gt; ping #测试连接PONG127.0.0.1:6379&gt; set name yn #设置值OK127.0.0.1:6379&gt;127.0.0.1:6379&gt; get name #获取值&quot;yn&quot; 1234yyn@yynlinux:~$ ps -ef | grep redis #查看进程列表并筛选redisredis 673 1 0 09:56 ? 00:00:48 /usr/bin/redis-server 0.0.0.0:6379yyn 9224 9029 0 11:20 pts/0 00:00:00 grep --color=auto redis 测试性能redis-benchmark 12345678910111213-h 指定服务器主机名 127.0.0.1-p 指定服务器端口 6379-s 指定服务器socket-c 指定并发连接数 50-n 指定请求数 10000-d 以字节形式指定SET/GET数据大小 2-k 1=keep alive 0=reconnect-r set/get/incr使用随机key，SADD使用随机值-P 通过管道传输&lt;numreq&gt;请求-q 强制退出redis，仅显示query/sec值-csv 以csv格式输出-l 生成循环，永久执行测试-t 仅运行以逗号分割的测试命令列表 使用 12# 测试100个并发连接， 100000请求redis-benchmark -h localhost -p 6379 -c 100 -n 100000 123456789101112131415161718192021222324252627282930313233root@yynlinux:~# redis-benchmark -h localhost -p 6379 -c 100 -n 10000====== PING_INLINE ====== 10000 requests completed in 3.77 seconds # 10000请求 100 parallel clients # 100并发客户端 3 bytes payload # 每次写入3字节 keep alive: 1 # 只有一台服务器处理这些请求，单机性能 host configuration &quot;save&quot;: 900 1 300 10 60 10000 host configuration &quot;appendonly&quot;: no multi-thread: no0.01% &lt;= 6 milliseconds0.02% &lt;= 7 milliseconds0.17% &lt;= 8 milliseconds...100.00% &lt;= 56 milliseconds # 所有请求在56毫秒内处理完成2655.34 requests per second #每秒处理2655个请求====== PING_BULK ====== 10000 requests completed in 3.72 seconds 100 parallel clients 3 bytes payload keep alive: 1 host configuration &quot;save&quot;: 900 1 300 10 60 10000 host configuration &quot;appendonly&quot;: no multi-thread: no0.01% &lt;= 7 milliseconds0.33% &lt;= 8 milliseconds...99.94% &lt;= 73 milliseconds100.00% &lt;= 74 milliseconds2687.45 requests per second 基础知识Redis默认有16个数据库。默认使用第0个数据库； 使用select进行数据库切换。 12345678910111213127.0.0.1:6379&gt; select 1 #切换到数据库1OK127.0.0.1:6379[1]&gt; select 2 #切换到数据库2OK127.0.0.1:6379[2]&gt; set name yn #设置一个值OK127.0.0.1:6379[2]&gt; dbsize #查看当前数据库大小(integer) 1127.0.0.1:6379[2]&gt; keys * #查看所有的key1) &quot;name&quot;127.0.0.1:6379[2]&gt; get name&quot;yn&quot; select，进行数据库切换 dbsize，查看当前数据库大小 keys * ，查看当前数据库所有的key flushdb，清空当前数据库 flushall，清除所有数据库内容 Redis是单线程的Redis很快。 官方表示：Redis基于内存操作，CPU不是Redis性能瓶颈，Redis瓶颈是机器内存和网络带宽，既然可以使用单线程，所以就使用单线程了。 Redis为什么单线程这么快？ Redis是将所有数据全部放在内存中的，使用单线程去操作效率就是最高的，多线程会上下文切换，对于内存系统来说，如果没有上下文切换，效率就是最高的。多次读写都是在一个CPU，在内存情况下，单线程就是最佳方案。 介绍可以用作：数据库、缓存和消息中间件 支持strings字符串，hashes散列，lists列表，sets集合，sorted sets有序集合与范围查询； bitmaps，hyperloglogs和geospatial地理空间索引半径查询。 内置复制replication、LUA脚本、LRU驱动事件，事务和不同级别的磁盘持久化； 并通过Redis哨兵Sentinel和自动分区Cluster提高可用性。 数据类型五大数据类型：Redis-key，String，List，Set，Hash，Zset 三种特殊数据类型：geospatial，hyperloglogs，bitmaps –Redis-Keyexists，查看键值是存在。1234567127.0.0.1:6379&gt; set name ynOK127.0.0.1:6379&gt; exists name # 查看name是否存在(integer) 1 # 1表示存在127.0.0.1:6379&gt; exists names(integer) 0 # 0表示不存在 move，移动数据到指定数据库move name 1将name移动到数据库1 12345678910127.0.0.1:6379&gt; get name&quot;yn&quot;127.0.0.1:6379&gt; move name 1(integer) 1127.0.0.1:6379&gt; get name(nil)127.0.0.1:6379&gt; select 1OK127.0.0.1:6379[1]&gt; get name&quot;yn&quot; expire，设置过期expire key seconds: 设置key到seconds秒后过期 123456789127.0.0.1:6379&gt; get name&quot;yn&quot;127.0.0.1:6379&gt; expire name 10 # 设置name在10秒后过期(integer) 1127.0.0.1:6379&gt; get name&quot;yn&quot;127.0.0.1:6379&gt; get name #10秒后(nil) ttl，查看剩余多长时间ttl key 12345678910111213141516127.0.0.1:6379&gt; set name ynOK127.0.0.1:6379&gt; ttl name(integer) -1127.0.0.1:6379&gt; expire name 10(integer) 1127.0.0.1:6379&gt; ttl name(integer) 8127.0.0.1:6379&gt; ttl name(integer) 6127.0.0.1:6379&gt; ttl name(integer) 2127.0.0.1:6379&gt; ttl name(integer) -2127.0.0.1:6379&gt; get name(nil) type，查看数据类型type key 1234127.0.0.1:6379&gt; set name ynOK127.0.0.1:6379&gt; type namestring String（字符串）命令设置，获取，追加，获取长度 set key value：设置值 get key ：获取值 append key value：在字符串后面追加值 若key不存在，则新建key，然后值为追加的值。（相当于set key） strlen: 获取字符串长度 123456789101112127.0.0.1:6379&gt; set name zhang #设置name值为zhangOK127.0.0.1:6379&gt; get name # 获取name的值&quot;zhang&quot;127.0.0.1:6379&gt; strlen name # 获取name值的长度(integer) 5127.0.0.1:6379&gt; append name San #在name值后面追加San(integer) 8127.0.0.1:6379&gt; strlen name # 获取name值的长度(integer) 8127.0.0.1:6379&gt; get name # 获取name值&quot;zhangSan&quot; 自增，自减，步长 incr key：若key对应值为一个整数，则实现自增1 decr key：自减1 incrby key increment：自增，可以指定步长 decrby key increment：自减，可以指定步长 1234567891011121314151617127.0.0.1:6379&gt; set views 0 #设置值 （初始浏览量为0）OK127.0.0.1:6379&gt;127.0.0.1:6379&gt; incr views # 自增 （浏览量变为1）(integer) 1127.0.0.1:6379&gt; incr views (integer) 2127.0.0.1:6379&gt; get views #获取值 &quot;2&quot;127.0.0.1:6379&gt; decr views #自减(integer) 1127.0.0.1:6379&gt; get views&quot;1&quot;127.0.0.1:6379&gt; incrby views 6 # 自增，步长为6 (integer) 7127.0.0.1:6379&gt; decrby views 4 # 自减，步长为4(integer) 3 截取，替换 getrange key a b：获取key对应值从a到b的所有内容（包括a且包括b）； 1234567891011127.0.0.1:6379&gt; set key1 &quot;hello,ZhangSan&quot; #设置值OK127.0.0.1:6379&gt; get key1&quot;hello,ZhangSan&quot;127.0.0.1:6379&gt; getrange key1 0 3 #截取字符串&quot;hell&quot;127.0.0.1:6379&gt; getrange key1 0 -1 # -1表示倒数第1个字符&quot;hello,ZhangSan&quot;127.0.0.1:6379&gt; getrange key1 -3 -1 # 截取字符串 倒数第3个字符到倒数第1个字符的内容&quot;San&quot; setrange key offset value：从offset开始，替换为value。替换指定位置开始的字符串。 123456127.0.0.1:6379&gt; get key1&quot;hello,ZhangSan&quot;127.0.0.1:6379&gt; setrange key1 3 xxxx(integer) 14127.0.0.1:6379&gt; get key1&quot;helxxxxhangSan&quot; 设置值同时设置过期时间 setex (set with expire)：设置值的同时设置过期时间 setex key expire value &#96;&#96;&#96;bash127.0.0.1:6379&gt; setex key3 60 qqweasd #设置key3的值，过期时间为60秒OK127.0.0.1:6379&gt; get key3“qqweasd”127.0.0.1:6379&gt; ttl key3(integer) 50127.0.0.1:6379&gt; ttl key3(integer) 48 1234567891011121314151617181920### 若值不存在则设置，否则失败- setnx (set if nost exist)：不存在则进行set - setnx key value - 在分布式锁中会常常使用。 - ```bash 127.0.0.1:6379&gt; mget key4 key5 # key4值为qqqwwweeee，key5没有值 1) &quot;qqqwwweeee&quot; 2) (nil) 127.0.0.1:6379&gt; setnx key4 qweasd # 设置key4值为qweasd (integer) 0 #失败 127.0.0.1:6379&gt; setnx key5 aaaaaa # 设置key5值为aaaaaa (integer) 1 #成功 127.0.0.1:6379&gt; mget key4 key5 1) &quot;qqqwwweeee&quot; # key4并没有被set 2) &quot;aaaaaa&quot; # key5值set成功 mset, mget, msetnx mset key value [key value ...]：可以一次设置多个值； mget key [key ...]：可以一次获取多个值 msetnx key value [key value ...]：设置多个值，若值不存在则设置。 这是一个原子性操作，要么一起成功，要么一起失败。 123456127.0.0.1:6379&gt; mset k1 v1 k2 v2 k3 v3 # 设置 k1=v1 k2=v2 k3=v3OK127.0.0.1:6379&gt; mget k1 k2 k3 # 获取多个值 1) &quot;v1&quot;2) &quot;v2&quot;3) &quot;v3&quot; getset getset key value：获取值并设置值 若key不存在，则创建并赋值，返回nil 若key存在，返回值并修改值 123456127.0.0.1:6379&gt; get k1(nil)127.0.0.1:6379&gt; getset k1 qweasd # 获取值，但是k1没有值，此时设置值(nil)127.0.0.1:6379&gt; get k1&quot;qweasd&quot; 可以存放什么，可以做什么字符串，数字 应用场景：计数器，统计数量，粉丝数，对象存储。 使用技巧技巧不是Redis的基础知识，只是Redis的一些使用技巧。 对象可以通过“POJO：ID：KEY”的方式设计一个对象，如： mset user:1:name zhangsan user:1:age 2 设计了一个 user的id为1，属性为： 1&#123;&quot;name&quot;:&quot;zhangsan&quot;,&quot;age&quot;:2&#125; 的一个对象。 12345127.0.0.1:6379&gt; mset user:1:name zhangsan user:1:age 4OK127.0.0.1:6379&gt; mget user:1:name user:1:age1) &quot;zhangsan&quot;2) &quot;4&quot;","categories":[],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://zswh33.github.io/tags/Redis/"}]},{"title":"Redis restudy 1 NoSQL","slug":"Redis-restudy-1","date":"2023-02-11T05:17:16.000Z","updated":"2023-02-11T10:38:31.731Z","comments":true,"path":"2023/02/11/Redis-restudy-1/","link":"","permalink":"http://zswh33.github.io/2023/02/11/Redis-restudy-1/","excerpt":"","text":"NoSQL概述为什么要用Nosql：大数据 发展 单机MySQL年代 网站瓶颈： 数据量太大，一个机器放不下； 数据索引（B+ Tree）一个机器内存放不下； 访问量太大； Memcached（缓存） + MySQL + 垂直拆分 优化发展过程： 优化数据结构和索引； 文件缓存（IO）； Memcached。（当时最热门的技术） 网站80%的情况都是在读，每次到数据库查询非常麻烦；为减轻数据库压力，可以设置缓存。 分库分表：水平拆分 水平拆分：Mysql集群。 为什么要用NoSQL用户个人信息，社交网络，地理位置。用户自己产生的数据，用户日志等等爆发式的增长！ NoSQL可以很好地处理以上的情况； 什么是NoSQLNoSQL &#x3D; Not Only SQL （不仅仅是SQL） 泛指：非关系型数据库 随着Web2.0互联网的诞生，传统的关系型数据库已难以应付，尤其是超大规模的高并发的社区！ 很多数据类型用户的个人信息，社交网络，地理位置。这些数据类型的存储不需要一个固定的格式。不需要多余的操作就可以横向扩展的。使用键值对来控制。 NoSQL特点 方便扩展（数据之间没有关系，扩展方便！） 大数据量高性能（Redis 一秒可以写8万次） 数据类型多样型 传统RDBMS与NoSQL区别 RDBMS 结构化组织 SQL 数据和关系都存储在单独的表中 row col 数据操作语言，数据定义语言 严格的一致性 基础的事务操作 … NoSQL 不仅仅是数据 没有固定查询语言 多种存储方式：键值对存储，列存储，文档存储，图形数据库（社交关系） 最终一致性 CAP定理和BASE理论 （异地多活！） 高性能，高可用，高可扩展性 … 大数据时代的3V+3高3V：用来描述问题 海量Volume，多样Variety，实时Velocity 3高：对程序的要求 高并发 高可扩（随时水平拆分，随时扩展机器） 高性能（保证用户体验和性能） 数据架构 商品的基本信息 名称、价格、商家信息 使用关系型数据库； 商品的描述，评论（文字比较多的情况） 使用文档型数据库，MongoDB 图片 分布式文件系统，FastDFS； 淘宝自己的：TFS Google：GFS Hadoop：HDFS 阿里云： OSS 商品的关键字（用来搜索） 搜索引擎 solr，elasticsearch 淘宝用的：ISearch 商品的热门波段信息 内存数据库 Redis，Tair，Memcache… 商品的交易，外部的支付接口 三方应用。 大型互联网的应用问题 数据类型太多了 数据源繁多，经常重构 数据要改造，需要大面积改造 解决方案：UDSL（统一的数据服务层）。 NoSQL四大分类 KV键值对： 新浪：Redis 美团：Redis + Tair 阿里、百度：Redis + memcache 文档型数据库（bson格式，与JSON一样） MongoDB MongoDB（一般必须要掌握）：基于分布式文件存储的数据库，用C++编写，主要用来处理大量的文档。 MongoDB是一个介于关系型数据库和非关系型数据库中间的产品。 MongoDB是非关系型数据库中功能最丰富最像关系型数据库的。 ConthDB 列存储数据库 HBase 分布式文件系统 图形关系数据库 不是用来存图形的 存储关系，比如：朋友圈社交网络，广告推荐。 Neo4j，infoGrid 分类 举例 典型应用场景 数据模型 优点 缺点 键值对 Redis，Oracle BDB 内容缓存，主要用于存储大量数据的高访问负载，也用于一些日志系统等等 Key指向Value的键值对，通常用hash table实现 查找速度快 数据无结构化，通常只被当做字符串或二进制数据。 列存储数据库 Cassandra，HBase 分布式文件系统 以列簇式存储，将同一列数据存在一起 查找速度快，可扩展性强，更容易进行分布式扩展 功能相对局限 文档型数据库 CouchDB,MongoDB Web应用（与Key-Value类似，Value是结构化的，不同的是数据库能够了解Value的内容） Key-Value对应的键值对，Value为结构化数据 数据结构要求不严格，表结构可变，不需要像关系数据库一样需要预先定义表结构 查询性能不高，而且缺乏统一的查询语法 图形数据库 Neo4J，InfoGrid，Infinite Graph 社交网络，推荐系统等，专注于构建关系图谱 图结构 利用图结构相关算法，比如最短路径寻址，N度关系查找等 很多时候需要对整个图做计算才能得出需要的信息，而且这种结构不太好做分布式的集群方案 其他垂直拆分：读写分离 三个mysql服务器， 可以设定，第二个负责写，其他两个负责读； 写数据到2，读数据到1和3；1和3随时同步来自2的数据。 水平拆分：Mysql集群Mysql引擎早些年MyISAM：表锁（读写锁整个表，十分影响效率，高并发会有严重的问题） 现在Innodb：行锁（读写锁一行）。 Redis数据类型 五大基础数据类型 String List Set Hash Zset 三种特殊数据类型 geo hyperloglog bitmap 要学的Redis，MongoDB，HBase，Neo4j","categories":[],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://zswh33.github.io/tags/Redis/"}]},{"title":"动态规划学习","slug":"动态规划学习","date":"2023-01-04T06:43:46.000Z","updated":"2023-01-08T08:39:00.647Z","comments":true,"path":"2023/01/04/动态规划学习/","link":"","permalink":"http://zswh33.github.io/2023/01/04/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"题目特点 计数 有多少种方式走到右下角 有多少种方法选出k个数使得和是sum 求最大最小值 从左上角走到右下角路径的最大数字和 最长上升子序列长度 求存在性 取石子游戏，先手是否必胜 能不能选出k个数使得和是sum 动态规划组成部分https://www.lintcode.com/problem/669/ 提出问题：给出面值2,5,7三种硬币，要求拼出27元，求最少需要多少硬币？ 一、确定状态 两个意识 最后一步 子问题 原问题：最少用多少枚拼出27 转化子问题：最少用多少枚硬币拼出27-ak 设状态f(X) &#x3D; 最少用多少枚硬币拼出X 子问题： 最后一枚硬币ak可能为2,5或7， 若ak是2，则 f( 27 ) &#x3D; f( 27 - 2 ) + 1 若ak是5，则 f( 27 ) &#x3D; f( 27 - 5 ) + 1 若ak是7，则 f( 27 ) &#x3D; f( 27 - 7 ) + 1 要求最少硬币数，即：$$f(27) &#x3D; min(f(27-2)+1,f(27-5)+1,f(27-7)+1)$$ 二、转移方程把括号换为中括号$$f[X] &#x3D; min{f[x-2]+1,f[x-5]+1,f[x-7]+1}$$ 三、初始条件和边界情况 边界情况 若x-2，x-5或x-7小于0怎么办？什么时候停下来？ 若不能拼出Y，则定于f[Y]&#x3D;+∞ 如：f[-1] &#x3D; f[-2] &#x3D; … &#x3D; +∞ 此时 $$f[1] &#x3D; min{f[-1]+1,f[-4]+1,f[-6]+1} &#x3D; +∞$$ 即：拼不出来1 初始条件：f[0] &#x3D; 0 四、计算顺序 计算顺序：f[0]，f[1]，f[2] …, f[27]。 总结 确定状态 最后一步（最优策略中使用最后一枚硬币ak） 化成子问题（最少的硬币拼出更小的面值27-ak） 转移方程 f[X] &#x3D; min ( f[X-2]+1, f[x-5]+1, f[X-7]+1 ) 初始条件和边界情况 f[0] &#x3D; 0 若不能拼出Y，f[Y] &#x3D; 正无穷 计算顺序 f[0], f[1], f[2], … 常见动态规划题 坐标型动态规划 序列型动态规划 划分型动态规划 区间型动态规划 背包型动态规划 最长序列型动态规划 博弈型动态规划 例题序列型动态规划… 划分型动态规划Decode Ways 确定状态 最后一步：最后一个字母，在数字序列中可以有N-1或N-1与N-2 子问题： 求数字串前N个字符的解密方式数，即需要知道数字串前N-1和N-2个字符的解密方式数； 状态：设数字串S前i个数字解密成字母串有**f[i]**种方式。 转移方程$$f[i] &#x3D; f[i-1]|S[i-1]对应一个字母 + f[i-2]|S[i-2]S[i-1]对应一个字母$$ 初始条件和边界情况 初始条件：f[0] &#x3D; 1，即空串有1种方式解密 解密成空串 边界情况，若i&#x3D;1，则只有一个数字 计算顺序 f[0]，f[1]，f[2]，…，f[N] 坐标型动态规划","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://zswh33.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"openEuler 7","slug":"openEuler-7","date":"2022-11-28T13:35:33.000Z","updated":"2022-11-28T13:51:36.303Z","comments":true,"path":"2022/11/28/openEuler-7/","link":"","permalink":"http://zswh33.github.io/2022/11/28/openEuler-7/","excerpt":"","text":"网络管理一些概念设备：主机内的网卡； 广播地址：到达本网段上所有主机的地址； 接口：为使用设备，驱动程序在设备上创建了接口； 子网掩码：将IP地址划分成网络地址和主机地址两部分的掩码； 路由：IP包跨网段访问时候的下一跳地址； 链路：设备到网络的连接；","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://zswh33.github.io/tags/Linux/"}]},{"title":"openEuler 6 任务管理","slug":"openEuler-6","date":"2022-11-28T07:33:11.000Z","updated":"2022-11-28T13:35:11.100Z","comments":true,"path":"2022/11/28/openEuler-6/","link":"","permalink":"http://zswh33.github.io/2022/11/28/openEuler-6/","excerpt":"","text":"任务管理介绍 在系统运维过程中，可能需要在某个预设的时间执行特定任务 如：定时发送邮件、备份并清空日志文件等任务； 任务的内容可以看做是一系列命令或一个脚本，我们需要在特定时间去执行； at语法 at [-V] [-q 队列] [-f 文件名] [-mldbv] 时间 at -c 作业[作业…] 类型计划执行，在特定时间运行一次：at 定期执行，按周期执行多次：cron 计划执行atat命令可以指定Linux在特定时刻运行脚本； atd是at的守护进程，在系统启动时会以后台模式运行； atd定期检查系统上/var/spool/at目录中，通过at命令写入的任务； 这个命令至少需要指定一个命令和一个执行时间； 时间上，at命令可以只指定时间，也可以时间日期一起指定； 指定时间的方式有两种绝对计时和相对计时 绝对计时格式：at 时间 日期 当前的时间：hh:mm，如果时间已经过去，则会在第二天执行； 使用midnight、noon、teatime来指定时间； teatime饮茶时间，一般指下午4点； 采用12小时计时制，即在时间后面加上AM或PM来说明是上午还是下午； 指定命令执行的具体日期，格式为：month day 或 mm/dd/yy 或 dd.mm.yy 。指定日期必须在指定时间的后面； 也可以用today和tommorrow表示今天或明天； 相对计时格式：at now+数量 单位 格式为now+count time-units ， now就是当前时间 time-units是时间单位； 这里可以是 minutes hours days weeks count是时间的数量， 可以用数字，表示几天、几个小时等； 其他可以使用today或tomorrow来表示日期； 示例假定目前时间为 12:30 2020年6月7日，要在今天16:30执行某个命令，命令如下： 绝对计时 at 16:30 at 4:30pm at 16:30 today at 16:30 7.6.20 at 16:30 6&#x2F;7&#x2F;20 at 16:30 Jun 7 相对计时 at now+240 minutes at now+4 hours 执行权限对于at命令，需要定时执行的命令来自标准输入或者使用-f指定文件中读取执行； 如果at命令是su切换到用户shell执行的，那么当前用户会被认为是执行用户，所有错误和输出结果都会返回给这个用户； 对于其他用户，是否允许被使用at命令，主要在于/etc/at.allow和/etc/at.deny文件中指定； at.allow的优先级高于at.deny。 其他管理命令at TIME：增加任务 atq：查询所有任务 atq -c &lt;id&gt;：查询任务详细信息 atrm &lt;id&gt;：删除指定任务 使用 123456789101112# 添加一个定时事件[root@localhost tmp]# at now+3hourswarning: commands will be executed using /bin/shat Mon Nov 28 23:24:00 2022at&gt; echo &quot;zzzcszczcs&quot; &gt; /tmp/aaw.logat&gt; &lt;EOT&gt;job 6 at Mon Nov 28 23:24:00 2022# 查询定时事件[root@localhost tmp]# atq6 Mon Nov 28 23:24:00 2022 a root4 Mon Nov 28 21:23:00 2022 a root5 Mon Nov 28 22:23:00 2022 a root 123456789# 详细查询指定定时事件[root@localhost tmp]# at -c 6#!/bin/sh# atrun uid=0 gid=0# mail root 0umask 22SHELL=/bin/bash; export SHELLHISTCONTROL=ignoredups; export HISTCONTROLHISTSIZE=1000; export HISTSIZE 周期性执行cron周期性重复执行一些命令，使用cron； cron会搜索/var/spool/cron目录，寻找以/etc/passwd文件中用户名命名的crontab文件，然后将crontab文件装入内存，即用户cron时间表； cron还将搜索/etc/crontab文件，即系统cron时间表； cron启动后，先检查是否存在需要运行的crontab文件； 若没有则转入睡眠状态，释放系统资源； 之后每分钟唤醒一次，查看当前是否有需要运行的命令。 crontab管理cron进程表格crontab用于安装、删除或打印用于驱动cron后台进程的表格； 用户把需要执行的命令序列放到crontab文件中执行，每个用户都拥有自己的crontab文件； crontab命令： 1234crontab -u # 设置指定用户的cron服务crontab -l # 列出指定用户的cron服务详细内容crontab -r # 删除指定用户的cron服务crontab -e # 编辑指定用户的cron服务 crontab文件中的时间表在crontab文件中指定需要执行的命令和执行时间； 文件每行有6个域，前5个域指定命令执行的时间，最后一个是要执行的命令，格式如下： 格式1minute hour day-of-month month-of-year day-of-week commands 参数 描述 minute 分钟 0~59 hour 小时 0~23 day-of-month 一个月的第几天 1-31 month-of-year 一年的第几个月 1~12 day-of-week 一周的周几 0 ~ 6 commands 执行的命令 如：每周一上午8:00执行命令 100 08 * * 1 commands 参数 参数 描述 * 所有取值范围内的数字 &#x2F; 每，如“*&#x2F;5”指的是每5个单位； - 从 一个数字 到另一个数字 , 离散的数字 如：晚上11点到早上8点之间每过2小时，在&#x2F;tmp&#x2F;test.txt文件中加入sleepy文本： 10 23-8/2 * * * echo &quot;sleepy&quot; &gt;&gt; /tmp/test.txt crontab文件 &#x2F;etc&#x2F;ctontab这个配置文件针对系统的任务。 123456789SHELL=/bin/shPATH=/usr/bin:/usr/sbin:/bin:/usr/lib/news/binMAILTO=root # 如果出现错误，或有数据输出，数据作为邮件发给这个账号HOME=/# run-parts01* * * * root run-parts /etc/cron.hourly # 每小时执行一次/etc/cron.hourly里的脚本02 4 * * * root run-parts /etc/cron.daily # 每天执行一次cron.daily文件里的脚本22 4 * * 0 root run-parts /etc/cron.weekly42 4 1 * * root run-parts /etc/cron.monthly crontab使用 crontab -l：查询当前定时事件； crontab -e：编辑一个定时任务； 将打开一个vim编辑器页面，然后使用上面的表达式可以创建任务； crontab -e 编辑一个定时任务； 1[root@localhost tmp]# crontab -e 1*/1 * * * * echo &quot;qqqqq&quot; &gt; /tmp/q.txt 查看当前定时任务 12[root@localhost tmp]# crontab -l*/1 * * * * echo &quot;qqqqq&quot; &gt; /tmp/q.txt 删除定时任务 1[root@localhost tmp]# crontab -r","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://zswh33.github.io/tags/Linux/"}]},{"title":"openEuler 5 文件系统 磁盘 磁盘分区 LVM","slug":"openEuler-5","date":"2022-11-27T15:01:14.000Z","updated":"2022-11-28T09:46:55.281Z","comments":true,"path":"2022/11/27/openEuler-5/","link":"","permalink":"http://zswh33.github.io/2022/11/27/openEuler-5/","excerpt":"","text":"文件系统概述文件系统是操作系统用于明确存储设备或分区上的文件的方法和数据结构； 即：存储设备上组织文件的方法。 操作系统中负责管理和存储文件信息的软件机构称为文件管理系统，简称文件系统； 文件系统： 文件系统API； 提供用户人性化接口； 对象操纵和管理的软件集合： 磁盘管理软件，类似于中间件； 对象及属性； 底层存储硬件，如磁盘或分区； 文件系统类型 FAT:包括FAT16，FAT32； NTFS：NTFS是一个基于安全性的文件系统，是Windows NT所采用的文件系统结构； NFS：网络文件系统，用于在UNIX系统间通过网络进行文件共享； RAW：磁盘未经处理或未格式化产生的文件系统； Ext：GNU&#x2F;Linux中标准的文件系统，包括Ext2，Ext3，Ext4； XFS：高性能的日志文件系统； openEuler的文件系统openEuler内核源于Linux； Linux内核支持多种不同类型的文件系统。 openEuler默认文件系统为ext4； 常用文件系统 说明 Ext 专门为Linux设计的文件系统，目前最新版本为ext4 XFS 一种高性能的日志文件系统。 vfat vfat是Linux对DOS，Windows下的FAT文件系统的统称 NFS 网络文件系统，用于在UNIX系统间通过网络进行文件共享 ISO 9660 光盘使用的标准文件系统 SWAP交换分区 Linux系统交换空间（swap）就是磁盘上的一块区域； 可以是一个分区，也可以是一个文件； 物理内存和交换空间的和就是系统可提供的虚拟内存的总量； swap分区作用： 增加系统可用内存空间：当物理内存不足，增加swap分区比增加物理内存更经济； 提高系统整体性能：将不常用数据移到swap分区后，系统会有更多内存用于缓存，增加系统I&#x2F;O； 有些Linux系统休眠功能依赖于swap功能；系统休眠时，会将内存数据保存到swap分区，下次启动时再加载到内存； 配置 swap有两种形式：分区和文件； 创建swap分区：fdisk创建分区，mksswap创建swap分区，swapon启用swap分区； 创建swap文件：创建文件，mkswap格式化文件，swapon启用swap文件。 推荐swap大小 RAM大小 推荐交换分区 &lt;=2GB RAM x 2 2GB - 8GB = RAM &gt;8GB 8GB 磁盘类型 磁盘材质：机械硬盘HDD，固态硬盘SSD； 接口类型：IDE、SCSI、SATA、SAS、FC； 两大协议指令和硬盘接口 两大协议指令：ATA和SCSI； ATA 并行：IDE 最初的硬盘通用标准； IDE属于Parallel-ATA，即并行ATA； 串行：SATA SATA将IDE和ATA区分开来； 一般来说，IDE称为并口，SATA称为串口； 个人电脑和低端服务器常见硬盘； SCSI 并行：SCSI SCSI（Small Computer System Interface）：小型计算机系统专用接口 串行：SAS SAS（Serial Attached SCSI）：就是串口的SCSI接口； 一般服务器采用这两种接口，比开始介绍的两种硬盘性能更高，稳定性更强，支持热插拔； 但是价格高，容量小，噪音大； 其他接口 近线SAS：NL-SAS（新产品） 介于SATA盘与SAS盘之间 有SATA盘的容量和SAS盘的协议组合而成； FC（FibreChannel） 使用光纤通道直接作为硬盘连接接口，为高吞吐量性能密集型系统设备开辟了一条提高I&#x2F;O性能水平途经； 目前高端存储产品使用FC接口硬盘； 查看磁盘信息fdisk -l查看所有磁盘的信息，包括已挂载和未挂载的磁盘； 123456789101112131415161718192021222324[root@localhost ~]# fdisk -lDisk /dev/sda：16 GiB，17179869184 字节，33554432 个扇区磁盘型号：VMware Virtual S单元：扇区 / 1 * 512 = 512 字节扇区大小(逻辑/物理)：512 字节 / 512 字节I/O 大小(最小/最佳)：512 字节 / 512 字节磁盘标签类型：dos磁盘标识符：0xde401923设备 启动 起点 末尾 扇区 大小 Id 类型/dev/sda1 * 2048 2099199 2097152 1G 83 Linux/dev/sda2 2099200 33554431 31455232 15G 8e Linux LVMDisk /dev/mapper/openeuler-root：13.2 GiB，14176747520 字节，27688960 个扇区单元：扇区 / 1 * 512 = 512 字节扇区大小(逻辑/物理)：512 字节 / 512 字节I/O 大小(最小/最佳)：512 字节 / 512 字节Disk /dev/mapper/openeuler-swap：1.79 GiB，1925185536 字节，3760128 个扇区单元：扇区 / 1 * 512 = 512 字节扇区大小(逻辑/物理)：512 字节 / 512 字节I/O 大小(最小/最佳)：512 字节 / 512 字节 df -h查看系统挂载、磁盘空间大小和利用率； 12345678910[root@localhost ~]# df -h文件系统 容量 已用 可用 已用% 挂载点devtmpfs 4.0M 0 4.0M 0% /devtmpfs 715M 24K 715M 1% /dev/shmtmpfs 286M 16M 271M 6% /runtmpfs 4.0M 0 4.0M 0% /sys/fs/cgroup/dev/mapper/openeuler-root 13G 3.7G 8.6G 30% /tmpfs 715M 8.0K 715M 1% /tmp/dev/sda1 974M 175M 733M 20% /boot/dev/sr0 3.5G 3.5G 0 100% /mnt/cdrom 磁盘分区简述 磁盘分区可以将硬盘驱动器划分为多个逻辑存储单元，这些单元称为分区； 通过将磁盘划分为多个分区，系统管理员可以使用不同的分区执行不同的功能； 好处： 限制应用或用户可用空间； 允许同一磁盘进行不同操作系统和多重启动； 将操作系统和程序文件与用户文件分隔； 创建用于操作系统虚拟内存交换的单独分区； 限制磁盘空间使用情况，以提高诊断工具和备份映像的性能； 分区类型 通常所说的“磁盘分区”就是指修改磁盘分区表 一个硬盘只有一个扩展分区，除去主分区，其他空间都分配给扩展分区。 MBR分区表格式Master Boot Record 扇区大小为512字节，第一个扇区要放两个东西：MBR和分区表 MBR：可以安装开机启动的程序，大小为446个字节 分区表：记录分区信息，大小为64个字节，只能记录4个分区的信息，分别对应：三个主分区和一个扩展分区 若分区数量不足，就要在扩展分区上建立逻辑分区； 逻辑分区表放在扩展分区上。 分区命名规则在Linux中，没有盘符的概念，通过设备名来访问设备，设备名存放在&#x2F;dev目录中； 命名规则如下： &#x2F;dev&#x2F;XXYN XX：代表设备类型，通常是 hd（IDE磁盘）； sd（SCSI磁盘）； fd（软驱）； vd（virtio磁盘）； y：代表分区所在的设备，如： /dev/hda表示第一个IDE磁盘； /dev/sdb表示第二个SCSI磁盘； 序号用a,b,c…来标识 N：代表分区 前四个分区（主分区和逻辑分区）用数字1-4； 逻辑分区从5开始 如：**&#x2F;dev&#x2F;hda3**就是第一个IDE磁盘上第三个主分区或扩展分区； &#x2F;dev&#x2F;sdb6就是第二个SCSI硬盘上的第二个逻辑分区 如果创建了一个主分区，然后就创建逻辑分区，逻辑分区照样从5开始，而不是2； 注意：Linux中，SSD、SAS、SATA类型硬盘，都使用sd来标识，IDE硬盘属于IDE接口类型硬盘，用hd来标识。 磁盘分区方案MBRMBR分区方案 主启动记录（Master Boot Record）分区方案指定了在运行BIOS固件的系统上应如何对磁盘进行分区，它是存在于驱动器开始部分的一个特殊启动扇区。 在MBR中， SCSI接口硬盘最多只能有15个分区（扩展分区不计入其中，逻辑分区计入） 其中主分区最多4个，逻辑分区最多12个； IDE接口硬盘最多只能有63个分区，其中主分区最多4个，逻辑分区最多60个； 由于分区大小数据以32位值存储，使用MBR方案分区时，最大磁盘和分区大小限制为2TB。 磁盘分区方案GPT随着硬盘驱动器容量不断增长，老旧的MBR分区方案的2TB磁盘和分区大小限制已不再是理论上的限制，在生产环境中已成为经常遇到的实际问题 GPT正在取代传统的MBR方案进行磁盘分区； GPT意为GUID分区表，驱动器上的每个分区都有一个全局唯一的标识符（globally unique identifier，GUID），对于运行统一可扩展固件接口（UEFI）固件的系统，GPT是在物理硬盘上布置分区表的标准 没有主分区和逻辑分区的区别； 每个硬盘最多可以有128个分区，GPT为逻辑块地址分配64位，因此最大支持18EB的分区大小。 LBALBA：Logical Block Address GPT上所有的磁盘所有区域都是以LBA来规划的。 在GPT上， LBA分区有前面34个，LBA0-LBA33，用于存储GPT分区表信息； 后面有33个，LBA^-1^-LBA^-33^；用于备份分区表信息。 LBA0是GPT分区上第一个LBA块，LBA0又称为Prorective MBR，MBR相容区块，用来兼容MBR分区； LBA1叫做GPT表头记录，记录分区表本身的位置和大小，同时记录备份用的GPT分位置； LBA2-LBA33：记录实际的分区信息； 每个LBA划分为4块，即每个LBA可以记录4个分区表； 所以，一个GPT可以建立128个分区表（32x4=128）； fdisk使用fdisk是Linux硬盘分区工具，也是Linux系统常用的一种硬盘分区工具之一，但不支持大于2TB的分区； 语法：fdisk [OPTION] 参数 选项： -b &lt;分区大小&gt;：指定每个分区的大小； -l：列出指定外围设备的分区表状况； -u：搭配-l参数列表，会用分区数目取代柱面数目，来标识每个分区的起始地址； -s &lt;分区编号&gt;：打印指定的分区大小，单位为区块； -v：显示版本信息。 fdisk交互模式 帮助 a 设置可引导标记 b 编辑bsd磁盘标签 c 设置DOS操作系统兼容标记 d 删除一个分区 l 显示已知文件系统类型， 82为swap分区，83为linux分区； m 显示帮助菜单 n 新建分区 o 建立空白DOS分区表 p 显示分区列表 s 新建空白SUN磁盘标签； t 改变一个分区的系统ID u 改变显示记录的单位 v 验证分区表 q 不保存退出 w 保存退出 建立主分区 n 新建一个分区 p 选择主分区 主分区号（1-4） 回车，默认起始柱面1 定义分区大小 &#x2F;直接+size w 保存退出 p 打印分区信息 parted分区工具parted也是Linux下常用的分区软件，支持创建2T以上的磁盘分区，相对于fdisk，parted更方便； 提供动态调整分区大小的功能； 语法：parted [options] [device [command [options …]…]] 选项： -i：交互模式 -s：脚本模式； device：磁盘设备名称，如&#x2F;dev&#x2F;sda； command：parted命令，如果没有这个，parted会进入交互模式； -v：显示parted版本信息； -h：显示帮助信息； 交互模式选择具体硬盘后，进入交互模式进行分区操作，如：parted &#x2F;dev&#x2F;sdb 说明 align-check：检查分区N的类型（min|opt）是否对齐； mklabel：创建新的磁盘标签（分区表）； name：给指定分区命名； print：打印分区表； rescue：修复丢失的法内情； resizepart：调整分区大小 rm：删除分区 select：选择要编辑的设备； disk_set：更改选定设备上的标志； disk_toggle：切换选定设备上的标志状态； quit：退出； set：更改分区的标记 toggle：设置或去标分区的标记； unit：设置默认单位； version：显示版本信息。 分区流程 mktable gpt ：创建GPT分区表； mkpart，新建分区； q，保存并退出。 非交互模式 硬盘格式改为GPT格式：parted &#x2F;dev&#x2F;sdb mklabel gpt 分区：parted &#x2F;dev&#x2F;sdb mkpart primary 0 1000； 格式化：mkfs -t ext4 &#x2F;dev&#x2F;sdb1 格式化格式化是对硬盘或磁盘分区进行初始化的一种操作，将分区格式化成不同文件系统； 先mkfs 然后tab，查看支持的文件系统类型； mkfs.ext4 &#x2F;dev&#x2F;sdb2 格式化sdb2分区为ext4类型； ll &#x2F;dev&#x2F;sdb2：查看磁盘信息； 格式化mkfsmkfs，make filesystem； 用来在特定分区上建立Linux文件系统； 语法：mkfs [-V] [-t fstype] [fs-options] filesys [blocks] 选项： device，预备检查的磁盘分区； -V：打印详细信息； -t：给定文件系统的格式 -c：在格式化前，检查partition中是否存在坏道； -l 将坏道的block的信息输出到bad_blocks_file文件里； block，给定block的大小； 磁盘挂载挂载点目录：根目录下media和mnt两个目录被叫做挂载点目录； 临时挂载：使用mount /dev/sda5 /test 表示将/dev/sda5挂载到test目录中，重启后失效； 永久挂载：即开机自动挂载，编辑/etc/fstab文件进行操作； fstab文件/etc/fstab 用来存放文件系统的静态信息的文件； 系统启动时，会自动从这个文件读取信息，并自动酱紫文件中指定文件系统挂载到指定的目录，这样只需要将磁盘的挂载信息写入这个文件中就不需要每次开机启动之后手动挂载了； 文件格式 123456789&lt;file system&gt; &lt;dir&gt; &lt;type&gt; &lt;options&gt; &lt;dump&gt; &lt;pass&gt;/dev/sda1 / ext4 defaults,noatime 0 1# file system 分区名称 可以用路径/dev/sda1，也可以用UUID# dir 挂载目录# type 文件系统类型# options # dump 自带备份工具，目前已经不用了# pass 检测 一些参数 options auto：启动后使用mount -a时自动挂载； ro：只读方式挂载文件系统； rw：读写模式挂载文件系统； user：允许任意用户挂载文件系统； nouser：只能被root挂载； dev&#x2F;nodev： 解析&#x2F;不解析文件系统上的块特殊设备； noatime&#x2F;nodiratime：不更新文件系统上&#x2F;目录上inode访问记录，可以提升性能； defaults：使用文件系统的默认挂载参数 sync&#x2F;async： I&#x2F;O同步&#x2F;异步进行； suid&#x2F;nosuid： 允许&#x2F;允许suid 操作和设定sgid位，参数通常用于一些特殊任务，使一般用户运行程序时临时提升权限； dump 0表示忽略，1表示进行备份，大部分用户没有安装dump，对于他们而言dump应为0； pass 0,1,2。 1，检查最高优先权，一般用在根目录； 2，其他所有需要被检查的设备，优先级低于1； 0，不会进行fsck检查； 逻辑卷管理概念LVM-逻辑卷管理是Linux对磁盘分区进行管理的一种机制，是建立在硬盘和分区之上，文件系统之下的一个逻辑层，可提高磁盘分区管理的灵活性； 物理单元PE：Physical Extents，具有唯一编号的PE是能被LVM寻址的最小单元； PE的大小可以指定，默认为4MB； PE大小一旦确定不能改变； 同一卷组的所有物理卷的PE大小是一致的； 逻辑单元LE：Logical Extents，逻辑卷中可用于分配的最小存储单元，逻辑区域大小取决于逻辑卷所在卷组中物理区域的大小；在同一个卷组中，LE大小与PE相同，且一一对应； 物理卷PV，Physical Volume，底层真正提供容量，存放数据的设备，可以是整个硬盘，硬盘上的分区等； 卷组VG：Volume Group，建立在物理卷之上，由一个或多个物理卷组成，即把物理卷整合起来提供容量分配； 一个LVM系统可以有一个或多个卷组； 逻辑卷LV：Logical Volume，逻辑卷建立在卷组之上，是从卷组中“切出”的一块空间，是最终用户使用的逻辑设备，逻辑卷创建之后，其大小可以伸缩。 逻辑卷优点 灵活的容量 可伸缩的存储池； 在线的数据再分配 方便设备命名； 磁盘条带化 卷镜像和卷快照 逻辑卷创建流程 物理磁盘层：fdisk格式化； 物理分区层：使用pvcreate转换为物理卷； 物理卷层PV：使用vgcreate创建卷组； 卷组层VG：使用lvcreate创建逻辑卷； 逻辑卷层LV，格式化。 PVpvcreate创建物理卷，可以使用物理磁盘或磁盘分区创建； 语法：pvcreate [OPTION] 设备文件名 -f，强制创建物理卷，无需用户确认； -u，指定设备的UUID； -y，所有问题回答yes； 需要将分区改为LVM分区才能创建物理卷； 使用分区创建时，磁盘分区后id为83，需要将id改为8e，才能创建物理卷，用fdisk修改id； 使用 将磁盘hda的6-9分区创建为pv； 1pvcreate /dev/hda&#123;6,7,8,9&#125; 查看物理卷信息 123[root@localhost ~]# pvs PV VG Fmt Attr PSize PFree /dev/sda2 openeuler lvm2 a-- &lt;15.00g 0 VGvgcreate创建LVM卷组；卷组将多个物理卷组织成一个整体，屏蔽了底层物理卷细节； 语法：vgcreate [OPTION] 卷组名 物理卷列表 选项： -l：卷组上允许创建的最大逻辑卷数； -p：卷组上允许添加的最大物理卷数； -s：卷组上的物理卷的PE的大小； 参数： 卷组名，创建卷组的名称； 物理卷列表，要加入到的卷组中的物理卷列表； 使用 使用vgcreate命令创建卷组“VG1000”，并将物理卷/dev/sdb1和/dev/sdb2添加到卷组中； 1[root@localhost ~]# vgcreate vg1000 /dev/sdb1 /dev/sdb2 查看卷组信息，使用vgdisplay、vgscan； 123[root@localhost ~]# vgs VG #PV #LV #SN Attr VSize VFree openeuler 1 2 0 wz--n- &lt;15.00g 0 lvlv用于创建LVM逻辑卷，逻辑卷创建在卷组之上； 语法：lvcreate [OPTION] 逻辑卷名称 选项： -L：指定逻辑卷的大小，单位“kKmMgGtT”字节； -l：指定逻辑卷的大小（LE数）； 参数： 逻辑卷：指定要创建的逻辑卷名称； 注意：逻辑卷创建完成后，需要格式化，挂载后才能使用。 使用创建逻辑卷 1[root@localhost ~]# vgcreate -L 200M vg1000 使用lvdisplay、lvscan查看卷组信息 1234567[root@localhost ~]# lvs LV VG Attr LSize Pool Origin Data% Meta% Move Log Cpy%Sync Convert root openeuler -wi-ao---- 13.20g swap openeuler -wi-ao---- 1.79g[root@localhost ~]# lvscan ACTIVE &#x27;/dev/openeuler/swap&#x27; [1.79 GiB] inherit ACTIVE &#x27;/dev/openeuler/root&#x27; [13.20 GiB] inherit 逻辑卷调整基本步骤扩容 扩容前先确认是否有足够的vg空间：vgs 使用命令扩容：lvextend -L +SIZE lv_device 12345678[root@localhost ~]# lvextend -L +2G /dev/vg1/lv1 Size of logical volume vg1/lv1 changed from 2.00 GiB (512 extents) to 4.00 GiB (1024 extents). Logical volume vg1/lv1 successfully resized.[root@localhost ~]# lvs LV VG Attr LSize Pool Origin Data% Meta% Move Log Cpy%Sync Convert root openeuler -wi-ao---- 13.20g swap openeuler -wi-ao---- 1.79g lv1 vg1 -wi-ao---- 4.00g 调整文件系统的大小：resize2fs LV_DEVICE 123456[root@localhost ~]# resize2fs /dev/vg1/lv1resize2fs 1.46.4 (18-Aug-2021)/dev/vg1/lv1 上的文件系统已被挂载于 /mnt/lv1；需要进行在线调整大小old_desc_blocks = 1, new_desc_blocks = 1/dev/vg1/lv1 上的文件系统现在为 1048576 个块（每块 4k）。 注意：不需要卸载，在线扩容。 缩容 先确定缩减后目标大小，并确保目标逻辑卷大小有足够的的空间容纳原有数据； 卸载文件系统：umount，并执行强制检测：e2fsck -f； 12345678[root@localhost ~]# e2fsck -f /dev/vg1/lv1e2fsck 1.46.4 (18-Aug-2021)第 1 步：检查inode、块和大小第 2 步：检查目录结构第 3 步：检查目录连接性第 4 步：检查引用计数第 5 步：检查组概要信息/dev/vg1/lv1：11/262144 文件（0.0% 为非连续的）， 34894/1048576 块 缩减文件系统：resize2fs DEVICE； 1234[root@localhost ~]# resize2fs /dev/vg1/lv1 1Gresize2fs 1.46.4 (18-Aug-2021)将 /dev/vg1/lv1 上的文件系统调整为 262144 个块（每块 4k）。/dev/vg1/lv1 上的文件系统现在为 262144 个块（每块 4k）。 缩减逻辑卷：lvreduce； 12345[root@localhost ~]# lvchange -a n /dev/vg1/lv1 # 先将逻辑改为不活跃[root@localhost ~]# lvreduce -L 1G /dev/vg1/lv1 # 然后缩减lv Size of logical volume vg1/lv1 changed from 4.00 GiB (1024 extents) to 1.00 GiB (256 extents). Logical volume vg1/lv1 successfully resized.[root@localhost ~]# lvchange -a y /dev/vg1/lv1 # 再将lv改为活跃 重新挂载使用。 逻辑卷容量变更lvresizelvresize指令用于调整逻辑卷空间大小，可以增大空间和缩小空间，实际包含了lvextend和lvreduce的功能； 语法：lvresize [OPTION] 逻辑卷名称； 选项： -L：指定逻辑卷的大小，单位”kKmMgGtT“； -l：指定逻辑卷大小（LE数）； 参数 逻辑卷：指定要创建的逻辑卷名称； 使用将逻辑卷空间增加200M 1[root@localhost ~]# lvresize -L +200M /dev/vg1000/lvol0","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://zswh33.github.io/tags/Linux/"}]},{"title":"openEuler 4 源代码软件安装 systemd","slug":"openEuler-4","date":"2022-11-26T10:42:19.000Z","updated":"2022-11-27T15:00:46.361Z","comments":true,"path":"2022/11/26/openEuler-4/","link":"","permalink":"http://zswh33.github.io/2022/11/26/openEuler-4/","excerpt":"","text":"源代码软件安装源代码软件Linux安装软件除了用rpm，还可以使用源代码软件安装； Linux下许多软件通过源代码包发行，源代码包移植性较好，不同用户可以编译并运行； 包管理软件优先使用软件包安装，但也会出现需要源代码安装的场景： 软件包版本太旧； 没有现成软件包可用； 软件包缺乏某些特性； 编译参数不适用当前业务 或 可通过优化编译参数提高性能； 优缺点 优点： 编译过程可用指定参数，灵活性好； 经过本机比阿尼，使得软件与本机兼容性最好。 缺点： 配置及编译过程繁琐； 可用由于一些问题导致没有依赖包； 如何进行源代码安装configure、make、make install 基本步骤 下载源码并解压； 查看README和INSTALL文件 这些文件记录了软件的安装方法和注意事项； 创建Makefile文件 执行.&#x2F;configure脚本命令生成； 编译 通过make命令将源码自动编译成二进制文件； 安装软件 make install将二进制文件安装到对应目录中。 目录默认为：/usr/local 配置文件位置为：/usr/local/etc/或/usr/local/**/etc Systemdd，deamon，守护进程 在Linux中，systemd是与SysV和LSB初始化脚本兼容的系统和服务管理器，开启systemd服务可以提供基于守护进程的按需启动策略； 支持快照和系统状态恢复，维护系统挂载和自挂载点，使得各服务之间基于从属关系实现更为精细的逻辑控制，具有更高的并行性能； unitsystemd服务的开启和监督系统基于unit的概念； unit由一个与配置文件对应的名称和类型组成，unit通常有以下几种类型： unit，单元：让系统直到如何进行操作和管理的资源。 Service unit：系统服务； Target unit：一组systemd units； Automount unit：文件系统挂载点； Device unit：内核识别的设备文件； Mount unit：文件系统挂载点； Path unit：在一个文件系统中的文件或目录； Scope unit：外部创建的进程； Snapshot unit：systemd manager的保存状态。 特性： 更快的启动速度； 提供按需启动能力； 采用cgroup特性追踪和管理进程生命周期； 启动挂载点和自动挂载的管理； 实现事务性依赖关系管理； 与SysV初始化脚本兼容； 能够对系统进行快照和恢复。 如何使用systemdsystemd使用systemctl命令来对系统服务进行运行、关闭、重启、状态打印、启用和禁用的操作； systemctl与sysvinit（service）命令功能相似，建议用systemctl来进行系统服务管理； 查看当前正在运行的服务：systemctl list-units --type service； 若加上 --all 参数，则列出所有的服务； 查看特定服务的状态：systemctl status NAME.service [root@localhost node-v18.12.1]# systemctl status firewalld ● firewalld.service - firewalld - dynamic firewall daemon Loaded: loaded (/usr/lib/systemd/system/firewalld.service; enabled; vendor&gt; Active: active (running) since Mon 2022-10-24 02:38:05 CST; 22h ago Docs: man:firewalld(1) Main PID: 829 (firewalld) Tasks: 2 (limit: 8932) Memory: 26.8M CGroup: /system.slice/firewalld.service └─829 /usr/bin/python3 -s /usr/sbin/firewalld --nofork --nopid 结果参数： Loaded：服务是否被加载，并显示对应的绝对路径是否启用； Active：服务是否正在运行，并显示时间节点； Main PID：服务的PID值； CGroup：相关控制组的其他信息 运行服务：systemctl start NAME.service 关闭服务：systemctl stop NAME.service 重启服务：systemctl restart NAME.service 启用服务（开机启动）：systemctl enable NAME.service 禁用服务（开机不启动）：systemctl disable NAME.service 其他操作 关闭系统：systemctl poweroff 重启系统：systemctl reboot 系统待机：systemctl suspend 系统休眠：systemctl hibernate 系统待机并休眠：systemctl hybrid-sleep","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://zswh33.github.io/tags/Linux/"}]},{"title":"OpenEuler 3 文件权限设置 文件属主设置 umask DNF软件包管理","slug":"OpenEuler-3","date":"2022-11-26T07:47:27.000Z","updated":"2022-11-27T12:52:49.033Z","comments":true,"path":"2022/11/26/OpenEuler-3/","link":"","permalink":"http://zswh33.github.io/2022/11/26/OpenEuler-3/","excerpt":"","text":"常用的权限设置命令chmod：修改文件权限，使用权限：文件所有者； chown：修改文件主属组，使用权限：管理员； chgrp：修改文件属组，使用权限：管理员； umask：遮罩码，使用权限：管理员、普通用户。 chmod文件调用权限针对文件所有者、所属组和其他人； 语法：chmod [OPTION]… MODE[,MODE]… FILE… 选项： 操作对象 u，表示用户，文件的所有者 g，表示用户组，表示文件或目录所属组； o，其他用户； a，所有用户； 操作符 +，添加权限； -，减少权限； &#x3D;，给定特定权限； 赋予的权限 r，读权限； w，写权限； x，执行权限； 根据配置场景，可以同时修改文件的一组权限，也可以只修改文件的某个权限； 如： chmod u+r FILE，表示给予文件所有者的读权限； chmod g-w FILE，删除文件所属组的写权限 chmod ug-x FILE，删除文件所有者和文件所属组的执行权限； chmod 777 FILE，为所有操作对象赋予所有权限； 数字： 4：读 2：写 1：执行 chownchown可以修改文件的所有者，可以改为指定用户或组； 语法：chown [OPTION]... [OWNER][:[GROUP]] FILE... 选项： -c：显示更改的部分的信息； -f：忽略错误信息； -h：修改符号链接； -v：显示详细的处理信息； -R：处理指定目录以及其子目录下所有文件； 根据配置场景，可以只修改属主，也可以只修改属组，也可同时修改属主和属组； 修改属主：chown OWNER； 修改属组：chwon :GROUP； 同时修改：chwon OWNER:GROUP； chgrp修改文件或目录的所属组； 语法：chgrp [OPTION]… GROUP FILE… 选项： -c：显示修改的部分； -v：显示详细修改过程； -f：不显示错误信息； -h：只修改符号连接的文件，不修改其他任何文件； -R：递归，修改目录下所有文件和子目录； 使用chgrp修改属组与chown修改属组是一样的，不同的是，chgrp不需要“:”； umask 预设权限掩码指定在建立文件或目录时进行权限掩码的预设； 修改在建立文件或目录时使用的默认权限的掩码。 掩码可以同时表示”文件夹“和”文件“的权限。 语法：umask [OPTION] [mode] 选项： -p，显示命令名称； -S，以文字形式查看当前文件权限掩码； umask计算 文件夹默认权限：777 - 权限掩码； 文件默认权限：777 - 权限掩码 - 111； 常见umask值与之对应的文件或目录权限： umask值 文件权限 目录权限 022 644 755 027 640 750 002 664 775 006 660 771 007 660 770 sudo 权限赋予sudo允许普通用户执行root用户可以执行的任务； 语法：sudo [OPTION] 选项： -k，使用者下次执行需询问密码； -l，打印使用者权限； -L，打印sudos设置； -V，打印版本编号； 在openEuler系统中， 不能使用su切换root用户， su只能用来：让root用户能切换其他用户。 RPM软件包管理RPM是一种用于互联网下载包打包和软件包自动安装工具； 可以生成RPM后缀文件作为软件包文件； 可以用来管理应用程序的安装、卸载和维护； rpm，全名red-hat package manager红帽包管理器； RPM软件包命名格式name-version-release.arch.rpm 软件名称-版本号-发行版号.处理器架构.rpm 版本号 格式：x.y.z x：主版本号 y：次版本号，代表软件功能的增加； z：修正版本号，代表修正bug； release 也可代表是第几次编译产生的； arch 常见平台：i386，i586，i686等； 有时候为noarch，表示软件包可以在任何平台安装； rpm 软件包后缀，表示可以用rpm安装； 有时候为“.src.rpm”表示这是一个源代码包； 优缺点优点： 简单便捷，兼容版本； 参数信息记录在数据库中，便于查询、升级或卸载软件； 缺点： 安装环境需与打包环境一致； 具有很强的依赖关系，卸载软件时需要对依赖性软件优先处理，否则会导致其他软件无法正常使用； RPM命令RPM一般用来安装、删除、升级、刷新和查询； 语法：rpm [OPTION…] 选项： -i，指定安装的软件包； -v，显示详细安装过程，显示安装过程中正在安装的软件信息； -h，使用“#”符号显示rpm软件安装过程及进度； -U 或 -F，升级指定软件包； -U，若存在旧包，删除旧包并安装新包； -F，若存在旧包，则在旧包的基础上进行升级； -e，卸载软件； -nodeps，不考虑依赖问题，强制卸载。（不建议使用）； -allmatches，若软件包存在多个版本，则使用这个命令进行批量卸载； -q，查询系统是否已安装指定软件包或查询指定rpm包内容信息； -qa，查询所有安装的软件包，可以不给出文件参数； 下面所有需要给出文件名参数 -qf，查询所有已安装过（包括被删除的）的软件包； -qp，查询未安装的软件包； -ql，查询软件包中的文件列表和完整目录； -qi，查询软件包详细信息； -qc，查询软件包的配置文件； -qd，查询软件包帮助文档； -a，查看系统已安装的所有软件包； -V，查询已安装软件包版本信息； -c，显示所有配置文件； -p，查询&#x2F;校验一个软件包的文件； 使用示例 安装软件 1[root@localhost ~]# rpm -ivh mysql-community-server-8.0.31-1.el7.x86_64.rpm 卸载软件 1[root@localhost ~]# rpm -e mysql-community-server 更新软件 12345678[root@localhost ~]# rpm -U mysql# 更新，先卸载旧的，再安装新的[root@localhost ~]# rpm -Uvh mysql# 更新并展示 详细信息和进度条[root@localhost ~]# rpm -F mysql# 更新，在旧的基础上升级新的[root@localhost ~]# rpm -Fvh mysql# 更新并展示 详细信息和进度条 查询 查询软件安装 1234[root@localhost ~]# rpm -q mysql# 查软件包是否安装[root@localhost ~]# rpm -qa# 查询所有安装的软件包 查询软件包文件 123456[root@localhost ~]# rpm -ql nano/etc/ima/digest_lists.tlv/0-metadata_list-compact_tlv-nano-4.9.3-2.oe2209.x86_64/etc/ima/digest_lists/0-metadata_list-compact-nano-4.9.3-2.oe2209.x86_64/usr/bin/nano/usr/bin/rnano... 查询软件包信息 12345678910111213141516171819[root@localhost ~]# rpm -qi nanoName : nanoVersion : 4.9.3Release : 2.oe2209Architecture: x86_64Install Date: 2022年10月24日 星期一 01时32分28秒Group : UnspecifiedSize : 2088365License : GPLv3+Signature : RSA/SHA1, 2022年09月28日 星期三 14时49分19秒, Key ID d557065eb25e7f66Source RPM : nano-4.9.3-2.oe2209.src.rpmBuild Date : 2021年08月02日 星期一 08时00分00秒Build Host : ecs-obsworker-205Packager : http://openeuler.orgVendor : http://openeuler.orgURL : https://www.nano-editor.orgSummary : Nano is a tiny GNU editorDescription :Nano is a tiny GNU editor DNF软件包管理介绍 DNF的上一届：yum包管理 yum，全称：Yellodog Updater modified yum是历史的产物，是光荣的牺牲者。 软件管理工具yum基于rpm包管理； 可以从指定服务器自动下载rpm服务器并安装； 可以解决软件包间依赖关系，提升效率。 由于yum工具有性能差、内存占用多、依赖解析速度慢、源文件依赖性较高等问题； 对于这种情况，DNF工具诞生； DNF管理工具解决了一些yum工具的问题，并在各个方面得到了提升。 DNF工具简述 DNF，Dandified YUM，即修饰过的YUM； DNF可以查询软件包的信息，从指定软件库去获取软件包，并可以自动处理依赖关系，实现安装、卸载和更新； DNF与yum完全兼容，可以使用yum命令行使用DNF工具； 使用需要root权限。 环节 配置DNF 配置参数 创建本地软件源仓库； 添加、启用或禁用软件源 管理软件包&#x2F;软件包组； 列出软件包&#x2F;软件包组清单； 显示RPM包信息，显示软件包信息； 下载rpm包；安装rpm包；安装软件包组； 删除软件包&#x2F;软件包组； 检查更新 更新所有包及其依赖。 软件源Linux系统免费的应用程序安装仓库； 软件源可以是网络服务器、光盘或硬盘上的一个目录； 配置文件位置：/etc/dnf/dnf/conf； 内容： main部分保存DNF的全局配置； cachedir：缓存目录，存储RPM包和数据库文件； best：升级包时，总是尝试安装其最高版本，若无法安装，则提示无法安装原因并停止安装； installoney_limit：可以同时安装“installonlypkgs”命令列出的包的数量，默认为3； installonlypkgs，指的是手动指定的只能安装，不能升级的软件包； clean_requirements_on_remove：在remove时删除软件时，删除不再使用的依赖项，默认为True。这里只能删除安装其他软件包时，DNF自动安装的软件包； repository允许用户自定义软件仓库。这里要求各个仓库的名称不能相同，用户可以添加一个或多个repository来修改需安装软件源位置； name&#x3D;软件源名称； baseurl，软件仓库的地址，可以使用http、ftp和file等协议； http://path/to/repo ftp://path/to/repo file:&#x2F;&#x2F;&#x2F;path&#x2F;to&#x2F;local&#x2F;repo 软件源管理添加软件源添加软件源有多个方法； 方法1：修改配置文件/etc/dnf/dnf.conf，详细查看上一节最后； 方法2：在&#x2F;etc&#x2F;yum.repos.d&#x2F;目录下添加“.repo”文件； 方法3：使用命令添加软件源： 1dnf config-manager --add-repo repository_url 查询软件源dnf repolist 12345678[root@localhost ~]# dnf repolistrepo id repo nameEPOL EPOLOS OSdebuginfo debuginfoeverything everythingsource sourceupdate update 启用&#x2F;禁用软件源12345# 启用软件源dnf config-manager --set-enable repo_id# 禁用软件源dnf config-manager --set-disable repo_id 创建本地软件源仓库可以创建本地软件源仓库，保存需要的软件包； 下面是创建本地软件源的方法： 安装createrepo 1dnf install createrepo； 将需要的软件包放置在目录下，如:&#x2F;mnt&#x2F;local_repo&#x2F;； 执行命令创建软件源； 1createrepo --database /mnt/local_repo 管理软件包查询软件包 searchdnf search 软件包名 12345[root@localhost ~]# dnf search mysqlLast metadata expiration check: 2:04:39 ago on 2022年10月24日 星期一 14时00分16秒.========================= Name &amp; Summary Matched: mysql ==========================mysql.x86_64 : MySQL client programs and shared librariesmysql.src : MySQL client programs and shared libraries 列出已安装&#x2F;可用软件包 list列出所有可用软件包 1dnf list all 查看指定软件包 123456[root@localhost ~]# dnf list mysqlLast metadata expiration check: 2:07:14 ago on 2022年10月24日 星期一 14时00分16秒.Available Packagesmysql.src 8.0.29-1.oe2209 sourcemysql.x86_64 8.0.29-1.oe2209 OSmysql.x86_64 8.0.29-1.oe2209 everything 其他查询 12dnf list installed # 列出已安装的包dnf list available # 列出可用包 查询软件包信息 infodnf info 软件包名 12345678910[root@localhost ~]# dnf info mysqlLast metadata expiration check: 2:09:03 ago on 2022年10月24日 星期一 14时00分16秒.Available PackagesName : mysqlVersion : 8.0.29Release : 1.oe2209Architecture : srcSize : 620 MSource : None... 下载download、安装install、删除remove123456# 下载mysql[root@localhost ~]# dnf download mysql# 安装mysql，若mysql不存在，则下载并安装mysql[root@localhost ~]# dnf install mysql# 移除mysql[root@localhost ~]# dnf remove mysql 管理软件包组注意，这里groups和group可通用。 查看当前信息：dnf groups summary 列出软件包组和组id：dnf groups list 列出已安装的软件包组信息：dnf groups list --installed -v：列出详细信息； 列出软件包组必装和选装软件包组：dnf groups info 包组名 安装软件包组：dnf group install group_name/group_id 删除软件包组：dnf group remove group_name/group_id 检查并更新检查所有更新：dnf check-update 更新指定软件包：dnf update package_name 更新指定软件包组：dnf group update group_name","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://zswh33.github.io/tags/Linux/"}]},{"title":"openEuler 2 常见文本编辑器 文件摘选 用户管理 用户组管理 文件权限","slug":"openEuler-2","date":"2022-11-25T08:34:35.000Z","updated":"2022-11-26T09:14:10.573Z","comments":true,"path":"2022/11/25/openEuler-2/","link":"","permalink":"http://zswh33.github.io/2022/11/25/openEuler-2/","excerpt":"","text":"Linux常见文本编辑器 emacs nano gedit kedit vi vim 基本模式：普通、插入、可视、选择、命令行、Ex 派生模式：操作符等待模式、插入普通、插入可视、插入选择、替换模式； 其他：Evim vim 移动光标： 上下左右 或 jkhl 向上下左右移动光标； 0 移动到行首； g0 移动到光标所在行行首； home&#x2F;end：跳转到 行首&#x2F;行尾。 :n 移动到第n行； gg：回到文件头部； G：到文件底部； 数据操作： 复制 yy 或 Y：复制整行文本； [n]yy：复制n行文本 y[n]w：复制一{n}个单词； 粘贴（分为：一行数据、一个字段） p：粘贴在当前行下面&#x2F;粘贴在光标后面； P：粘贴在当前行上面&#x2F;粘贴在光标前； 删除 d[n]w：删除（剪切）1{n}个单词； [n]dd：删除（剪切）1{n}行。 查找 :&#x2F;word 在光标之后查找字符串word，按n向后继续搜索，shift+n向上搜索； :?word 在光标之前查找字符串word，按n向后继续搜索； 替换 :1,5s&#x2F;word1&#x2F;word2&#x2F;g，将文档中1-5行word1替换为word2，不加g表示只替换每行第一个word1 %s&#x2F;word1&#x2F;word2&#x2F;gi，将文档所有word1替换为word2，不区分大小写； **&#x2F;表示替换光标后的第一个word，?**表示替换光标前第一个word。 1,5 表示1-5行； %表示所有行； i表示不区分大小写。 撤销和重做 u 撤销最近的改变； U 撤销当前行自从光标定位在上面开始的所有改变； ctrl-r 重做最后一次撤销。 一些命令 set nu：显示行编号； set nonu：隐藏行编号。 set hlsearch： 高亮所有搜索结果 保存文件并退出 在插入模式下按esc退出插入模式 :w 保存 :q 退出 :wq 保存并退出 :q! 强制退出 :wq! 强制保存并退出 查看文件cat cat是一个文本文件查看和链接工具； cat filename，查看文件内容； cat &gt; filename，编辑一个文件； cat file1 file2 &gt; file3，将几个文件合并为一个文件； 一个 &gt; 表示覆盖，两个 &gt;&gt; 表示追加。 常用选项； -n：从1开始对所有行编号并显示在每行开头； -b：对非空行编号； -s：当有多个空行，则只输出一个空行； -E：在每行结尾增加**$**； –help：显示帮助信息； more选项： +n，从第n行开始显示； -n，定义屏幕大小为n行； -c，从顶部清屏，然后显示； -s，把连续的多个空行显示为一行。 操作 Enter：向下滚动一行； Ctrl+F：下一页； 空格：下一页； Ctrl+B：上一页； b：上一页； &#x3D;：输出当前行号； q：退出 less格式：less [option] 文件； -f：强制打开特殊文件，如外围设备代号，目录和二进制文件； -g：只高亮最后搜到的关键字； -i：忽略索索大小写； -N：显示每行行号； -s：当有多个空行在一起时只输出一个空行； -o &lt;文件名&gt;：将less输出的内容保存到指定文件； 操作： /或?：向上或向下搜索字符； b：向上一页 空格 或 f：向下一页 u：向上半页 d：向下半页； y：向上一行； Enter：向下一行； h：帮助页面； q：退出； 文件摘选headhead用来显示文件开头到标准输出； head默认显示前10行； 命令格式：head [option]… [file]… 选项： -q：输出时隐藏文件名，head默认不显示文件名； -v：显示文件名； -c num：显示前num个字节； -n num：显示前num行。 tail显示文件末尾到标准输入，默认为文件后10行； 格式：tail [option]… [file]… 选项： -f：循环读取，对于日志文件的监控有用； -q：不显示文件名，tail默认不显示文件名； -v：显示文件名； -c num：显示文件最后num个字节； -n num：显示文件最后num行； -s：与-f结合使用，表示每次反复的时间间隔休眠s秒； cut提取列或字段； 1cut -d: -f1 /etc/passwd # 显示/etc/passwd文件以:间隔的第一列 格式：cut [option]… [file] 选项： -b：仅显示行中指定直接范围的内容； -c [范围]：仅显示行中指定范围的字符； -d：指定字段的分隔符，默认分隔符为TAB； -f [范围]：显示指定第num个字段的内容，可以用逗号隔开显示多个字段； 范围指定： N：每行第N个字节，字符或字段； N-：每行第N个字节、字符或字段到每行的末尾； -M：每行的第一个字节、字符或字段到每行的第M个； N-M：每行的第N到第M个字节、字符或字段； 用户 Linux是一个多用户的操作系统； 一个系统可以建立多个用户，多个用户可以在同一时间内登录到同一系统执行不同的任务； 每个用户都会分配一个uid。 用户UID UID指的是用户的ID，一个用户UID标识一个给定用户，UID是用户的唯一标识符； 通过UID也可以区分不同用户的类别； 超级用户：也称root，它的UID为0，超级用户拥有系统的完全控制权； 普通用户：也称一般用户，UID在1000-60000之间，普通用户可以对自己目录下文件进行访问，也可对经过授权的文件进行访问； 虚拟用户：也称系统用户，UID为1-999，虚拟用户最大的特点是不提供密码登录系统，存在的目的是方便系统的管理。 通过id命令可以查看不同用户的uid； id [option] [user_name]； id命令会输出：用户的有效ID，用户所在组的ID和用户所在的用户组 有效ID：系统用于区分用户对文件有效权限的UID 真实ID：系统在用户登录系统时对用户进行区分的UID； 通常情况下，有效ID与真实ID相同。 参数： -u，-user，只输出有效的uid； -g，只输出有效的gid -n，-name，对于-ugG选项输出名字而不是数值，需要配合-ugG选项使用； -r，-real，输出真实ID而不是有效id，需要配合-ugG选项使用； 12[root@localhost ~]# id yyn用户id=1000(yyn) 组id=1000(yyn) 组=1000(yyn),10(wheel) 用户管理命令创建用户 useradd创建用户账号，保存在&#x2F;etc&#x2F;passwd文件中； 语法：useradd [options] user_name 这里的用户名对大小写敏感，可以出现数字、字母、下划线和减号（减号不能放在首位）。 -u，指定用户UID； -o，允许UID重复，需要配合-u属性； -g，指明用户所属基本组，这里可以为组名，也可为GID（组必须存在）； -d，指定用户home目录，并自动创建用户home目录； -M，不创建家目录； -s，指明用户的默认shell程序； 默认为&#x2F;bin&#x2F;bash。 另外也可以有&#x2F;usr&#x2F;sbin&#x2F;nologin； -D，显示或更改默认配置。 12345[root@localhost ~]# cat /etc/passwd | tail -n3chrony:x:983:980::/var/lib/chrony:/sbin/nologintcpdump:x:72:72::/:/sbin/nologinyyn:x:1000:1000:yyn:/home/yyn:/bin/bash用户名:密码:UID:GID:描述信息:家目录:默认Shell 修改用户 usermod修改用户账号的各类信息。 语法：usermod [options] user_name -u，修改用户UID； -g，修改用户所属用户组； -l，修改用户账号名称； -L，锁定指定用户，让其无法登录； -d，修改用户home目录； -s，修改用户默认shell程序； 123[root@localhost ~]# usermod -u 1003 yyn[root@localhost ~]# id yyn用户id=1003(yyn) 组id=1000(yyn) 组=1000(yyn),10(wheel) 删除用户 userdel删除指定的用户以及该用户相关的文件； 默认只删除用户，不删除用户相关文件。 语法：userdel [options] user_name -f，强制删除用户账号，即使用户当前处于登录状态； -r，删除用户，同时删除与用户相关的所有文件； -h，显示命令帮助信息； 修改密码 passwdpasswd修改用户密码。 语法：passwd [OPTION…] user_name -n，设置修改密码最短天数； -x，修改密码最长天数； -w，设置用户在密码过期前多少天收到警告消息； -1，立即让用户密码过期； -i，设置密码过期多少天后禁用账户； -l，立即锁定一个用户； -u，立即解除用户锁定； -d，删除用户密码，若用户处于锁定状态，会进行解锁； -s，显示用户密码信息。 root用户可以修改任何用户的密码，普通用户只能修改自己的密码。 与密码有关的配置文件都保存在&#x2F;etc&#x2F;login.dfs文件中，其中包含PASS_MAX_DAYS、PASS_MIN_DAYS、PASS_WARN_AGE。分别表示：密码最长使用天数、密码两次修改最短间隔天数，密码过期前几天提醒用户。 若最短间隔天数为0，则表示任何时候都可以修改密码； 示例 1234[root@localhost ~]# cat /etc/shadow | grep yynyyn:!::0:99999:7:::# 用户名:密码# !表示用户没有设置密码。 查看用户密码信息 12[root@localhost ~]# passwd -S yynyyn PS 1969-12-31 0 99999 7 -1 (Password set, SM3 crypt.) 创建用户 1234567[root@localhost ~]# useradd u1[root@localhost ~]# useradd u2 -d /home/aaa[root@localhost ~]# useradd u3 -u 2234[root@localhost ~]# tail -3 /etc/passwdu1:x:1004:1004::/home/u1:/bin/bashu2:x:1005:1005::/home/aaa:/bin/bashu3:x:2234:2234::/home/u3:/bin/bash 修改用户用户名 123[root@localhost ~]# usermod -l u4 u3[root@localhost ~]# tail -1 /etc/passwdu4:x:2234:2234::/home/u3:/bin/bash 修改用户家目录 1234[root@localhost ~]# mkdir /home/aaaww[root@localhost ~]# usermod -d /home/aaaww u4 # 这里应为home，写错了，但是好像成功了[root@localhost ~]# tail -1 /etc/passwdu4:x:2234:2234::/home/aaaww:/bin/bash 其他 使用who查看登录用户的信息； id，查看用户信息； 用户组 具有相同特性用户的逻辑集合，通过组的形式使得具有相同特性的多个用户拥有相同的权限，便于管理； 每个用户都拥有自己的私有组； 同一组内所有游湖可以共享该组下的文件； 每个用户组都会被分配一个gid； 用户组GID与UID类似，GID作为唯一标识符来标示一个用户组； 添加用户时，默认情况下回同时建立一个与用户同名且UID和GID相同的组； GID与UID为0，都表示超级用户组或超级用户； 系统预留一些较前的GID给虚拟用户（也称为系统用户）。 可以通过id [option] [user_name]，查看用户组gid及每个用户组拥有的用户数量； 用户组分类 普通用户组：可以加入多个用户； 系统组：一般加入的用户为系统用户； 私有组：也称基本组，在创建用户时，若没有指明所属用户组，则会为该用户定义一个私有的用户组，且用户组名与用户名同名。 私有组在有其他用户加入时，就会变成一个普通用户组。 管理命令创建组 groupadd创建一个新的用户组，并将新用户组信息添加到系统文件中； 语法：groupadd [options] group_name -f，强制创建， 若组已存在，则不输出错误信息； -g，为新用户组指定GID； -o，允许创建拥有重复GID的组； -p，为新用户组使用加密过的密码； -r，创建一个系统账户； -h，展示帮助信息； 示例 123[root@localhost ~]# groupadd yynGroup[root@localhost ~]# tail -1 /etc/groupyynGroup:x:2235: 修改用户组 groupmod修改组gid或名称； 语法：groupmod [options] group_name -g，指定要使用的GID； -o，允许重复GID； -n，修改组名称； -p，修改密码； -h，展示帮助信息。 示例 修改用户组GID 12345[root@localhost ~]# id yyn用户id=1003(yyn) 组id=1000(yyn) 组=1000(yyn),10(wheel)[root@localhost ~]# groupmod -g 1006 yyn[root@localhost ~]# id yyn用户id=1003(yyn) 组id=1006(yyn) 组=1006(yyn),10(wheel) 删除用户组 groupdel删除用户组； 若用户组存在一些用户，需要先删除用户，才能删除用户组； 语法：groupdel [options] group_name -f，强制删除，可以解决一些无法删除的组； 如：一些私有组。 -h，展示帮助信息； 关联用户和组 gpasswdgpasswd添加或删除用户到组中。 语法：gpasswd [option] group_name -a，向组group中添加用户user； -d，从组group中删除用户； -M，向组添加多个成员； -A user1,…，设置组的管理员（可以有多个）； -r，删除组密码； -R，限制用户登入组，只有组成员擦可以用newgrp加入该组； -Q，要chroot进的目录 示例 1234[root@localhost ~]# gpasswd -a yyn yynGroup正在将用户“yyn”加入到“yynGroup”组中[root@localhost ~]# groups yynyyn : yyn wheel yynGroup 用户与组的关联文件 &#x2F;etc&#x2F;passwd：用户账号信息文件； [root@localhost ~]# tail -1 /etc/passwd u2:x:1005:1005::/home/aaa:/bin/bash 123456789101112 - 用户名:密码:UID:GID:备注信息:HOME目录:默认SHELL- /etc/shadow：用户账号信息加密文件； - 存储密码信息； - 只有root用户具有读权限； - ```shell [root@localhost ~]# tail -1 /etc/shadow u2:!:19289:0:99999:7::: 用户名:加密密码:最后一次修改时间:最小修改时间间隔:密码有效期:密码需要变更前警告天数:密码宽限时间:账号失效时间:保留字段 密码字段为!或*，表示用户当前无法登录； 用户组关联文件 &#x2F;etc&#x2F;group：组信息文件； 每一行记录代表一个用户组； 一个组中可以有多个用户，一个用户可以属于不同的组； [root@localhost ~]# tail -1 /etc/group yynGroup:x:2235:yyn 12345678910 - 组名:组密码:GID:组内用户列表- /etc/gshadow：组信息加密文件； - 保存组加密信息，如用户组管理密码； - ```shell [root@localhost ~]# tail -1 /etc/gshadow yynGroup:!::yyn 组名:组密码:用户组管理员:用户组附加用户 示例 向用户组添加用户。 123[root@localhost ~]# gpasswd -M u1,u2,yyn yynGroup[root@localhost ~]# tail -1 /etc/groupyynGroup:x:2235:u1,u2,yyn 指定GID，修改GID 123456[root@localhost ~]# groupadd -g 1234 yynGroup2[root@localhost ~]# tail -1 /etc/groupyynGroup2:x:1234:[root@localhost ~]# groupmod -g 2345 yynGroup2[root@localhost ~]# tail -1 /etc/groupyynGroup2:x:2345: 文件权限权限权限时操作系统用来限制对资源访问的一种机制，权限分为：读、写、执行； 在Linux系统中，每个文件或目录都具有特定的访问权限，所属用户及所属组； 一个文件或目录有三种权限：文件属主的访问、用户组成员访问和系统中任何用户访问； 123456789[root@localhost ~]# ls -l总用量 44drwxr-xr-x. 2 root root 4096 10月 24 06:53 ddrwxr-xr-x. 2 root root 4096 10月 24 06:56 d2#文件类型权限 连结数 所有者 所属组 文件容量 最后修改日期 文件名# 其中# drwxr-xr-x# 第一位是文件类型，剩余9位是文件权限位； 连结数 若是一个文件，则表示当前文件的连结数量； 若是一个目录，则表示目录下的子目录数量，其中另包含“.”和”..”两个； 文件容量 对于一个文件，则表示文件字节大小； 对于一个目录，则表示目录符的大小，不包含其中的文件； 文件名 不同类型文件有不同颜色； 白色，普通文件； 蓝色，目录文件； 绿色，可执行文件； 青色，软链接文件； 红色，压缩文件； … 文件类型 -：普通文件，除去其他6种类型文件； d：目录 b：块设备文件，可随机存取装置； c：字符设备文件 -&gt; 键盘、鼠标等一次性读取装置； l：符号链接文件； p：命名管道文件（piep） s：套接字文件（socket） b和c一般出现在&#x2F;dev目录下； 权限位说明 drwxr-xr-x 文件类型 属主权限 属组权限 其他用户权限 位置 0 1 2 3 4 5 6 7 8 9 表示 d r w x r - x r - x 描述 目录文件 读 写 执行 读 写 执行 读 写 执行","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://zswh33.github.io/tags/Linux/"}]},{"title":"Java 并发 Tools Note","slug":"Java-并发-Tools-Note","date":"2022-11-15T01:52:59.000Z","updated":"2022-11-15T02:13:38.338Z","comments":true,"path":"2022/11/15/Java-并发-Tools-Note/","link":"","permalink":"http://zswh33.github.io/2022/11/15/Java-%E5%B9%B6%E5%8F%91-Tools-Note/","excerpt":"","text":"性能分析工具Lmbench3、vmstat vmstathttps://www.cnblogs.com/ggjucheng/archive/2012/01/05/2312625.html vmstat是Linux下的一个监控工具，可以用来 CPU使用率 内存使用 虚拟内存交换IO读写情况； 123$ vmstat 2 1# 第一个参数表示采样的时间间隔数# 第二个参数表示采样的次数，是可选参数，不输入表示一直采样 12345678910111213yyn@yynlinux:~$ vmstat 1procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu----- r b swpd free buff cache si so bi bo in cs us sy id wa st 0 0 0 2560392 36372 699792 0 0 365 226 173 465 1 2 96 0 0 0 0 0 2560392 36372 699792 0 0 0 0 143 347 1 1 98 0 0 1 0 0 2560392 36372 699792 0 0 0 0 147 344 1 1 98 0 0 1 0 0 2560392 36372 699792 0 0 0 0 150 341 1 1 98 0 0 5 0 0 2560392 36372 699792 0 0 0 0 146 339 0 1 99 0 0 0 0 0 2560392 36372 699792 0 0 0 0 144 344 1 0 99 0 0 0 0 0 2560392 36372 699792 0 0 0 0 148 338 1 1 98 0 0 2 0 0 2560392 36372 699792 0 0 0 0 134 334 0 0 100 0 0 0 0 0 2560392 36372 699792 0 0 0 0 145 335 1 0 99 0 0 这里表示vmstat每1秒采集一次数据； r表示运行队列，即多少进程真的分配到CPU； 当这个值超过CPU数目，就会出现CPU瓶颈； b：阻塞的进程； swpd：虚拟内存使用大小，如果大于0，表示物理内存不足了； free：空闲物理内存大小（内存&#x2F;运存）； buff：Linux用来存储目录索引，权限等缓存； cache：打开的文件的文件缓冲区； si：每秒从磁盘读入虚拟内存的大小，值大于0表示物理内存不够用或内存泄漏 so：每秒从虚拟内存写入磁盘的大小； bi：块设备每秒接收的块数量； 块设备指：系统上的所有磁盘和其他块设备，默认块大小1024byte。比如：磁盘写入速度； bo：块设备每秒发送的块数量； 比如：磁盘读入速度； bi和bo的值一般要接近0，否则就是IO过于频繁，需要调整； in：每秒CPU中断次数，包括时间中断； cs：每秒上下文切换次数，比如：调用系统函数，线程的切换等会触发上下文切换。这个值越小越好，太大要考虑调低线程或者进程的数目； us：用户CPU时间； sy：系统CPU时间。如果太高，表示系统调用时间长，如IO操作频繁； id：空闲CPU时间，一般来说：id + us + sy = 100 wt：等待IO CPU时间。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://zswh33.github.io/tags/Java/"}]},{"title":"Java 并发编程艺术 Note","slug":"Java-并发编程艺术-Note","date":"2022-11-15T01:48:26.000Z","updated":"2022-11-18T02:42:18.575Z","comments":true,"path":"2022/11/15/Java-并发编程艺术-Note/","link":"","permalink":"http://zswh33.github.io/2022/11/15/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF-Note/","excerpt":"","text":"《Java并发编程的艺术》阅读笔记 如何减少上下文切换减少上下文切换 无锁并发编程。 多线程竞争锁，会引发上下文切换 -&gt; 考虑避免使用锁； 如，将数据的ID按照Hash算法取模分段，不同线程处理不同段的数据； CAS算法 Java的Atomic包使用CAS算法来更新数据，不需要加锁； 使用最少线程 避免创建不必要的线程； 协程：在单线程实现多任务的调度，在单线程里维持多个任务间的切换； 避免死锁 避免一个线程同时获取多个锁； 避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源； 尝试使用定时锁，使用lock.tryLock(timeout)来替代使用内部锁机制； 对于数据库锁，加锁和解锁必须在一个数据库连接里，否则可能出现解锁失败的情况； 服务器集群可以使用ODPS或Hadoop搭建一个服务器集群。 volatile定义：Java编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致地更新，线程应却表通过排它锁单独获得这个变量； CPU术语《Java并发编程的艺术》Page.9 术语 英文 描述 内存屏障 memory barriers 是一组处理器指令，用于实现对内存操作的顺序限制。 缓冲行 cache line CPU高速缓存中可以分配的最小存储单位。处理器填写缓存行会加载整个缓存行，现存CPU需要执行几百次CPU指令。 原子操作 atomic operations 不可中断的一个或一系列操作。 缓存行填充 cache line fill 当处理器识别到从内存中读取操作数是可缓存的，处理器读取整个高速缓存行到适当的缓存（L1，L2，L3或所有）。 缓存命中 cache hit 如果进行高速缓存行填充操作的内存位置仍然是下次处理器访问的地址时，处理器从缓存中读取操作数，而不是从内存读取。 写命中 write hit 当处理器将操作数写回到一个内存缓存的区域时，它首先会检查这个缓存的内存地址是否在缓存行中，如果存在一个有效的缓存行，则处理器将这个操作数写回到缓存，而不是写回到内存，这个操作称为写命中。 写缺失 write misses the cache 一个有效的缓存行被写入到不存在的内存区域。 如何实现可见性 如果对volatile变量进行写操作，JVM就会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据协会到系统内存； 为了保证各个处理器的缓存是一致的，实现了缓存一致性协议 每个处理器通过嗅探总线上传播的数据来检查自己的缓存值是否过期， 当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置为无效状态， 当处理器对这个数据进行修改操作，会重新从系统内存中把数据读到处理器缓存里。 实现原则 Lock前缀指令会引起处理器缓存协会到内存。 一个处理器的缓存回写到内存会导致其他处理器的缓存无效 IA-32处理器和Intel 64处理器使用MESI（修改，独占，共享，无效）控制协议去维护内部缓存和其他处理器缓存的一致性； IA-32和Intel 64处理器能嗅探其他处理器访问系统内存和他们的内部缓存。处理器使用嗅探技术保证它的内部缓存、系统内存和其他处理器的缓存的数据在总线上保持一致； 在Pentium和P6 family处理器中，如果有处理器嗅探到别的处理器打算写内存地址，而这个地址处于共享状态，那么这个处理器会使它的缓存行无效，在下次访问相同内存地址时，强制执行缓存行填充。 案例：追加字节数提高volatile《Java并发编程的艺术》Page.10 著名Java并发编程大师Dong lea在JDK 7 里新增了一个队列集合类LinkedTransferQueue，在使用volatile变量时，使用追加字节的方式来优化队列出队，入队的性能： 12345678910private transient final PaddedAtomicReference&lt;QNode&gt; head;private transient final PaddedAtomicReference&lt;QNode&gt; tail;static final class PaddedAtomicReference &lt;T&gt; extends AtomicReference &lt;T&gt;&#123; Object p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,pa,pb,pc,pd,pe; PaddedAtomicReference(T r)&#123;supre(r);&#125;&#125;public class AtomicReference &lt;V&gt; implements java.io.Serializable&#123; private volatile V value; //...&#125; 这里的目的是：将对象追加到64字节； 一个对象引用4字节，有15个变量即60个字节,再加上父类value变量，一共64个字节； 为什么要添加到64字节？ 对于英特尔酷睿i7，酷睿、Atom和NetBurst，以及Core Solo和Pentium M处理器上的L1、L2、L3缓存的高速缓存行是64个字节宽，不支持部分填充缓存行； 这意味着，若队列头结点和尾节点不足64字节的话，处理器会将他们读到同一个高速缓存行中； 当一个处理器试图修改头结点，会将整个缓存行锁定；在缓存一致性机制下，其他处理器会不能访问高速缓存的尾节点； 而队列的入队和出队操作需要不停修改头结点尾节点，在多处理器情况下会严重影响到队列的入队和出队效率； 追加到64字节，填满高速缓冲区的缓存行，避免头结点和尾节点加载到同一个缓存行，使头、尾节点不互相锁定。 是不是所有的volatile变量都要追加到64字节呢？ 不是。 缓存行非64位宽的处理器不能； 如P6系列和奔腾处理器，他们的L1和L2高速缓存行是32个字节宽； 共享变量不会被频繁地写。 追加字节的方式需要处理器读取更多字节到高速缓冲区，本身带来一定性能损耗，如果变量本身不被频繁写，锁的几率是非常小的，就没必要通过追加字节的方式来避免互相锁定。 其他：该写法Java7下不生效，Java7会淘汰或重新排列无用字段； Synchronized原理synchronized实现同步的基础：Java中每个对象都可以作为锁； 对于普通同步方法，锁的是当前实例对象； 对于静态同步方法，锁是当前类的Class对象； 对于同步代码块，锁是Synchronized括号里配置的对象。 在JVM中原理 当一个线程视图访问同步代码块时，首先必须得到锁，退出或抛出异常时必须释放锁； 在JVM中，代码块的同步是使用monitorenter和monitorexit指令实现的： monitorenter插入到同步代码块的开始位置，monitorexit插入到同步代码块的结束和异常位置； JVM保证：每个monitorenter必须有对应的monitorexit与之配对； 任何一个对象都有一个monitor与之关联，当一个monitor被持有后，它将处于锁定状态； 线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor所有权，即尝试获取monitor的锁。 Java对象头synchronized用的锁在Java的对象头里； 若对象是数组类型，则虚拟机用3个字宽存储对象头； 若对象是非数组类型，则用2个字宽存储对象头； 在32位虚拟机中，1字宽等于4字节，即32bit； Java对象头的长度 长度 内容 说明 32&#x2F;64bit Mark Word 对象的hashCode或锁信息等 32&#x2F;64bit Class Metadata Address 对象类型数据的指针 32&#x2F;32bit Array Length 数组的长度（若对象是数组） Java对象头的Mark Word默认存储对象的：HashCode，分代年龄和锁标记位。 32位JVM Mark Word Java对象头存储结构 锁状态 25bit 4bit 1bit 是否偏向锁 2bit 锁标志位 无锁状态 对象的hashCode 对象分代年龄 0 01 Mark Word 运行期间变化 锁状态 25bit 4bit 1bit 2bit 23bit 2bit 是否是偏向锁 锁标志位 轻量级锁 指向栈中锁记录的指针 00 重量级锁 指向互斥量（重量级锁）的指针 10 GC标记 空 11 偏向锁 线程ID Epoch 对象分代年龄 1 01 在64位虚拟机下，Mark Word是64bit大小的； 64位虚拟机下，Mark Word 存储结构 锁状态 25bit 31bit 1bit 4bit 1bit 2bit cms_free 分代年龄 偏向锁 锁标志位 无锁 unused hashCode 0 01 偏向锁 ThreadId(54bit) Epoch(2bit) 1 01 锁的升级和对比Java SE1.6为了减少锁和释放锁带来的性能消耗，引入了偏向锁和轻量级锁； 在Java SE 1.6中，锁一共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态。 锁可以升级但不能降级，即偏向锁升级成轻量级锁后不能降低到偏向锁，目的是为了提高获得和释放锁的效率。 偏向锁HotSpot作者研究发现，大多数情况下，锁不仅不存在多线程竞争，而且总是由同一个线程多次获得。为了让线程获得锁的代价更低而引入了偏向锁； 当一个线程访问同步块并获得锁时，会在对象头和栈帧中的锁记录里存储偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里是否存储指向当前线程的偏向锁。若测试成功，表示线程已经获得了锁。若测试失败，则需要再测试一下Mark Word中偏向锁的标志是否为1（表示当前是偏向锁）；若没有设置，则使用CAS竞争锁；若设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。 偏向锁执行流程 一个线程访问同步块 测试对象头的Mark Word是否存储指向当前线程的偏向锁 存在 线程获得锁 不存在 测试Mark Word中偏向锁的标志是否为1 是：尝试使用CAS将对象头的偏向锁指向当前线程 不是：使用CAS竞争锁 偏向锁的撤销 偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁； 偏向锁的撤销，需要等待一个全局安全点（这个时间点没有正在执行的字节码）； 当出现竞争，首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，若线程不活跃，则将对象头设置为无锁状态；若线程存活，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或标记对象不适合作为偏向锁，最后唤醒暂停的线程； 撤销流程 出现竞争 暂停拥有偏向锁的线程 检查持有偏向锁的线程是否存活 未存活 对象头设置为无锁状态； 存活 拥有偏向锁的栈会被执行 遍历对象的锁记录 栈中的锁记录和对象头的Mark Word 要么重新偏向于其他线程， 要么恢复好无锁或标记对象不适合作为偏向锁 唤醒暂停的线程","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://zswh33.github.io/tags/Java/"}]},{"title":"平衡二叉树以及其拓展 Note","slug":"平衡二叉树以及其拓展-Note","date":"2022-11-09T04:00:54.000Z","updated":"2022-11-09T04:01:49.132Z","comments":true,"path":"2022/11/09/平衡二叉树以及其拓展-Note/","link":"","permalink":"http://zswh33.github.io/2022/11/09/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E4%BB%A5%E5%8F%8A%E5%85%B6%E6%8B%93%E5%B1%95-Note/","excerpt":"","text":"二叉平衡树http://c.biancheng.net/view/3432.html https://blog.csdn.net/u014454538/article/details/120103527 平衡二叉树，又称为AVL树，遵循： 每棵子树的左子树和右子树深度差不能超过1； 二叉树每棵子树都要求是平衡二叉树。 平衡因子表示左子树深度和右子树深度的差，取值可能为0、1和-1； 情况LL、RR、LR、RL 右旋 将根节点绕左儿子顺时针下压 条件： LL：新插入节点在根节点的左儿子的左子树上； 左旋 将根节点绕右儿子逆时针下压 条件：RR： 新插入节点在根节点的右儿子的右子树上； LR 条件： LR：新插入节点在根节点的左儿子的右子树上； 操作： 以左儿子为根节点左旋，再将原根节点右旋； RL 条件： RL：新插入结点在根节点的右儿子的左子树上； 操作 以右儿子为根节点右旋，再将原根节点左旋； 红黑树","categories":[],"tags":[{"name":"Note","slug":"Note","permalink":"http://zswh33.github.io/tags/Note/"}]},{"title":"Nginx Note Variable","slug":"Nginx-Note-Variable","date":"2022-11-01T11:54:36.000Z","updated":"2022-11-01T13:02:32.240Z","comments":true,"path":"2022/11/01/Nginx-Note-Variable/","link":"","permalink":"http://zswh33.github.io/2022/11/01/Nginx-Note-Variable/","excerpt":"","text":"变量地址$binary_remote_addr和$remote_addr$remote_addr长度为7-15bytes； $binary_remote_addr长度为4bytes。 都是客户端地址； $server_name上游服务器的地址； $query_string请求连接的地址； 比如：https://www.baidu.com/s?&amp;wd=qwe","categories":[],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://zswh33.github.io/tags/Nginx/"}]},{"title":"Nginx Note","slug":"Nginx-Note","date":"2022-11-01T11:48:19.000Z","updated":"2022-11-01T13:06:01.870Z","comments":true,"path":"2022/11/01/Nginx-Note/","link":"","permalink":"http://zswh33.github.io/2022/11/01/Nginx-Note/","excerpt":"","text":"https://blog.csdn.net/remotesupport/article/details/6016245 https://blog.51cto.com/qiangsh/1765013 限制连接数limit_zone1limit_zone ZONENAME KEY THE_SIZE 定义一个数据区，记录会话状态信息； ZONENAME：zone_name，数据区域的名字； KEY：这里可以是一个变量$variable，是判断会话的变量，唯一指定一个会话的变量； THE_SIZE：the_size，记录区的总容量。 例子1limit_zone one $binary_remote_addr 10m 定义一个名为“one”的区域，容量10m， 以变量**$binary_remote_addr为判断会话的基准，即一个地址一个会话**。 $remote_addr长度为7-15bytes，会话信息长度为32-64bytes； $binary_remote_addr长度为4bytes，会话信息长度为32bytes。 limit_conn1limit_conn ZONE_NAME THE_SIZE 指定一个区域会话最大的并发连接数； 当连接数超过指定的并发连接数，会返回503错误； ZONE_NAME：zone_name，区域的名字，由limit_zone定义； THE_SIZE：the_size，允许的并发连接数。 例子123456limit_zone one $binary_remote_addr 10m;server&#123; location /download/&#123; limit_conn one 5; &#125;&#125; 定义一个名为one的区域，容量为10m（这里容量指的是：10MB），一个地址一个会话； 在&#x2F;download&#x2F;目录下，一个会话只能发起5个连接，超过的进行503处理。 limit_conn_zone位于：http 1limit_conn_zone KEY zone=NAME:SIZE 定义一个区域：唯一标识一个会话、名字、大小； KEY：这里一般为$binary_remote_addr，唯一标识一个区域会话的变量；$binary_remote_addr即为用一个IP表示一个区域会话。 NAME：区域的名字； SIZE：大小，单位字节；10m表示10MB。 例子1234567limit_conn_zone $binary_remote_addr zone=addr:10mserver&#123; location /&#123; limit_conn addr 5; limit_rate 100k; &#125;&#125; 定义一个区域，名字为addr，判断会话用变量**$binary_remote_addr，区域名字为addr，大小10MB**； 在location&#x2F;下面，在名为addr的区域，一个会话允许最大连接数为5，速度限制100K； limit_conn_log_level123limit_conn_log_level info|notice|warn|error;Default: limit_conn_log_level error;Context: http, server, location 当达到最大连接数，记录日志的等级。 limit_conn_status123Syntax: limit_conn_status code;Default: limit_conn_status 503;Context: http, server, location 超过限制后，返回的相应状态码，默认503. 案例：根据请求参数限制连接12345678910limit_conn_zone $mp_limit_key zone=mp:10m;server&#123; set $mp_limit_key $binary_remote_addr; # 为key设置默认值 if ( $query_string ~ .*mp=(\\d+).* )&#123; set $mp_limit_key $1; &#125; location /&#123; limit_conn mp 10; &#125;&#125; 依据**$mp_limit_key**定义一个会话，区域名为mp，限制大小10MB； 使用正则表达式.*mp=(\\d+).*取出参数mp并设置值到mp_limit_key； 限制连接数为10。","categories":[],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://zswh33.github.io/tags/Nginx/"}]},{"title":"Java 数据结构 Note","slug":"Java-数据结构-Note","date":"2022-10-30T12:04:23.000Z","updated":"2022-12-10T01:17:34.268Z","comments":true,"path":"2022/10/30/Java-数据结构-Note/","link":"","permalink":"http://zswh33.github.io/2022/10/30/Java-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-Note/","excerpt":"","text":"Java中的队列QueueAPI 功能 抛出异常 返回false或null 添加 add() offer() 查询不删除 element() peek() 查询并删除 remove() poll() Deque双端队列 功能 抛出异常 返回false或null 添加到队列尾部 add() offer() addLast() offerLast() 添加到队列头部 push() addFirst() offerFirst() 查询不删除头部 element() peek() getFirst() peekFirst() 查询不删除尾部 getLast() peekLast() 查询并删除头部 remove()&#x2F;pop() poll() removeFirst() pollFirst() 查询并删除尾部 removeLast() pollLast() BlockingQueue阻塞队列，线程安全 功能 抛出异常 返回false或null 阻塞 阻塞等待，超时抛出异常 添加 add() offer() put() offer(E e,long timeout,TimeUnit unit) 查询并删除 take() poll(long timeout,TimeUnit unit) 其他API int remainingCapacity()：返回剩余容量； boolean remove(Object o)：删除一个指定元素，成功返回true； boolean contains(Object o)：若队列包含指定元素，返回true； int drainTo(Collection&lt;? super E&gt; c)：队列中删除所有元素，并将元素添加到指定集合； int drainTo(Collection&lt;? super E&gt; c,int maxElements)：同上，可以指定最大元素数量； BlockingDeque阻塞队列和双端队列的结合； 新增的API 等待 takeFirst &#x2F; take：查询并删除队列第一个元素，如果没有则阻塞； takeLast：查询并删除队列最后一个元素，没有则阻塞； putFirst &#x2F; putLast：插入元素，若队列满则阻塞等待； 等待超时 offerFirst(E e, long timeout,TimeUnit unit)：添加元素到队首，若队列满则等待； offer 或 offerLast(E e,long timeout,TimeUnit unit)：同上； pollFirst(long timeout,TimeUnit unit)：查询并删除第一个元素，队列空则等待，超时则抛出错误； pollLast(long timeout,TimeUnit unit)：同上； LinkedBlockingDeque链表实现的双端阻塞队列 ArrayBlockingQueue数组实现的阻塞队列 可以给定容量和访问策略 ArrayBlockingQueue(int capacity) ArrayBlockingQueue(int capacity,boolean fair) ArrayBlockingQueue(int capacity,boolean fair,Collection&lt;?extends E&gt; c) PriorityBlockingQueue优先队列的阻塞版本 不允许有null元素 SynchronousQueue 没有容量的同步队列。 一旦有消费或生产过程，就必须有相应的生产或消费过程，否则阻塞； 队列中没有容量，在这个队列中，不参与等待的API一律返回null，比如： remove、containsAll、removeAll、retainAll永远返回false； peek永远返回null。 可以指定访问策略 SynchronousQueue()，创建一个不公平的同步队列； SynchronousQueue(boolean fair)，指定公平&#x2F;不公平。 APIput(E e)：将元素添加到队列，然后阻塞等待另一个线程接收元素； offer(E e, long timeout,TimeUnit unit)：将元素插入到队列中，等待消费者消费，超时则hole..； offer(E e)：若有另一个线程在等待接收元素，则将元素插入到队列中，否则返回false； take()：查询队列首元素，删除元素并返回，若队列中没有数据则阻塞等待； poll(long timeout,TimeUnit unit)：查询队列首元素，删除元素并返回，若队列空则等待，超时返回null； poll()：查询队列首元素，删除元素并返回，若队列空则返回null； TransferQueue这个队列可以实现生产者消费者程序，并协调消息使消息能够从生产者传输到消费者； 新增APIgetWaitingConsumerCount()：获取等待的消费者数量； hasWaitingConsumer()：获取是否有消费者在等待； transfer()：将元素交给消费者，如果没有消费者，则等待； tryTransfer()：将元素交给消费者，若没有消费者，则抛弃元素，返回false； tryTransfer(E e,long timeout,Timeunit unit)：将元素交给消费者，若没有消费者，则等待，超时则抛弃元素，返回false； LinkedTransferQueue链表实现的TransferQueue。 特别的API transfer：将元素转移给消费者，若没有消费者，则等待； 将元素插入到队列尾部，然后等待消费者消费； tryTransfer(E e, long timeout, TimeUnit unit)：将元素插入队列，然后等待消费者消费；若超时，则取消阻塞，返回false；成功返回true； take：从队列的头中取出元素，若没有元素则等待； poll(long timeout, TimeUnit unit)：take的超时版本，从队列的头中取出元素，若没有元素则等待，超时返回null； poll()：从队列头部取出元素，若没有元素，则返回null； peek()：查询不删除队列头部元素，若队列空，则返回null； AbstractQueueAPIadd(E e)：添加元素，失败抛出异常； addAll(Collection&lt;? extends E&gt; c)：添加元素，失败抛出异常； clear：删除所有元素； element：查询不删除头部元素； remove：查询并删除头部元素； ConcurrentLinkedQueue基于链表，无界的线程安全队列； LinkList线程不安全，基于链表的队列； PriorityQueue优先队列特点 无限长的队列，并且动态增长，默认初始容量可以用构造参数initialCapacity参数覆盖； 不允许有NULL对象； 添加到PriorityQueue的对象必须有可比性； 默认情况下，队列按自然顺序排序； 比较器可用于队列中对象的自定义排序； 线程不安全； add和poll方法复杂度：O(log(n)) API boolean add(object) 将指定对象插入； boolean offer(object) 将指定对象插入； boolean remove(object) 从此队列删除指定元素的单个实例； Object poll()：删除并返回队列的头部，若队列为空，返回null； Object element()：获取队列头部； Object peek()：获取队列头部； clear()：从队列中删除所有元素； comparator()：返回队列的比较器； contains(Object o)：是否包含指定元素。 一些API的区别add、remove、element：抛出异常； offer、poll、peek：不抛出异常，返回null； 抛出异常 不抛出异常 添加 add offer 删除 remove poll 获取首元素 element peek","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://zswh33.github.io/tags/Java/"}]},{"title":"openEuler 1 Linux操作系统 版本更新 登录和电源管理 文件管理 文件查看 文件查找 压缩解压 软链接硬链接","slug":"openEuler-1","date":"2022-10-23T07:58:12.000Z","updated":"2022-11-26T09:13:29.703Z","comments":true,"path":"2022/10/23/openEuler-1/","link":"","permalink":"http://zswh33.github.io/2022/10/23/openEuler-1/","excerpt":"","text":"https://ilearningx.huawei.com/courses/course-v1:HuaweiX+EBG2020CCHW1100063+Self-paced/courseware/6abdf02386a84e38b9fd85e020966057/fccbc4b5a17b45d99cbef50dd9ff5466/ 操作系统操作系统：是指控制和管理整个计算机系统的硬件和软件资源、并合理地组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境的程序集合。 Linux版本介绍 内核版本 Linux内核版本号由3个数字组成：5.19.16 第一个数字：目前发布的内核版本 第二个数字：偶数表示稳定版本，奇数表示开发中版本。 第三个数字：错误修补的次数。 发行版本 商业发行版：由商业公司维护，提供收费的服务，如升级补丁； 社区发行版：由社区组织维护。 openEuler操作系统是一款开源、免费的操作系统，由openEuler社区运作。内核源于Linux，支持鲲鹏及其他多种处理器，适用于数据库、大数据、云计算、人工智能等应用场景。 版本号 创新版本：相对较新，半年一版本； LTS：稳定版，两年一版本。 分区 swap：交换分区。在内存空间不足时，用于置换内存中的脏数据。 内存较小时建议为内存大小的两倍； 内存较大时，根据情况分配。 boot：系统引导程序 boot&#x2F;efi：EFI固件要启动的引导器和应用程序 &#x2F;：根分区 安装选择 最小安装 最小化安装Linux。 服务器 安装服务器场景涉及到的软件。 虚拟化主机 虚拟化场景设计的相关软件。 Linux的GUI和CLIGUI，图形用户界面； CLI，命令行界面； 登录Linux 本地登录 一个典型的Linux将运行6个虚拟控制台和1个图形控制台。openEuler目前没有图形控制台； 可以通过ctrl + alt + F1-F6 在虚拟控制台之间切换； 远程登录 软件：putty，xshell等。 Shell 常见的Shell：bash，sh，csh，ksh。 系统默认提示符：[当前用户名@主机名 当前所在位置]$ 其中最后的符号，root用户为#，其他用户为$ 用户 为保障系统安全： 初次登录系统修改密码 定期修改密码 设计高复杂度密码 八位以上字符，包含大写、小写字母，数字和特殊字符中三种及以上的字符。 修改密码：passwd root用户拥有最高权限 切换用户使用：su [用户名] 无参默认切换root用户 Shell快捷操作 tab：命令补全； history：查看历史命令； history n：执行编号为n的历史命令； ↑&#x2F;↓：历史命令切换，上一个命令&#x2F;下一个命令； home&#x2F;end：切换到行首&#x2F;行尾； Ctrl + A 移动光标到行首 Ctrl + E 移动光标到行尾 Ctrl + C 终止当前程序 clear或Ctrl + L：快速清屏。 二 双击Tab可以列出所有可用命令； Linux命令分类 分类 命令 登录和电源管理 login, shutdown, halt, reboot, install, exit, last等 文件处理 file, mkdir, grep, dd, find, mv, ls, diff, cat, ln等 系统管理 df, top, free, quota, at, ip, kill, crontab等 网络操作 ifconfig, ip, ping, netstat, telnet, ftp, route, rlogin, rcp, finger, mail, nslookup等 系统安全 passwd, su, umask, chgrp, chmod, chown, chattr, sudo ps, who等 其他 tar, unzip, gunzip, unarj, mtools, man 登录和管理电源loginLinux是一个多用户操作系统，可以同时接收多个用户登录，还允许一个用户进行多次登录； 虚拟控制台切换使用“alt和一个功能键”实现，通常使用F1-F6； last查看最近的登录记录 1234[root@localhost ~]# lastroot pts/0 192.168.227.1 Sun Oct 23 23:01 still logged inyyn tty1 Sun Oct 23 18:39 still logged inreboot system boot 5.10.0-106.18.0. Mon Oct 24 02:38 still running last -n 3或 last -3：显示最近的3条登录记录； last tty2：tty2虚拟控制台的登录记录； last root：root用户的登录记录； exit退出登录。 shutdown介绍 shutdown作用是关闭计算机，权限是超级用户。 参数： -h：关机后关闭电源； -r：关机后打开电源（重启）； -t：改变到其他运行级别之前，告诉init程序多久以后关机； -k：不关机，送警告信号给每位登陆者； -F：在重启计算机时强迫fsck； -f：关机时，不做fsck动作； -t seconds：设定关机前时间； -C：取消自动关机 shutdown命令可以安全地将系统关机，直接断掉电源方式关闭Linux十分危险； Linux后台运行着许多进程；强制关机会导致进程数据丢失；使系统处于不稳定状态，甚至可能损坏硬件设备。 使用shutdown可以向其他用户通知警告信息，并冻结login命令，禁止登录。 halthalt命令的作用是关闭系统，使用权限是超级用户； 主要参数 -n：方式sync系统调用，它用在用fsck修复根分区后，以阻止内核用老版本的超级块覆盖修补过的超级块； -w：不重启和关机，只是写wtmp（&#x2F;var&#x2F;log&#x2F;wtmp）记录； -f：不调用shutdown，强制关机或重启； -i：关机或重启前，关闭所有网络接口； -d：关闭系统，不留下记录。 rebootreboot命令作用是重启计算机，权限：系统管理者； 主要参数： -n：保存数据后重启系统； -w：不重启，只是把记录写到&#x2F;var&#x2F;log&#x2F;wtmp文件里； -d：不写记录到&#x2F;var&#x2F;log&#x2F;wtmp文件里； -i：关闭网络设置后再重启系统； 文件管理目录介绍 &#x2F;：根目录 &#x2F;bin：所有用户使用的二进制程序目录 &#x2F;boot：引导加载程序文件目录 &#x2F;dev：设备文件目录 &#x2F;etc：配置文件目录 &#x2F;lib：系统库目录，动态链接共享库 &#x2F;lib64：64位的系统库目录 &#x2F;media：可移动媒体设备目录 &#x2F;mnt：挂载目录 &#x2F;opt：应用软件存放目录 &#x2F;proc：进程信息目录 &#x2F;root：root用户主目录 &#x2F;run：内存文件系统目录，临时文件目录，存储系统运行以来的文件目录，系统重启后目录会被清空； &#x2F;sbin：系统管理员用户使用的二进制程序目录； &#x2F;srv：服务数据目录； &#x2F;sys：内核设备树目录，Linux2.6内核新出现的文件系统sysfs； &#x2F;tmp：存放临时文件的目录 &#x2F;usr：用户应用程序和配置目录，类似于windows的Program Files目录； &#x2F;var：动态目录，用于存放经常被修改的文件，比如日志； &#x2F;home：用户用其存储个人配置。 路径分为绝对路径和相对路径； pwd打印当前的工作目录； 运行参数： -L，目录连接链接时，输出连接路径； -P：输出物理路径，即文件在设备中的路径； cd用于改变当前工作目录； 使用 cd &#x2F;usr：进入&#x2F;usr目录 cd .. cd . 进入当前目录 cd 或 cd ~ ：回到家目录 cd - ：回到前一个目录，可以在两个目录间跳转； ls列出目录内容或文件信息 参数 -a：显示所有文件及目录，包括隐藏文件和目录； -l：除文件名外，打印另包含文件形态，权限，拥有者，文件大小等； -t：将文件按照建立时间先后次序列出； -S：将文件按文件大小依次列出； -R：若目录下有文件，则将目录下文件也列出； mkdir创建目录（文件夹） 123mkdir dir1 # 创建一个dir1文件夹mkdir dir2 dir3 dir4 # 创建三个文件夹mkdir -p dir/dir5 # 创建dir，然后在dir下创建dir5；若dir不存在，需要添加 -p 参数 cp复制文件或目录，可以复制单个文件，可以复制多个文件； 语法：cp [OPTION]… SOURCE… DIRECTORY -a：保留链接，文件属性，并复制目录下所有内容； -p：除文件内容外，还把修改时间和放文件权限也复制到新文件； -r：若源文件是目录文件，则复制包含目录下所有子目录和文件； -l：不复制文件，只是生成链接文件。 mv移动文件或目录。 若源文件和目标文件在同一个父目录里面，则mv命令效果相当于给文件命名； 语法：mv [选项] 源文件或目录 目标文件或目录 -b：若需要覆盖文件，覆盖前进行备份； -f：force强制，若目标文件存在，不询问直接覆盖； -i：若目标文件存在，询问是否覆盖； -u：若目标文件存在，且源文件比较新，则覆盖； rm删除文件或目录； 语法：rm [OPTION] file_or_dir -f，–force：忽略不存在的文件，不给出提示，直接删除； -i，–interactive：进行交互式删除； -r，-R，–recursive：指示rm将参数中列出的全部目录和子目录递归删除，即删除目标目录包含其子目录及文件； -v，–verbose：输出删除日志； cat读取文件全部内容，或将几个文件合并为一个文件； 语法：cat [OPTION] [FILE] -A，–show-all：等价于-vET； -b，–number-nonblank：对非空输出行编号； -E，–show-ends：每行结尾处显示$； -n，–number：所有行显示行号，从1开始； head显示文件开头的内容，head命令默认打印文件开头10行； 语法：head [OPTION] [FILE] -q：隐藏文件名，默认开启； -v：显示文件名； -c&lt;字节&gt; 指定打印结果的字节数； -n&lt;行数&gt;：指定打印行数。 tail读取文件尾部； 语法：tail [OPTION]… [FILE]… -f：循环读取； -q：不显示处理信息； -v：显示详细的处理信息； -c&lt;数目&gt; 指定打印结果的字节数； -n&lt;行数&gt; 指定显示行数； more逐页阅读文件。more会加载整个文件； 使用按键 space 或 Ctrl+F：下一页 b,back 或 Ctrl+B：上一页 Enter：向下n行，默认n为1； **&#x3D;**：输出当前行行号； v：使用vi编辑器 !：调用Shell，并执行命令； q：退出 语法：more [OPTION] [FILE] +n 从第n行开始显示； -n 定义屏幕大小为n行； +&#x2F;pattern 在文件打开前进行表达式搜索，然后从该子串之后开始显示； -c 先进行清屏，然后显示 less可以随意浏览文件；less运行后不会加载整个文件。 语法：less [OPTION]… [FILE]… 操作： &#x2F;字符串：向下搜索字符串； ?字符串：向上搜索字符串； q：退出； space：下一页； Enter：下一行； PageUp：上一页； PageDown：下一页。 find查找指定目录下的文件； 可以指定一些匹配条件，如按文件名、文件类型、用户甚至是时间戳查找文件； 语法：find [path…] [expression] -name 按照文件名查找文件； -perm 按照文件权限查找文件； -user 按照文件属主来查找文件； -mtime -n +n 按照文件更改时间来查找文件； -type，按照类型查找文件 d 目录 f 一般文件 l 软链接 使用：-type d 表示查找目录文件 -empty 查找空文件和空目录 -empty -delete 找到空文件并删除 which在PATH指定目录主查找可执行文件； 查找命令的执行文件的路径； 语法：which [options] programname […] gzip压缩和解压缩； 存疑：不能将多个文件打包到同一个文件夹中。 压缩率60%-70%； 压缩结果为gzip文件； 语法：gzip [options] [file or directory] -d，–decompress或–uncompress，解压缩文件； -f或–force，强行压缩文件，不考虑文件名是否存在或文件是否为符号链接； -l或–list，列出压缩文件的相关信息； -r或–recursive，递归处理，将指定目录下所有文件和子目录一并处理； -v或–verbose，显示指令执行过程。 tar将多个文件打包为一个文件； 语法：tar [OPTION…] [FILE] -c 建立新的压缩文件； -x 从压缩的文件中提取文件； -t 显示压缩文件的内容； -z 支持gzip解压文件 -j 支持bzip2解压文件； -v 显示操作过程； -C 指定操作目录 实战 tar -czf dir.tar.gz dir，创建压缩文件； tar -xvf dir.tar.gz -C dir2 ，解压缩文件； ln创建链接文件； Linux中链接分为软链接和硬链接； 软链接： 以路径形式存在，类似于Windows的快捷方式 删除源文件后链接失效； 可以对目录进行链接； 可以跨文件系统； 硬链接： 以文件副本形式存在，不占用实际空间； 删除源文件后无影响； 不可以对目录进行链接； 不可以跨文件系统。 ln命令默认创建硬链接； 语法：ln [-f | -n] [ -s ] SourceFile [Targetfile] -b，删除，覆盖以前建立的链接； -d，允许超级用户制作目录的硬链接； -f，强制执行； -i，交互模式，文件存在提示用户是否覆盖； -n，对目录创建符号链接时，创建的符号链接可以视为一般目录，也就是可以cd； -s，软链接（符号链接）。 注意 SourceFile为一个路径表达式，若为“.&#x2F;w.c”表示当前目录的w.c文件；若为”&#x2F;home&#x2F;yyn&#x2F;w.c”则表示yyn目录下的w.c文件；这里可以是相对位置也可以是绝对位置，创建时源文件可以不存在； ​","categories":[],"tags":[{"name":"openEuler Linux","slug":"openEuler-Linux","permalink":"http://zswh33.github.io/tags/openEuler-Linux/"}]},{"title":"Java并发 2","slug":"Java并发-2","date":"2022-10-20T01:25:52.000Z","updated":"2022-10-20T03:41:41.672Z","comments":true,"path":"2022/10/20/Java并发-2/","link":"","permalink":"http://zswh33.github.io/2022/10/20/Java%E5%B9%B6%E5%8F%91-2/","excerpt":"","text":"创建线程，实现接口优于继承Thread Java不支持多继承，因此继承了Thread类就无法继承其他类； 类可能只要求可执行就可，继承Thread开销过大。 基础线程机制ExecutorExecutor管理多个异步任务的执行，无需程序员显式地管理线程的生命周期。 目前有三种Executor： CachedThreadPool：一个任务创建一个线程； FixedThreadPool：所有任务使用固定数量的线程，多出来的排队或丢弃，取决于初始化参数； SingleThreadExecutor：大小为1的FixedThreadPool。 12345678910111213141516public class ExecutorStudy &#123; public static void main(String[] args) &#123; ExecutorService executorService = Executors.newFixedThreadPool(5); for (int i = 0; i &lt; 30; i++) &#123; executorService.execute(()-&gt;&#123; System.out.println(Thread.currentThread().getName()+&quot; Execute.&quot;); try &#123; TimeUnit.MILLISECONDS.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); &#125; executorService.shutdown(); &#125;&#125; DaemonDaemon，即守护线程。 守护线程是程序运行时在后台提供服务的线程，不是程序中不可或缺的部分。 当所有非守护线程结束时，程序也将终止，同时会杀死所有守护线程。 主线程不是守护线程； 使用setDaemon()可以设置一个线程为守护线程。 1234Thread thread = new Thread(() -&gt; &#123; System.out.println(&quot;这即将是一个守护线程&quot;);&#125;);thread.setDaemon(true);//设置守护线程 sleep()休眠当前线程为指定时间。 123456Thread thread = new Thread(() -&gt; &#123; System.out.println(&quot;这是一个线程&quot;); try &#123; Thread.sleep(3000);//线程休眠3秒 &#125;catch (Exception e)&#123;e.printStackTrace();&#125;&#125;); yield()Thread.yield()表示当前线程已经完成了生命周期中最重要的部分。 这个方法只是给线程调度器一个建议，且只是建议具有相同优先级的其他线程可以运行。 1234Thread thread = new Thread(() -&gt; &#123; System.out.println(&quot;这是一个线程&quot;); Thread.yield();&#125;); 线程中断一个线程执行完毕后会自动结束，如果在运行过程中发生异常也会提前结束. InterruptedException当对一个线程使用了interrupt()方法，若线程处于阻塞、限期等待或无限期等待状态，就会抛出InterruptedException异常，从而提前结束该线程。 不能终端I&#x2F;O阻塞和synchronized阻塞。 示例：sleep()限期阻塞。 1234567891011121314151617public static void main(String[] args) throws InterruptedException &#123; Thread thread = new Thread(() -&gt; &#123; int cnt = 0; try &#123; while (true) &#123; System.out.println(&quot;执行 &quot; + cnt++); Thread.sleep(1000); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;, &quot;一个线程&quot;); thread.start();//启动线程 Thread.sleep(3500);//等待thread线程执行一会 thread.interrupt();//发出中断线程请求&#125; 12345678910执行 0执行 1执行 2执行 3java.lang.InterruptedException: sleep interrupted at java.lang.Thread.sleep(Native Method) at com.yn.ExecutorStudy.lambda$main$0(ExecutorStudy.java:37) at java.lang.Thread.run(Thread.java:748)Process finished with exit code 0 interrupted()如果一个线程的run()无限循环且没有sleep()方法，此时调用interrupt()方法就无法使线程提前结束。 在线程内可以用interrupted()来获取线程是否执行过interrupt，在线程内控制是否接收interrupt中断。 1234567891011public static void main(String[] args) throws InterruptedException &#123; Thread thread = new Thread(() -&gt; &#123; int cnt = 0; while (!Thread.interrupted()) &#123; System.out.println(&quot;执行 &quot; + cnt++); &#125; System.out.println(&quot;线程结束&quot;); &#125;, &quot;一个线程&quot;); thread.start();//启动线程 thread.interrupt();//发出中断线程请求&#125; Executor的中断操作Executor可以通过shutdown()方法或shutdownNow()方法来关闭Executor服务。 shutdown()会等待线程执行完毕后在进行服务关闭； shutdownNow()会调用每个线程的interrupt方法。 123456789101112131415public class ExecutorStudy2 &#123; public static void main(String[] args) &#123; ExecutorService executorService = Executors.newCachedThreadPool(); executorService.execute(()-&gt;&#123; try &#123; while (true)&#123; System.out.println(&quot;线程执行&quot;); Thread.sleep(300); &#125; &#125;catch (Exception e)&#123;e.printStackTrace();&#125; System.out.println(&quot;线程结束&quot;); &#125;); executorService.shutdownNow(); &#125;&#125; 123456789线程执行线程结束java.lang.InterruptedException: sleep interrupted at java.lang.Thread.sleep(Native Method) at com.yn.ExecutorStudy2.lambda$main$0(ExecutorStudy2.java:13) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) at java.lang.Thread.run(Thread.java:748) 通过submit()方法提交任务，可以获得一个Future对象，通过future对象可以独立控制单个线程。 1234567891011121314151617public static void main(String[] args) throws InterruptedException &#123; ExecutorService executorService = Executors.newCachedThreadPool(); Future&lt;?&gt; submit = executorService.submit(() -&gt; &#123; try &#123; while (true) &#123; System.out.println(&quot;线程执行&quot;); Thread.sleep(300); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;线程结束&quot;); &#125;); Thread.sleep(1000); submit.cancel(true);//类似于interrupt() executorService.shutdown();&#125; 123456789101112131415线程执行线程执行线程执行线程执行java.lang.InterruptedException: sleep interrupted at java.lang.Thread.sleep(Native Method) at com.yn.FutureStudy.lambda$main$0(FutureStudy.java:14) at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) at java.util.concurrent.FutureTask.run(FutureTask.java:266) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) at java.lang.Thread.run(Thread.java:748)线程结束Process finished with exit code 0 线程互斥同步Java提供了两种锁机制来控制多个线程对共享资源的互斥访问。 JVM实现的synchronized 同步 JDK实现的ReentrantLock 可重入锁 synchronized使用synchronized使用多个方式实现同步。","categories":[],"tags":[{"name":"Java并发","slug":"Java并发","permalink":"http://zswh33.github.io/tags/Java%E5%B9%B6%E5%8F%91/"}]},{"title":"Java并发 1","slug":"Java并发-1","date":"2022-10-19T11:57:25.000Z","updated":"2022-10-20T01:26:52.625Z","comments":true,"path":"2022/10/19/Java并发-1/","link":"","permalink":"http://zswh33.github.io/2022/10/19/Java%E5%B9%B6%E5%8F%91-1/","excerpt":"","text":"https://www.pdai.tech/md/java/thread/java-thread-x-theorty.html 不想看书，这个文章是基于上面文章的再总结。 重排序三种类型：编译器优化的重排序，指令级并行的重排序，内存系统的重排序。 编译器优化的重排序：编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序； 指令级并行的重排序：现代处理器都有采用指令集秉性技术（ILP），这种技术将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序； 内存系统的重排序：由于处理器使用缓存和读写缓冲区，使得加载和存储操作可能在乱序执行。 从Java源代码到最终实际执行指令序列，会经历三种重排序。 JMM的编译器重排序规则会禁止特定类型的编译器重排序； JMM的处理器重排序规则会要求Java再生成指令序列时，插入特定的内存屏障（memory barriers，Intel为memory fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序。 Java如何解决并发问题：JMM（Java内存模型）JMM本质：Java内存模型规范了JVM如何提供按需禁用缓存和编译优化的方法。 理解1： volatile，synchronized和final； Happens-Before规则。 理解2：可见性、有序性、原子性。 原子性即，不可再分的操作 1234x = 10; // 将10赋值给x 为原子性操作y = x; //1. 读取x的值 2. 将值赋值给yx++; //1. 读取x的值 2.将值进行+1操作 3. 将值赋值给xx = x + 1;// 同上一行 可见性在程序运行过程中，对于一个变量： 使用时，将变量从“主存”放到“工作内存”，访问&#x2F;赋值操作优先对工作内存的值进行操作，而不是主存。 在多线程下，不同线程使用不同的工作内存，可能导致变量的更新无法及时同步导致错误。 在java中，将变量用volatile修饰，可以实现变量的可见性。 有序性即，代码有序执行，禁止指令重排。 Happens-Before规则JMM规定了先行发生原则。（即，定义了一些需要正确执行的规则） 单一线程原则 Single Thread Rule 在一个线程内，程序前面的操作先行于发生于后面的操作； 管程锁定规则 Monitor Lock Rule 一个unlock操作先于对同一个锁的lock操作； volatile变量规则 Volatile Variable Rule 对于一个Volatile变量，写操作先于读操作执行。 线程启动规则 Thread Start Rule Thread对象的start()方法调用先于此线程的每一个动作。 线程加入规则 Thread Join Rule Thread对象的结束先于join()方法返回。 线程的结束先于对线程对象的join()方法返回。 线程中断规则 Thread Interruption Rule 对线程的interrupt()方法先于线程对中断的检测； 也就是interrupt()先于interrupted() 对象终结规则 Finalizer Rule 一个对象的构造函数执行先于finalize()方法。 传递性 Transitivity 若操作A先于操作B，操作B先于操作C，则操作A先于操作B。 线程安全不是一个非真即假的命题线程安全不是一个非真即假的命题，按照共享数据安全强弱顺序可以分为：不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。 不可变 不可变的对象一定是线程安全的。多线程环境下，尽量使对象不可变，来满足线程安全。 实现不可变： final、String、枚举类型 Nubmer部分子类，如Long和Double等，BigInteger和BigDecimal等； 注意：AtomicInteger和AtomicLong是可变的。 对于集合类型，可以使用Collections.unmodifiableXXX()方法来实现一个不可变集合。 123456789public class UnmodifiableMap &#123; public static void main(String[] args) &#123; Map&lt;String,String&gt; map = new HashMap&lt;String,String&gt;()&#123;&#123; put(&quot;name&quot;,&quot;ZHangsan&quot;);put(&quot;age&quot;,&quot;12&quot;); &#125;&#125;; Map&lt;String,String&gt; unmodifiableMap = Collections.unmodifiableMap(map); unmodifiableMap.put(&quot;height&quot;,&quot;195&quot;); &#125;&#125; 12345Exception in thread &quot;main&quot; java.lang.UnsupportedOperationException at java.util.Collections$UnmodifiableMap.put(Collections.java:1457) at com.yn.UnmodifiableMap.main(UnmodifiableMap.java:13)Process finished with exit code 1 绝对线程安全 不论运行环境如何，调用者都无需做额外的操作； 相对线程安全 相对线程安全要求保证对这个对象单独的操作是线程安全的，而对于一系列连续的操作需要额外的同步手段来保证正确性。 如：对于Vector的使用，若其中有10个对象，此时有一个线程对Vector进行遍历，另一个线程进行remove，对于第一个线程就会出现ArrayIndexOutOfBoundsException错误。 此时就需要额外的同步手段来保证正确性。 线程兼容 对象本身不是线程安全的，但可以通过调用端正确的使用同步手段来保证对象在并发环境中可以安全的使用。 线程对立 线程对立指的是不论调用端如何采取同步措施，都无法在多线程环境中并发使用的代码。 线程安全的实现互斥同步synchronized和ReentrantLock 互斥同步最主要的问题就是线程阻塞和唤醒带来的性能问题，因此互斥同步也称为阻塞同步。 互斥同步是一种悲观的并发策略，无论共享数据是否会真的出现竞争，它都要进行加锁。 非阻塞同步非阻塞同步，也就是CAS。Compare-And-Swap,CAS,比较并交换。 随着硬件指令集的发展，硬件开始支持一些原子性操作，如：CAS，比较并交换。CAS指令需要有3个操作数，分别是内存地址V，预期值A和新值B，当执行操作时，当V等于A，则将V的值更新为B，否则不断尝试。 非阻塞同步是一种基于冲突监测的乐观并发策略。在多线程下，需要进行操作时，先进行操作，如果没有其他线程争用共享数据，则操作成功，否则不断尝试，直到成功为止。 AtomicInteger中的CAS在JUC包下有AtomicInteger就使用了Unsafe类的CAS操作。 首先是使用： 123456public static void main(String[] args) &#123; AtomicInteger atomicInteger; atomicInteger = new AtomicInteger(0); atomicInteger.getAndIncrement();//自增，这是一个原子性操作 atomicInteger.compareAndSet(2,3);//期待值 目标值&#125; 1234public final int getAndIncrement() &#123; return unsafe.getAndAddInt(this, valueOffset, 1);&#125;//AtomicInteger中的getAndIncrement用到了Unsafe类的方法 123456789//获得并设置 var1为变量 var2为期望值，var4为目标值public final int getAndSetInt(Object var1, long var2, int var4) &#123; int var5; do &#123; var5 = this.getIntVolatile(var1, var2); &#125; while(!this.compareAndSwapInt(var1, var2, var5, var4)); return var5;&#125; 12public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);//这是一个native方法 ABA问题如果一个变量在初次读取的时候是A值，此时另一个线程将值改为B，又改为A，CAS操作就会认为该值并没有被改变过，这样就会影响CAS操作的正确性。 JUC提供了一个带有标记的原子引用类AtomicStampedReference来解决这个问题，AtomicStampedReference为变量添加了版本功能，当值发生改变，版本就会更新，通过检测版本，就可以观察到变量是否被改变。 在现实中大部分情况下，ABA问题都不会影响并发的正确性， 如果要解决ABA问题，改用传统的互斥同步可能比原子类更高效。 无同步方案要保证线程安全，并不是一定就要同步。 如果方法本来就不涉及共享数据，则不需要同步措施去保证正确性。 栈封闭 局部变量线程私有，多个线程访问同一个方法的局部变量，不会出现线程安全问题。 线程本地存储 java.lang.ThreadLocal可以为每个线程实现线程本地存储功能，每个线程访问ThreadLocal中的对象都会调用到只属于当前线程的对象。 ThreadLocal理论上并不是用来解决多线程并发问题的。 其他注意事项：ThreadLocal有内存泄漏情况，应该尽可能在每次使用ThreadLocal后手动调用remove()，以避免出现ThreadLocal内存泄露风险。 可重入代码 若一个程序或子程序可以安全地被并行执行，则称为可重入。 （e..栈封闭？） 其他 虚拟机会优化掉很大一部分不必要的加锁、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程的需要唤醒等操作。","categories":[],"tags":[{"name":"Java并发","slug":"Java并发","permalink":"http://zswh33.github.io/tags/Java%E5%B9%B6%E5%8F%91/"}]},{"title":"数据结构","slug":"数据结构","date":"2022-10-18T07:11:57.000Z","updated":"2022-11-13T14:32:11.190Z","comments":true,"path":"2022/10/18/数据结构/","link":"","permalink":"http://zswh33.github.io/2022/10/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","excerpt":"","text":"静态链表 right为链表每个元素的后继下标； 双向静态链表 双向链表，有前驱有后继。 8的后继为0，表示这是一个循环链表 ​ 56 9 12 23 49 20 16 62 0 &gt; 1 &gt;2&gt;3&gt; 4 &gt;5 &gt;6 &gt;7 &gt; 8 &gt; 0 树n个节点可以构成不相似的二叉树的数量有： bn表示n个结点构成的不同形态的二叉树的数量。$$b_n&#x3D;\\begin{cases}b_0&#x3D;1\\b_n&#x3D;\\sum_{i&#x3D;0}^{n-1}b_ib_{n-i-1}\\end{cases}$$结论：$$b_n &#x3D; \\frac{1}{n+1}·C^n_{2n}$$ 图vertex n.顶点 重连通图即，任意两个顶点之间含有不止一条通路，这个图就称为重连通图； 关节点：如果删除某个顶点及其相关联的边后，原来的图被分割为两个及以上的联通分量，则称该顶点为无向图的一个关节点。 判断一个重连通图判断图中是否有关节点，没有则表示图为重连通图。 拓扑算法n: 拓扑序列 拓扑排序：从某个集合上的一个偏序得到该集合上的一个全序，这个操作称之为拓扑排序。 Dijkstra算法带权单源最短路径算法。 图来源：https://blog.csdn.net/xiaoxi_hahaha/article/details/110257368 Floyd算法带权最短路径 查找表静态查找表和动态查找表静态查找表：只进行查找操作，不改动表中数据元素； 动态查找表：在查找的同时进行数据的增加和删除操作。 关键字表中元素的属性，可以作为关键字。比如学生有姓名、学号、年龄等属性，这些都可以作为关键字。 主关键字和次关键字主关键字：唯一标识一个数据元素，比如学号； 次关键字：与主关键字相反，如姓名、年龄。 一些名词 静态查找树 次优查找树 二叉排序树 哈希表http://c.biancheng.net/view/3437.html 哈希函数 直接定值法：H(key) = key 或 H(key) = a * key + b 数字分析法：取出每个值中不同部分较多的地方作为哈希地址； 平方取中法：对关键字进行平方操作，取中间几位作为哈希地址； 折叠法：将关键字分为几个部分，然后取这几部分的叠加和作为哈希地址； 除留余数法：若已知哈希表长度m，取一个不大于m的数字p，然后对关键字进行取余运算 H(key) = key % p 随机数法：取关键字的一个随机函数值作为哈希地址，即H(key) = random(key); 选择一个哈希函数需要注意的地方： 若关键字长度不等，可以用随机数法； 关键字位数多，折叠法或数字分析法； 关键字位数较短，平方取中法； 哈希表大小已知，可以选择除留余数法； 关键字分布情况； 查找表的查找频率； 计算哈希函数需要的时间； 处理冲突 开放定址法：H(key) &#x3D; [ H(key) + d ] MOD m; $$H(key) &#x3D; [ H(key) + d ]\\ %\\ m$$ m为哈希表表长 d的取值 线性探测法：d &#x3D; 1,2,3, …, m-1 二次探测法：d&#x3D;12, -12, 22 , -22, 32 … 伪随机数探测法：d&#x3D;伪随机数 再哈希法： 若发生冲突，再使用另一个哈希函数进行计算，直到冲突不再发生； 链地址法 将处于一个地址的值放在一个链表中； 建立一个公共溢出区 建立两张表，一张基本表，一张溢出表； 将哈希函数结果产生冲突，就将数据放到公共溢出区； B-树 (B-Tree)名字这里不是B减树，B-树，指的就是B树。换言之，B树，就是B-树。 B+树是B树的plus，不存在B减树； 满足下列要求的m叉树 树中每个结点至多有m个孩子结点（即，至多有m-1个关键字） 每个结点的结构如下： \\ \\ 除根节点外，其他结点至少有⌈m/2⌉个孩子结点； 若根节点不是叶子节点，则根节点至少有两个孩子结点，（即根节点没有只有一个孩子结点的情况）； 所有的叶子节点都在同一层上，即B树是所有节点平衡因子均等于0的多路查找树。 除根节点外，其他结点都包含n个key，这里⌈m/2⌉-1 &lt;= n &lt;= m-1$$\\lceil m&#x2F;2 \\rceil - 1 \\leq n \\leq m-1$$","categories":[],"tags":[{"name":"Note","slug":"Note","permalink":"http://zswh33.github.io/tags/Note/"}]},{"title":"Effective Java 2","slug":"Effective-2","date":"2022-10-17T00:38:50.000Z","updated":"2022-10-17T02:27:09.238Z","comments":true,"path":"2022/10/17/Effective-2/","link":"","permalink":"http://zswh33.github.io/2022/10/17/Effective-2/","excerpt":"","text":"6. 避免创建不必要的对象最好能重用单个对象，而不是每次需要的时候就创建一个相同功能的新对象； 可以提高效率。 String避免多次创建对象错误的做法： 1String s = new String(&quot;It&#x27;s a text.&quot;); 每次执行的时候都会创建一个String对象，而且参数(&quot;It&#39;s a text.&quot;)本来就是一个对象，这样使用会影响效率； 如果在一个频繁调用的方法中出现，就会创建成千上万个对象； 正确的做法： 1String s= &quot;It&#x27;s a text.&quot;; 这样就只使用了一个String实例，而不是每次运行都会创建一个示例； 在JVM里这样做，对于不同的String引用，如果它们的字符串是相同的，它们对应对象就是一样的，而不是多个对象。 对于提供了静态工厂方法的类，一般优先使用静态工厂方法而非构造器。如使用Boolean.valueOf()而不是Boolean()。 有些对象创建成本较高，如果内容不变，可以考虑将这些对象缓存下来多次使用。 比如Pattern实例； Pattern实例创建成本较高，若多次创建对性能影响较大； 可以考虑将正则表达式显式地编译成一个Pattern实例，并让他成为类初始化的一部分； 1private final static Pattern pattern = Pattern.compile(&quot;&gt;(.*)&lt;\\/div&gt;&quot;) 优先使用基本类型而非装箱基本类型使用基本类型比装箱基本类型效率较高，因为装箱基本类型需要创建对象； 错误的做法： 123456789public class 使用基本数据类型而非装箱基本类型 &#123; public static void main(String[] args) &#123; Long res = 0L; for (int i = 0 ; i &lt; Integer.MAX_VALUE ; i++)&#123; res += i; &#125; System.out.println(res); &#125;&#125; 正确的做法：只需要将Long改为long就可。 123456789public class 使用基本数据类型而非装箱基本类型 &#123; public static void main(String[] args) &#123; long res = 0L; for (int i = 0 ; i &lt; Integer.MAX_VALUE ; i++)&#123; res += i; &#125; System.out.println(res); &#125;&#125; 7. 消除过期的对象引用使用栈来学习“无意识的内存泄露”。12345678910111213141516171819202122232425262728293031public class Stack &#123; private Object[] elements;//栈内引用 private int size = 0;//当前大小 private static final int DEFAULT_INITIAL_CAPACITY = 16;//默认初始化容量 public Stack()&#123; elements = new Object[DEFAULT_INITIAL_CAPACITY]; &#125; //向栈中添加内容 public void push(Object e)&#123; ensureCapacity(); elements[size++] = e; &#125; //从栈中取出内容 public Object pop()&#123; if (size==0)throw new EmptyStackException(); return elements[--size]; //当size--，旧的对象并没有被清理，如果对象很大且很多，就会引发内存泄露 &#125; //确保容量，如果数组大小不够了，就扩容。 public void ensureCapacity()&#123; if (elements.length == size)&#123; elements = Arrays.copyOf(elements,2*size+1); &#125; &#125;&#125; 如果栈内元素先push，然后pop，旧的对象并没有被清理，且由于被引用，不会被gc清理掉。 有概率引发内存泄漏； 解决方法： 123456public Object pop()&#123; if (size==0)throw new EmptyStackException(); Object o = elements[--size];//先取出对象 elements[size] = null;//将数组内引用清除 return o;&#125; 先取出对象，将数组内引用清除，这样就不会引用对象，最后返回对象； 若对象在后续过程中使用结束，对象将会被gc清理，而不是无法被清理。 为缓存设置生命周期监听器和其他回调 为API回调使用WeakHashMap 如果实现了一个API，客户端在这个API进行注册回调，却没有显式地取消注册，这样的注册会逐渐堆积起来，引发可能的内存泄漏； 确保回调被回收的方法就是只保存他们的弱引用，比如将他们保存成WeakHashMap的键。","categories":[],"tags":[{"name":"Effective Java","slug":"Effective-Java","permalink":"http://zswh33.github.io/tags/Effective-Java/"}]},{"title":"Effective Java 1","slug":"Effective-Java-1","date":"2022-10-07T06:48:48.000Z","updated":"2022-10-07T11:14:20.426Z","comments":true,"path":"2022/10/07/Effective-Java-1/","link":"","permalink":"http://zswh33.github.io/2022/10/07/Effective-Java-1/","excerpt":"","text":"1. 用静态工厂方法代替构造器说明在方法内部添加一个静态方法，用于获取一个对象，代替构造器的功能； 比如，在boolean包装Boolean类中，就有valueOf方法可以代替构造方法获得一个Boolean对象； 123public static Boolean valueOf(boolean b) &#123; return (b ? TRUE : FALSE);&#125; 优势 静态方法有名字，可以指定一个功能作为方法名； 实现对象重用，优化程序运行； 在对象使用结束后，可以将对象缓存起来，若下次调用可以再次使用； 相对对象重用，创建一个新的对象损耗可能会更大； 在情况允许时，尽量多地使用对象重用，减少创建对象造成额外损耗； 如Boolean类：Boolean类加载结束后，默认会创建两个Boolean对象，分别表示true和false，在使用静态工厂创建对象时，直接将代表true或false的对象返回，以节约内存使用和程序效率。 123456789101112131415161718public final class Boolean implements java.io.Serializable, Comparable&lt;Boolean&gt;&#123; //默认创建两个Boolean对象，用于表示TRUE和FALSE public static final Boolean TRUE = new Boolean(true); public static final Boolean FALSE = new Boolean(false); // 包装了boolean类，这里存值 private final boolean value; // 构造方法新创建了一个Boolean对象 public Boolean(boolean value) &#123; this.value = value; &#125; //使用valueOf方法，直接返回Boolean类加载时创建的两个静态对象，无需再次创建对象。 public static Boolean valueOf(boolean b) &#123;return (b ? TRUE : FALSE);&#125; public static Boolean valueOf(String s) &#123; return parseBoolean(s) ? TRUE : FALSE; &#125;&#125; 依据不同的参数，可以返回任何子类的对象，也可以返回不同的对象； 应用： 静态方法可以返回对象，而无需将对象的类设为公有的； 静态方法可以通过接口返回不同的对象。EnumSet没有构造器，只能通过静态工厂创建对象，在OpenJDK实现中，EnmuSet的实现有两种类型：RegalarEumSet和JumboEnumSet；当枚举元素数量等于小于64时，静态工厂方法返回RegalarEumSet对象；当枚举元素数量大于64时，静态工厂方法返回JumboEnumSet对象。（对于调用者，无需知道背后的实现原理，直接使用就好；对于EnumSet开发者，此做法用于代码优化。） 方法返回的对象所属的类，在编写静态工厂方法的类时可以不存在； 如mysql和JDBC； 缺点 类如果不包含public的构造器，则不能被继承； 静态工厂方法需要程序员主动去寻找，而非构造方法可以直接使用； 示例： 1234567891011class Apple &#123; private String type; private String status; //构造方法名与类名相同，可以直接使用 public Apple(String type, String status) &#123; this.type = type; this.status = status; &#125; //静态工厂方法需要在API中寻找，没有构造方法方便 public static Apple getNewApple()&#123;return new Apple(&quot;redApple&quot;,&quot;fresh&quot;);&#125;&#125; 一些惯例 from，从别的类型进行转换，只有一个参数； of，将多个参数合并； 12345678//将多个参数合并到一起public Set&lt;Apple&gt; of(String ...colors)&#123; Set&lt;Apple&gt; apples = new HashSet&lt;&gt;(); for (String s : colors) &#123; apples.add(new Apple(&quot;Red&quot;)); &#125; return apples;&#125; valueOf，也是类型转换； createInstance或getInstance，通过参数获取一个对象，参数可以与成员变量不同； createInstance或netInstance，保证每次返回一个新创建的实例； getInstance一般用在单例模式。 getType（这里可以是getApple），与getInstance一致； newType，与netInstance类似； type，getType和newType的简化版。 2. 遇到多个构造器参数，可以考虑使用构建器（Builder）说明若一个类有多个参数，且对象使用构建器进行创建； 有些参数有些时候不需要输入，但构造器中必须填入一个值； JavaBeans模式，即一堆setter方法，这样可以解决上面的问题，但JavaBeans模式有严重的缺点，在构造过程中JavaBean可能处于不一致状态，即线程不安全。 这个时候，就可以考虑使用建造者Builder模式 12345678910111213141516171819202122232425262728293031323334public class 建造者模式 &#123; public static void main(String[] args) &#123; Cat cat = new Cat.Builder(&quot;小黑&quot;) .age(12).color(&quot;White&quot;).build(); System.out.println(cat); &#125;&#125;class Cat&#123; private String name; private int age; private String color; private String owner; public static class Builder&#123; //必要参数 private String name; //可选参数 private int age; private String color; private String owner; public Builder(String name) &#123;this.name = name;&#125; public Builder age(int val)&#123;age=val;return this;&#125; public Builder color(String val)&#123;color=val;return this;&#125; public Builder owner(String val)&#123;owner=val;return this;&#125; public Cat build()&#123;return new Cat(this);&#125; &#125; public Cat(Builder builder) &#123; owner = builder.owner; color = builder.color; age = builder.age; name = builder.name; &#125;// toString &#125; Builder模拟了具有名字的可选参数，这样的客户端易于编写，易于阅读； 示例 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//这里先创建一个抽象类FriedRice//然后分别创建两个类继承FriedRice，分别为FriedRiceWithHam和FriedRiceWithEgg//fried rice 炒饭 可以添加 老干妈LaoGanMa、辣条LaTiao、再加一个鸡蛋Egg等// ham 火腿 egg鸡蛋//FriedRiceWithHam 火腿炒饭，可以有：大、中、小 三种 LARGE MEDIUM SMALL//FriedRiceWithEgg 蛋炒饭，spicy辣度 可以选择：little微辣 general中辣 very特辣//具体开发中不要使用中文，也不要使用拼音//先整一个抽象类FriedRiceabstract class FriedRice&#123; //额外要加的东西 public enum Ingredient&#123;老干妈,辣条,Egg&#125;//实际开发不要使用中文 private Set&lt;Ingredient&gt; ingredientSet; abstract static class Builder&lt;T extends Builder&lt;T&gt;&gt;&#123; EnumSet&lt;Ingredient&gt; ingredients = EnumSet.noneOf(Ingredient.class);//默认没有配料 public T addIngredient(Ingredient val)&#123;ingredients.add(val);return self();&#125;//添加配料 public abstract FriedRice build(); protected abstract T self(); &#125; FriedRice(Builder&lt;?&gt; builder)&#123; ingredientSet = builder.ingredients.clone(); &#125;&#125;//创建一个FriedRiceWithHam火腿炒饭@ToString(callSuper = true)//是Lombok插件的注解，可以自动生成toString方法，文章主要讲解内容不包含这部分，忽略就好class FriedRiceWithHam extends FriedRice&#123; public enum Size&#123;SMALL,MEDIUM,LARGE&#125; private Size size;//大小 public static class Builder extends FriedRice.Builder&lt;Builder&gt;&#123; private Size size; public Builder(Size size)&#123;this.size = size;&#125; @Override public FriedRice build() &#123;return new FriedRiceWithHam(this);&#125; @Override protected Builder self() &#123;return this;&#125; &#125; FriedRiceWithHam(Builder builder) &#123; super(builder); this.size = builder.size; &#125;&#125;//创建一个FriedRiceWithEgg鸡蛋炒饭@ToString(callSuper = true)//是Lombok插件的注解，可以自动生成toString方法，文章主要讲解内容不包含这部分，忽略就好class FriedRiceWithEgg extends FriedRice&#123; public enum Spicy&#123;LITTLE,GENERAL,VERY&#125; private Spicy spicy; public static class Builder extends FriedRice.Builder&lt;Builder&gt;&#123; private Spicy spicy; public Builder(Spicy spicy)&#123;this.spicy = spicy;&#125; @Override public FriedRice build() &#123;return new FriedRiceWithEgg(this);&#125; @Override protected Builder self() &#123;return this;&#125; &#125; FriedRiceWithEgg(Builder builder) &#123; super(builder); spicy = builder.spicy; &#125;&#125; 使用 12345678910public class Builder模式也适用于类层次结构 &#123; public static void main(String[] args) &#123; //创建一个鸡蛋炒饭，中辣，添加老干妈 FriedRice friedRiceWithEgg = new FriedRiceWithEgg.Builder(FriedRiceWithEgg.Spicy.GENERAL) .addIngredient(FriedRice.Ingredient.老干妈).build(); //创建一个火腿炒饭，大份，添加鸡蛋 FriedRice friedRiceWithHam = new FriedRiceWithHam.Builder(FriedRiceWithHam.Size.LARGE) .addIngredient(FriedRice.Ingredient.Egg).build(); &#125;&#125; 3. 用私有构造器或枚举类型强化Singleton属性Singleton，即单例模式；对于一个类，只会被实例化一次，后续通过静态方法获取对象也只能获取到这一个对象，不会再次创建新的对象。 创建一个Singleton，有两种方式私有构造器将构造器私有化，然后通过getInstance方法创建并获取对象。 发展默认情况下，可以通过以下方式实现单例模式。12345678//Chopsticks n.筷子//这里假定筷子只能有一根//这里创建一个单例对象class Chopstick&#123; private static final Chopstick INSTANCE = new Chopstick();//类加载后，自动创建一个Chopstick对象， private Chopstick()&#123;&#125;//构造器私有化，禁止二次创建 public static Chopstick getInstance()&#123;return INSTANCE;&#125;//获取实例&#125; 但是，这个单例是可以通过反射进行破坏；12345678910111213141516public static void main(String[] args) throws Exception &#123; Chopstick instance = Chopstick.getInstance();//第一个实例对象 //第二个实例对象 Class&lt;?&gt; aClass = Class.forName(&quot;com.yn.study.chapter1.Chopstick&quot;);//获取Class对象 Constructor&lt;?&gt; declaredConstructor = aClass.getDeclaredConstructor();//获取Constru对象 declaredConstructor.setAccessible(true);//跳过private检查 Chopstick chopstick = (Chopstick) declaredConstructor.newInstance();//创建实例对象 System.out.println(instance); System.out.println(chopstick); /**输出结果如下： * com.yn.study.chapter1.Chopstick@7f31245a * com.yn.study.chapter1.Chopstick@6d6f6e28 * 表示这两个对象不是同一个对象 */&#125; 所以，可以在构造方法里面添加判断，让第二次创建过程抛出错误来解决破坏；12345class Chopstick&#123; private static final Chopstick INSTANCE = new Chopstick();//类加载后，自动创建一个Chopstick对象， private Chopstick() &#123;if (INSTANCE!=null)throw new Error(&quot;请不要二次创建对象&quot;);&#125;//构造器私有化，禁止二次创建 public static Chopstick getInstance()&#123;return INSTANCE;&#125;//获取实例&#125; 如果要使对象变得可序列化，必须声明readResolve方法如果要使对象变得可序列化，仅仅在声明中加上implements Serializable是不够的，为了维护Singleton，必须声明所有实例域是transient（瞬时）的，并声明readResolve方法； 否则，每当反序列化一个对象，都会创建一个新的对象； 12345678910111213141516171819202122232425public static void main(String[] args) throws Exception &#123; //单例破解方案——序列化：将对象存储于文件中，然后从文件中读取 //创建一个单例对象 Chopstick chopstick1 = Chopstick.getInstance(); //将对象写入文件 File file = new File(&quot;Chopstick.dat&quot;); FileOutputStream os = new FileOutputStream(file); ObjectOutputStream oos = new ObjectOutputStream(os); oos.writeObject(chopstick1); oos.close();os.close(); //将对象从文件中读取 FileInputStream is = new FileInputStream(file); ObjectInputStream ois = new ObjectInputStream(is); Chopstick chopstick2 = (Chopstick) ois.readObject();//第二个实例化对象 System.out.println(chopstick1); System.out.println(chopstick2); /** * 输出结果 * com.yn.study.chapter1.Chopstick@2503dbd3 * com.yn.study.chapter1.Chopstick@7ef20235 * 表示这两个对象不是一个对象 */&#125; 声明readResolve方法 1private Object readResolve()&#123;return INSTANCE;&#125; 这样，上面的结果获得的将是同一个对象。 12com.yn.study.chapter1.Chopstick@2503dbd3com.yn.study.chapter1.Chopstick@2503dbd3 使用123456789//Chopsticks n.筷子//这里假定筷子只能有一根//这里创建一个单例对象class Chopstick implements Serializable &#123; private static final Chopstick INSTANCE = new Chopstick();//类加载后，自动创建一个Chopstick对象， private Chopstick() &#123;if (INSTANCE!=null)throw new Error(&quot;请不要二次创建对象&quot;);&#125;//构造器私有化，禁止二次创建 public static Chopstick getInstance()&#123;return INSTANCE;&#125;//获取实例 private Object readResolve()&#123;return INSTANCE;&#125;//写readResolve方法，防止反序列化破坏单例&#125; 枚举类枚举本就是一个单例对象，而且不可破坏。 1234enum ChopstickPlus&#123; INSTANCE; ChopstickPlus getInstance()&#123;return INSTANCE;&#125;&#125; 4. 通过私有构造器，使得类不可实例化有些类只包含静态方法或静态域，这样的类不希望会被实例化，因为这些类被实例化是没有意义的； 这里我表示疑惑：应该一般情况下没有人会去尝试实例化一个只有静态方法的类，嗯..但是…，书上说有一些时候会无意识的初始化该类？？下面继续记笔记。 对于没有特别声明构造器的类，其构造器默认是public的， 这里可以通过将构造器私有化，来避免不必要的实例化。 同样，为避免通过反射创建对象，可以在构造方法里添加抛出错误，防止类实例化。 123456//EasyMath 一个简单的，无意义的，仅用于学习的，计算类class EasyMath&#123; public static long sum(long a,long b)&#123;return a+b;&#125;//一个求和的静态方法 //不希望不必要的工具类实例化 private EasyMath()&#123;throw new AssertionError();&#125;&#125; 但这样有个缺点：这个类不能有父类。 5. 优先考虑依赖注入引用资源这里..就只写个标题吧。。 详见Effective Java 第三版 P16页。","categories":[],"tags":[{"name":"Effective Java","slug":"Effective-Java","permalink":"http://zswh33.github.io/tags/Effective-Java/"}]},{"title":"C++ 1","slug":"C-1","date":"2022-10-06T15:00:05.000Z","updated":"2022-10-18T00:51:27.146Z","comments":true,"path":"2022/10/06/C-1/","link":"","permalink":"http://zswh33.github.io/2022/10/06/C-1/","excerpt":"","text":"C++在C语言的基础上扩充了一些特有的内容：bool类型、重载函数、模板、STL等 头文件C语言中头文件要加“.h”后缀，C++头文件不需要加后缀； 一些替换： C C++ string.h cstring math cmath iostream输入输出头文件； Input 输入 Output 输出 stream流 命名空间using namespace &lt;命名空间&gt; C++标准库中所有标识符定义在std命名空间中； std standard adj.标准的 使用： 1using namespace std; 输入输出&lt;&lt; 输入 &gt;&gt;输出 预定义的标准流对象cin是isream类的对象，用于标准输入； cout是ostream类的对象，用于标准输出； cerr和clog是ostream类的对象，处理标准错误信息。","categories":[],"tags":[{"name":"C","slug":"C","permalink":"http://zswh33.github.io/tags/C/"}]},{"title":"Git Hook 学习使用","slug":"Git-Hook-学习使用","date":"2022-10-05T12:32:58.000Z","updated":"2022-10-11T00:53:00.382Z","comments":true,"path":"2022/10/05/Git-Hook-学习使用/","link":"","permalink":"http://zswh33.github.io/2022/10/05/Git-Hook-%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8/","excerpt":"","text":"简介Git能够做到进行某些操作后，触发一些自定义脚本，这个功能叫做Git Hook（Git钩子）。 要实现这个功能，只需要将需要执行的脚本按照指定文件名放入项目目录的.git\\hooks文件夹下； 使用 默认情况下，.git/hooks里会有一堆后缀为.sample的文件，这些都是git提供的一些示例文件，只需要将.sample后缀去掉，就可以使这些脚本生效； 即： 向.git/hooks文件夹放一些没有.xxx后缀的文件，文件名与要绑定的操作相关，详细见下面； 在文件里写入要执行的脚本，脚本可以使用Linux Shell语言，也可以使用Ruby或Python语言； 这样就实现了Git Hook功能：进行指定的Git操作，自动触发写好的脚本； 一个示例这里先写一个示例进行解释。 首先到 文件名与操作如下： pre-commit 在commit之前会运行这个脚本，可以使用这个脚本实现代码检查；可以使用 prepare-commit-msg commit之前， 第一个git服务器 首先找一个Linux系统（e…嗯 ），安装应用git； 1$ sudo apt install git # ubuntu发行版本Linux安装git命令 阿里云使用yum包管理器下使用以下命令 1yum install git 为git添加用户和用户组 12$ groupadd git$ useradd git -g git 创建一个证书登录 参考文献https://www.runoob.com/git/git-server.html","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://zswh33.github.io/tags/git/"}]},{"title":"Git 1","slug":"Git-1","date":"2022-09-29T08:32:44.000Z","updated":"2022-09-29T13:24:19.013Z","comments":true,"path":"2022/09/29/Git-1/","link":"","permalink":"http://zswh33.github.io/2022/09/29/Git-1/","excerpt":"","text":"https://www.runoob.com/git 介绍Git是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目； Git工作区、暂存区、版本库工作区：在电脑里看到的目录，本地文件； 暂存区：放在.git目录下的index文件（.git&#x2F;index），暂存区有时也叫索引； 版本库：工作区有一个隐藏目录.git,不算工作区，是Git的版本库。 HEAD是指向master分支的一个游标； objects是git的对象库，位于**.git&#x2F;objects**下，包含了创建的各种对象和内容； 当对工作区修改或新增文件时执行git add命令， 暂存区的目录树会被更新； 工作区修改或新增的内容被写入到对象库的一个新的对象中，而该对象的ID被记录在暂存区的文件索引中； 当执行git commit提交操作时，暂存区的目录树写到版本库中，master分支会做相应的更新； 执行git reset HEAD命令，暂存区的目录树会被重写，被master分支指向的目录树所替换，工作区不受影响； 执行**git rm –cached &lt;file&gt;**命令，会直接从暂存区删除文件，工作区不做改变； 执行**git checkout .或git checkout – &lt;file&gt;**命令，会用暂存区全部或指定的文件替换工作区的文件；","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://zswh33.github.io/tags/git/"}]},{"title":"Nginx 2","slug":"Nginx-2","date":"2022-09-26T11:57:18.000Z","updated":"2022-09-26T13:23:37.146Z","comments":true,"path":"2022/09/26/Nginx-2/","link":"","permalink":"http://zswh33.github.io/2022/09/26/Nginx-2/","excerpt":"","text":"《深入理解Nginx：模块开发与架构解析（第2版） 》 准备工作 epoll是Linux上处理大并发网络连接的利器，准备一个Linux内核2.6以上版本的操作系统； 使用uname -a查询Linux内核版本 12yyn@yyn:~$ uname -aLinux yyn 5.15.0-47-generic #51-Ubuntu SMP Thu Aug 11 07:51:15 UTC 2022 x86_64 x86_64 x86_64 GNU/Linux 软件要求 GCC编译器，用于编译Nginx源代码文件 （yum install -y gcc）； G++编译器，后续用于编写Nginx HTTP模块（yum install -y gcc-c++）； PCRE库（Perl兼容正则表达式），支持正则表达式，为Nginx提供正则表达式支持（yum install -y pcre pcre-devel）；pcre-devel是使用PCRE做二次开发时所需要的开发库，包括头文件等； zlib库用于对HTTP包的内容做gzip的压缩；允许在nginc.conf配置了gzip on，并指定对于某些类型（content-type）的HTTP响应使用gzip来进行压缩以减少网络传输量；（yum install -y zlib zlib-devel） OpenSSL开发库，用于让Nginx支持SSL协议的HTTP；也提供MD5、SHA1等散列函数；（yum install -y openssl openssl-devel） 目录 Nginx的源代码目录 存放Nginx的源代码文件，第三方或自己所写的模块源代码文件； Nginx编译阶段产生的中间文件 用于将configure命令执行后所生成的源文件及目录， 以及make命令执行后生成的目标文件和最终连接成功的二进制文件 默认情况下，configure命令会将该目录命名为objs，并放在Nginx源代码目录下 部署目录 存放Nginx服务运行期间所需要的二进制文件、配置文件等；默认位于**&#x2F;usr&#x2F;local&#x2F;nginx**下； 日志文件 内核参数优化 Linux内核参数考虑是最通用的场景，不符合Web服务器的定义； 所以需要修改Linux内核参数，使得Nginx获得更高的性能； Nginx作为静态Web服务器、反向代理服务器或是提供图片缩略图功能的服务器时，内核参数的调整都是不同的； 可以通过修改&#x2F;etc&#x2F;sysctl.conf来修改内核参数。 最常用的配置 123456789101112131415fs.filemax = 999999net.ipv4.tcp tw_reuse = 1net.ipv4.tcp keepalive_time = 600net.ipv4.tcp_fin_timeout = 30net.ipv4.tcp_max_tw_buckets = 5000net.ipv4.ip_local_port_range = 1024 61000net.ipv4.tcp_rmem = 4096 32768 262142net.ipv4.tcp_wmem = 4096 32768 262142net.core.netdev_max_backlog = 8096net.core.rmem_default = 262144net.core.wmem_default = 262144net.core.rmem_max = 2097152net.core.wmem_max = 2097152net.ipv4.tcp_syncookies = 1net.ipv4.tcp_max_syn.backlog = 1024 修改后使用sysctl-p命令，使上述修改生效。 参数解释： file-max：进程可以同时打开的最大句柄数，这个参数直接限制最大并发连接数，根据实际情况配置 tcp_tw_reuse：这个参数设置为1，表示允许TIME-WAIT状态的socket重新用于新的TCP连接； tcp_keepalive_time：表示当keepalive启用时，TCP发送keepalive消息的频率；默认是2小时，若设置得更小一些，可以更快地清理无效的连接； tcp_fin_timeout：当服务器主动关闭连接时，socket保持在FIN-WAIT-2状态的最大时间； tcp_max_tw_buckets：操作系统允许TIME_WAIT套接字数量的最大值，若超过这个数字，TIME_WAIT套接字将立刻被清除并打印警告信息；参数默认为180000，过多TIME_WAIT套接字会使Web服务器变慢； tcp_max_syn_backlog：表示TCP三次握手建立阶段接收SYN请求队列的最大长度，默认为1024，设置得大一些可以使Nginx繁忙来不及accept新连接的情况时，Linux不至于丢失客户端发起的连接请求； ip_local_port_range：定义了UDP和TCP连接中本地端口的取值范围。 net.ipv4.tcp_rmem：定义了TCP接收缓存的最小值、默认值和最大值； net.ipv4_wmem：定义了TCP发送缓存的最小值、默认值和最大值； netdev_max_backlog：当网卡接收数据包的速度大于内核处理的速度时，会有一个队列保存这些数据包；这个参数表示该队列的最大值； rmem_default：这个参数表示内核套接字接收缓存区默认的大小； wmem_default：这个参数表示内核套接字发送缓存区默认的大小； rmem_max：这个参数表示内核套接字接收缓存区的最大大小； wmem_max：这个参数表示内核套接字发送缓存区的最大大小。 注意： 滑动窗口的大小与套接字缓存区会在一定程度上影响并发连接的数目；每个TCP连接都会为维护TCP滑动窗口而消耗内存，这个窗口会根据服务器的处理速度收缩或扩张 参数wmem_max的设置，需要平衡物理内存的总大小，Nginx并发处理的最大链接数量而决定（由nginx.conf中的work_processes和worker_connections参数决定）； 滑动窗口过小会影响大数据量的传输速度； rmem_default、wmem_default、rmem_max、wmem_max这4个参数设置要根据业务特性以及实际的硬件成本综合考虑。 tcp_syncookies：该参数与性能无关，用于解决TCP的SYN攻击。 p31页 1.3.5获取Nginx源码。","categories":[],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://zswh33.github.io/tags/Nginx/"}]},{"title":"Redis 6 Stream消息队列","slug":"Redis-6","date":"2022-09-23T08:10:47.000Z","updated":"2022-09-29T01:25:03.202Z","comments":true,"path":"2022/09/23/Redis-6/","link":"","permalink":"http://zswh33.github.io/2022/09/23/Redis-6/","excerpt":"","text":"Stream消息队列https://pdai.tech/md/db/nosql-redis/db-redis-data-type-stream.html Stream是一个新的强大的支持多播的可持久化的消息队列。 Stream结构 consumer Group：消费组，使用XGROUP CREATE创建，一个消费组有多个消费者，这些消费者之间是竞争关系； last_delivered_id：游标，每个消费组会有个游标last_delivered_id，任意一个消费者读取了消息都会使游标last_delivered_id往前移动； Pending Entries List：pending_ids。维护并存放消费者读取消息的状态（消费者是否已经向服务器回应ACK）；pending_ids记录了当前已被客户端读取的消息，但还没有ack的消息；一旦某个消息被ack，这个队列会将消息id移除，表示消费者收到了该消息；用于确保客户端消费了消息一次，而不是在网络传输途中丢失了没处理。 消息ID：即Stream创建Entry时会生成的ID。 格式：timestampInMillis-sequence 12345567-9 毫米时间戳-序号； 序号为在同一时间戳内生成的消息的序号，用于区分在同一时间戳生成的多个消息； 格式必须为 整数-整数，后面加入的消息ID必须大于前面的消息ID； 消息内容：消息内容就是Entry的键值对； 生产者命令XADD：添加消息到末尾； XTRIM：对流进行修剪； XDEL：删除消息； XLEN：获取流包含的元素数量； XRANGE：获取消息列表； xxxxxxxxxx http { include mime.types; default_type application&#x2F;octet-stream; upstream yupstream{ # 服务器资源 server 127.0.0.1:8080 weight&#x3D;1; # 权重为1 server 127.0.0.1:8081 weight&#x3D;1; } server{ listen 801; server_name localhost; # 代理​​​ # 根目录请求 location &#x2F; { root html; index index.html,index.htm; proxy_pass http://yupstream; # 反向代理 } location &#x2F;admin { } }​}​perl XREAD：以阻塞或非阻塞方式获取消息列表。 消费组消费 使用示例XGROUP CREATE 创建消费者组 XREADGROUP GROUP 读取消费组中的消息 XACK 将消息标记为已处理 XGROUP SETID 为消费者组设置新的最后递送消息ID XGROUP DELCONSUMER 删除消费者 XGROUP DESTROY 删除消费者组 XPENDING 显示待处理消息的相关信息 XCLAIM 转移消息的归属权 XINFO 查看流和消费者组的相关信息 XINFO GROUPS 查询组信息 XINFO STREAM 打印流信息 XINFO CONSUMERS 组成员信息 创建组&#x2F;查询信息1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162127.0.0.1:6379&gt; xadd st1 * apple 1 banana 23&quot;1664179267483-0&quot;127.0.0.1:6379&gt; xadd st1 * apple 12 banana 2 # 为st1添加两个消息&quot;1664179271399-0&quot;127.0.0.1:6379&gt; xgroup create st1 g1 0-0 # 为st1创建一个消费者组g1，从0-0开始消费OK127.0.0.1:6379&gt; xgroup create st1 g2 $ # 为st1创建一个消费者组g2，仅获取最新的消息OK127.0.0.1:6379&gt; xinfo stream st1 # 获取st1的stream信息 1) &quot;length&quot; 2) (integer) 2 # 长度 3) &quot;radix-tree-keys&quot; 4) (integer) 1 5) &quot;radix-tree-nodes&quot; 6) (integer) 2 7) &quot;last-generated-id&quot; 8) &quot;1664179271399-0&quot; # 最后生成的id 9) &quot;max-deleted-entry-id&quot;10) &quot;0-0&quot;11) &quot;entries-added&quot;12) (integer) 213) &quot;recorded-first-entry-id&quot;14) &quot;1664179267483-0&quot;15) &quot;groups&quot;16) (integer) 217) &quot;first-entry&quot; # 第一个entry18) 1) &quot;1664179267483-0&quot; 2) 1) &quot;apple&quot; 2) &quot;1&quot; 3) &quot;banana&quot; 4) &quot;23&quot;19) &quot;last-entry&quot; # 最后一个entry20) 1) &quot;1664179271399-0&quot; 2) 1) &quot;apple&quot; 2) &quot;12&quot; 3) &quot;banana&quot; 4) &quot;2&quot;127.0.0.1:6379&gt; xinfo groups st1 #获取st1的组信息1) 1) &quot;name&quot; 2) &quot;g1&quot; 3) &quot;consumers&quot; 4) (integer) 0 5) &quot;pending&quot; 6) (integer) 0 7) &quot;last-delivered-id&quot; 8) &quot;0-0&quot; 9) &quot;entries-read&quot; 10) (nil) 11) &quot;lag&quot; 12) (integer) 22) 1) &quot;name&quot; 2) &quot;g2&quot; 3) &quot;consumers&quot; 4) (integer) 0 5) &quot;pending&quot; 6) (integer) 0 7) &quot;last-delivered-id&quot; 8) &quot;1664179271399-0&quot; 9) &quot;entries-read&quot; 10) (nil) 11) &quot;lag&quot; 12) (integer) 0 消费组12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485# 消费者消费数据 xreadgroup group 组名 消费者名 count 数量 streams steam名127.0.0.1:6379&gt; xreadgroup group g1 consumer001 count 1 streams st1 &gt;1) 1) &quot;st1&quot; 2) 1) 1) &quot;1664179267483-0&quot; 2) 1) &quot;apple&quot; 2) &quot;1&quot; 3) &quot;banana&quot; 4) &quot;23&quot;# 消费者consumer001再次从流st1、组g1消费一个数据127.0.0.1:6379&gt; xreadgroup group g1 consumer001 count 1 streams st1 &gt;1) 1) &quot;st1&quot; 2) 1) 1) &quot;1664179271399-0&quot; 2) 1) &quot;apple&quot; 2) &quot;12&quot; 3) &quot;banana&quot; 4) &quot;2&quot;# st1中已经没有数据，再次读取返回nil127.0.0.1:6379&gt; xreadgroup group g1 consumer001 count 1 streams st1 &gt;(nil)# 尝试带阻塞读取数据 127.0.0.1:6379&gt; xreadgroup group g1 consumer001 block 0 count 1 streams st1 &gt;# 此处阻塞# 在另一个终端向st1中添加数据后取消阻塞1) 1) &quot;st1&quot; 2) 1) 1) &quot;1664179863235-0&quot; 2) 1) &quot;apple&quot; 2) &quot;12&quot; 3) &quot;qwe&quot; 4) &quot;11&quot;(17.78s) # 等待时间127.0.0.1:6379&gt; xinfo groups st1 # 获取st1的组信息# 包含 组名，消费者数量，获取的数量等数据1) 1) &quot;name&quot; 2) &quot;g1&quot; 3) &quot;consumers&quot; 4) (integer) 1 5) &quot;pending&quot; 6) (integer) 3 7) &quot;last-delivered-id&quot; 8) &quot;1664179863235-0&quot; 9) &quot;entries-read&quot; 10) (integer) 3 11) &quot;lag&quot; 12) (integer) 02) 1) &quot;name&quot; 2) &quot;g2&quot; 3) &quot;consumers&quot; 4) (integer) 0 5) &quot;pending&quot; 6) (integer) 0 7) &quot;last-delivered-id&quot; 8) &quot;1664179271399-0&quot; 9) &quot;entries-read&quot; 10) (nil) 11) &quot;lag&quot; 12) (nil)# 获取组g1的流st1的消费者数据127.0.0.1:6379&gt; xinfo consumers st1 g11) 1) &quot;name&quot; 2) &quot;consumer001&quot; # 消费者名 3) &quot;pending&quot; 4) (integer) 3 # 未处理的数据 5) &quot;idle&quot; 6) (integer) 61034127.0.0.1:6379&gt; xack st1 g1 1664179271399-0 # 使用ack表示数据已消费(integer) 1127.0.0.1:6379&gt; xinfo consumers st1 g1 # 查看st1 g1下的消费者数据1) 1) &quot;name&quot; 2) &quot;consumer001&quot; 3) &quot;pending&quot; 4) (integer) 2 # 未处理的数据减少了 5) &quot;idle&quot; 6) (integer) 325172127.0.0.1:6379&gt; xack st1 g1 1664179863235-0(integer) 1127.0.0.1:6379&gt; xack st1 g1 1664179267483-0 # 将剩余的数据进行消费(integer) 1127.0.0.1:6379&gt; xinfo consumers st1 g1 # 再次查询1) 1) &quot;name&quot; 2) &quot;consumer001&quot; 3) &quot;pending&quot; 4) (integer) 0 # 没有数据需要处理了 5) &quot;idle&quot; 6) (integer) 382595 一些命令XGROUP 组操作XGROUP CREATE 创建组XGROUP CREATE key groupname &lt;id | $&gt; [MKSTREAM] [ENTRIESTREAD entries_read] 为key创建一个消费者组，名为groupname； 每个组的名字在同一个key里是惟一的；若尝试创建一个已经存在的组，会返回错误 参数： &lt;id | $&gt;：从什么开始消费，其中id为指定id，$只接受新的消息，如： 123-1 为从id为123-1的节点开始； 0-0 为从头开始； $，只接受新的消息。 MKSTREAM：添加这个参数后，若指定流不存在，不再返回错误，而是创建名为key的流； ENTRIESREAD：hole… 12345678910111213141516171819127.0.0.1:6379&gt; xadd st2 123-2 apple 3 stone 5 # 为st2添加数据（一般不用指定id，这里仅学习使用）&quot;123-2&quot;127.0.0.1:6379&gt; xadd st2 * apple 3 stone 123 # 为st2添加数据，id为自动生成，目前st2的最大id就是下面这个了&quot;1664183965455-0&quot;127.0.0.1:6379&gt; xgroup create st2 cg1 $ # 创建一个消费者组，指定$表示获取最新数据OK127.0.0.1:6379&gt; xinfo groups st21) 1) &quot;name&quot; 2) &quot;cg1&quot; 3) &quot;consumers&quot; 4) (integer) 0 5) &quot;pending&quot; 6) (integer) 0 7) &quot;last-delivered-id&quot; 8) &quot;1664183965455-0&quot; # 使用 9) &quot;entries-read&quot; 10) (nil) 11) &quot;lag&quot; 12) (integer) 0 XGROUP DESTROY 删除组XGROUP DESTROY key groupname 完全删除一个消费者组； 不论消费者组中是否存在活跃的消费者或是未处理的数据，会直接将消费者组删除； 返回成功删除的消费者组的数量 1234127.0.0.1:6379&gt; xgroup create st1 cg1 0-0 # 创建消费者组，名为cg1，绑定的流为st1，起点0-0OK127.0.0.1:6379&gt; xgroup destroy st1 cg1 # 删除消费者组，名为cg1，绑定的流为st1(integer) 1 XGROUP SETID 设置组的消费idXGROUP SETID key groupname &lt;id | $&gt; [ENTRIESREAD entries_read] 设置消费者组要获取数据的起点id； ENTRIESREAD：hole… XGROUP CREATECONSUMER 创建消费者XGROUP CREATECONSUMER key groupname consumername 创建一个消费者，key为流的名字，groupname为组的名字，consumername为消费者的名字； 可以使用XREADGROUP进行数据消费； 返回值为1或0，表示消费者是否被成功创建 XGROUP DELCONSUMER 删除消费者XGROUP DELCONSUMER key groupname consumername 删除消费者，key为流的名字，groupname为组的名字，consumername为消费者的名字； XINFO 信息查询XINFO CONSUMERSXINFO CONSUMERS key groupname 返回绑定key的消费者组下的消费者信息； XINFO GROUPSXINFO GROUPS key 返回绑定key的所有消费者组； XINFO STREAMXINFO STREAM key [FULL [COUNT count]] 返回流的信息； 信息包含： length：流中实体的数量； radix-tree-keys： radix-tree-nodes： groups：定义在流中消费者组的数量 last-generated-id：最后一个实体使用的id； max-deleted-entry-id：流中删除的最大id的条目； entries-added：在流存活期间，所有添加过的实体的数量； first-entry：第一个entry的信息； last-entry：最后一个entry的信息。 可选参数： FULL：将返回更多的信息； 对于entries属性，以升序全部或指定数量的实体信息； 对于groups属性，包括XINFO GROUPS和XINFO CONSUMERS返回的信息。 COUNT：指定FULL中返回实体的数量 消费者操作XPENDING key group [[IDLE min-idle-time] start end count [consumer]] 获取消费组内被读取但未处理完毕的信息； 应用场景：为了解决组内数据被读取但在处理期间消费者崩溃的问题。","categories":[],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://zswh33.github.io/tags/Redis/"}]},{"title":"Redis 5 HyperLogLogs Bitmaps  Geospatial","slug":"Redis-5","date":"2022-09-22T03:12:20.000Z","updated":"2022-09-23T08:11:27.922Z","comments":true,"path":"2022/09/22/Redis-5/","link":"","permalink":"http://zswh33.github.io/2022/09/22/Redis-5/","excerpt":"","text":"Redis 三种特殊类型HyperLogLogs（基数统计）用于统计一些准确度要求不高的数据； 允许容错，可以接受一定误差； 基数，指内容不可重复；A&#x3D;{1,2,3,4,5}，B&#x3D;{3,5,6,7,9}，基数&#x3D;1,2,4,6,7,9； 用来做什么可以用来统计各种计数，如注册IP数，每日访问IP数，在线用户数，共同好友数等； 优势可以使用少量固定的内存去存储并识别集合中的唯一元素，估算的基数不一定准确，有0.81%标准错误近似值； 如： 一个IP消耗15个字节，100W个IP就是15M，HyperLogLog在Redis中每个键占用内容都是12K，理论存储近似接近2^64个值；不论存储的内容是什么，它有一个基于基数估算的算法，只能比较准确地估算出基数，可以使用少量固定的内存去存储并识别集合的唯一元素； 使用123456789101112127.0.0.1:6379&gt; pfadd k1 a b c d e f g h i # k1 =&#123;a,b,c,d,e,f,g,h,i&#125;(integer) 1127.0.0.1:6379&gt; pfcount k1 # 获取数量(integer) 9127.0.0.1:6379&gt; pfadd k2 a z b x c s d r e # k2 = &#123;a,b,c,d,e,z,x,s,r&#125;(integer) 1127.0.0.1:6379&gt; pfcount k2 (integer) 9127.0.0.1:6379&gt; pfmerge k3 k1 k2 # 合并k1和k2 存放到k3OK127.0.0.1:6379&gt; pfcount k3 # k3的数量(integer) 13 Bitmap（位存储）位图数据结构，通过操作二进制数来进行记录，只有0和1两个状态； 用来做什么比如用户每天的打卡情况； 设置打卡情况 12345678910127.0.0.1:6379&gt; setbit sign:year 0 1 # 用户第0天打卡了(integer) 0 127.0.0.1:6379&gt; setbit sign:year 1 0 # 用户第1天没打卡(integer) 0127.0.0.1:6379&gt; setbit sign:year 2 1 # 用户第二天打卡了(integer) 0127.0.0.1:6379&gt; setbit sign:year 3 1(integer) 0127.0.0.1:6379&gt; setbit sign:year 4 0 # 用户第4天没打卡(integer) 0 获取打卡情况 1234127.0.0.1:6379&gt; getbit sign:year 4 # 用户第4天没打卡(integer) 0127.0.0.1:6379&gt; getbit sign:year 3 # 用户第三天打卡了(integer) 1 获取所有的打卡情况 12127.0.0.1:6379&gt; bitcount sign:year(integer) 3 Geospatial（地理位置）geospatial可以存放一个坐标，地理位置，基于经纬度； 底层实现原理Geo的底层实现就是SortedSet，可以通过SortedSet命令控制geo； 原理Redis Geo使用Geohash实现位置的存储； Geohash将经纬度编码成为一个52bit的整型，而此时有序集合的score就可以存储52bit的整型且不失精度； 一些命令geoadd 添加地理位置介绍GEOADD key [NX | XX] [CH] longitude latitude member [longitude latitude member ...] 添加指定的位置信息到key中； 数据存储为一个有序集合； 可以通过GEOSEARCH命令获取这些信息； 参数 longitude 经度 latitude 纬度 命令支持标准的x，y坐标，经度必须放置在纬度的前面； 极其接近极点的坐标无法被索引： 有效经度范围：-180到180； 有效纬度范围：-85.05112878到85.05112878 若使用范围之外的经纬度会返回错误； XX 仅更新已有元素，不添加新元素； NX 不更新已有元素，只添加新元素； CH GEOADD默认返回值为新添加的元素的数量，使用CH之后将返回值改为改变的元素的数量，不计入原值和输入值相同的情况。一个双score有序集合可以存储一个52bit的整数且不失精度； 注意：XX与NX不可一起使用 geopos 获取指定成员经纬度GEOPOS key member [member ...] 返回所有指定成员的经度和纬度； 通过key使用有序集合进行索引； 由于存储数据时采用geohash方法，获取到的数据可能会出现一些误差； 若元素不存在则返回一个由null组成的数组； 12345678127.0.0.1:6379&gt; geoadd g1 116 40 &quot;BeiJing&quot; 112 37 &quot;TaiYuan&quot; # 添加TaiYuan和BeiJing的经纬度(integer) 2127.0.0.1:6379&gt; GEOPOS g1 BeiJing TaiYuan NonExistMember # 查询TaiYuan和BeiJing还有一个没有输入的值的经纬度1) 1) &quot;116.00000113248825073&quot; 2) &quot;39.99999991084916218&quot;2) 1) &quot;112.00000137090682983&quot; 2) &quot;37.00000026605963654&quot;3) (nil) # member不存在，返回nil geodist 两个成员的距离GEODIST key member1 member2 [M | KM | FT | MI] 返回两个成员之间的距离； 如果有一个或两个成员不存在，则返回null； 最后的参数为单位，默认为米： m 米； km 千米； mi 英里； ft 尺 步数 距离的计算基于假定地球是一个完美的球体，所以计算结果会有0.5%的误差； 1234567127.0.0.1:6379&gt; GEOPOS g1 BeiJing TaiYuan1) 1) &quot;116.00000113248825073&quot; 2) &quot;39.99999991084916218&quot;2) 1) &quot;112.00000137090682983&quot; 2) &quot;37.00000026605963654&quot;127.0.0.1:6379&gt; GEODIST g1 BeiJing TaiYuan m&quot;482157.6407&quot; geohashGEOHASH key member [memebr …] 返回geohash字符串 （geohash是一个可以将纬度和精度编码为一个52bit的散列函数） 123127.0.0.1:6379&gt; GEOHASH g1 BeiJing TaiYuan1) &quot;wx47x9u8gu0&quot;2) &quot;wqxdkxeut50&quot; geosearch1234567891011121314GEOSEARCH key &lt; FROMMEMBER member | FROMLONLAT longitude latitude &gt; # 二选一 从成员 从经纬度 &lt; BYRADIUS radius &lt;M | KM | FT | MI&gt; | BYBOX width height &lt;M | KM | FI | MI&gt; &gt; # 通过圆形 通过矩形 [ASC | DESC] [COUNT count [ANY]] [WITHCOORD] [WITHDIST] [WITHHASH] 介绍返回给定形状范围内的member列表； 支持搜索圆形区域和方形取悦； 命令代替了GEORADIUS和GEORADIUSBYMEMBER； 参数 形状的中心 FROMMEMBER：以成员为形状的原点； FROMLONLAT：以指定经纬度为形状的原点； 形状的参数 BYRADIUS：形状为圆形，根据给定radius参数为圆形的半径 BYBOX：形状为矩形，根据给定的width和height为形状的长宽； 需要返回对象的其他参数 WITHDIST：返回原点到各个成员的距离； WITHCOORD：返回成员的经纬度； WITHHASH：返回成员的GEOHASH值。 是否排序 若未指定以下两个参数，则默认不排序； ASC：排序顺序为距离原点，最近的元素到最远的元素； DESC：距离原点，最远的元素到最近的元素； 返回数量 COUNT &lt;count&gt; [ANY] 默认返回所有的元素； 通过COUNT &lt;count&gt;参数可以限制返回的数量； 若提供ANY，Redis查询过程会在查到指定数量的结果后直接返回不排序，且不考虑远近问题； 若不提供ANY，Redis会返回排序后的所有结果。不提供ANY时，命令执行的速度会相对慢一点； 1234567891011121314127.0.0.1:6379&gt; GEODIST g1 BeiJing TaiYuan m # 查询得知，TaiYuan到BeiJing的距离为482157m，换算48.22km&quot;482157.6407&quot;127.0.0.1:6379&gt; GEOSEARCH g1 FROMMEMBER TaiYuan BYRADIUS 500 KM ASC COUNT 2 WITHCOORD WITHDIST WITHHASH# 查询g1中 以TaiYuan为圆心，半径为500KM，两个对象， 要求返回结果中有距离圆心的距离、对象的经纬度还有对象的GEOHASH1) 1) &quot;TaiYuan&quot; 2) &quot;0.0000&quot; 3) (integer) 4041790908459398 4) 1) &quot;112.00000137090682983&quot; 2) &quot;37.00000026605963654&quot;2) 1) &quot;BeiJing&quot; 2) &quot;482.1576&quot; 3) (integer) 4069855081124858 4) 1) &quot;116.00000113248825073&quot; 2) &quot;39.99999991084916218&quot; geosearchstore123456789101112GEOSEARCHSTORE destination source &lt; FROMMEMBER member | # 原点为对象 FROMLONLAT logitude latitude # 原点为经纬度 &gt; &lt; BYRADIUS radius &lt;M | KM | FT |MI&gt; | # 圆，半径，单位 BYBOX width height &lt;M | KM | FT | MI&gt; # 矩形，宽，高，单位 &gt; [ASC | DESC] # 从近到远 从远到近 [COUNT count [ANY]] # 数量 ANY任意对象 [STOREDIST] # 与GEOSEARCH类似； 不同的是，GEOSEARCHSTORE会将获得的结果存放到destination中； 默认将获得的对象以及其GEOHASH以SortedSet方式存放； 使用STOREDIST参数后，存放内容为获得的对象和距离原点的距离。 STOREDIST， 1234567891011121314127.0.0.1:6379&gt; GEOSEARCHSTORE ss1 g1 FROMMEMBER BeiJing BYRADIUS 500 KM ASC COUNT 2 ANY(integer) 2127.0.0.1:6379&gt; GEOSEARCHSTORE ss2 g1 FROMMEMBER BeiJing BYRADIUS 500 KM ASC COUNT 2 ANY STOREDIST(integer) 2127.0.0.1:6379&gt; zrange ss1 0 -1 WITHSCORES1) &quot;TaiYuan&quot;2) &quot;4041790908459398&quot;3) &quot;BeiJing&quot;4) &quot;4069855081124858&quot;127.0.0.1:6379&gt; zrange ss2 0 -1 WITHSCORES1) &quot;BeiJing&quot;2) &quot;0&quot;3) &quot;TaiYuan&quot;4) &quot;482.15764068388631&quot; georadius 通过半径获取附近的人的地址（弃用）GEORADIUS key longitud latitude raduis &lt;M | KM | FI | MI&gt; [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count [ANY]] [ASC | DESC] [STORE key] [STOREDIST key] georadiusbymember 通过半径获取成员附近的地址（弃用）123GEORADIUSBYMEMBER key member radius &lt;M | KM | FT | MI&gt; [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count [ANY]] [ASC | DESC] [STORE key] [STOREDIST key]","categories":[],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://zswh33.github.io/tags/Redis/"}]},{"title":"Redis 4 Stream","slug":"Redis-4","date":"2022-09-21T15:06:24.000Z","updated":"2022-09-27T08:55:41.733Z","comments":true,"path":"2022/09/21/Redis-4/","link":"","permalink":"http://zswh33.github.io/2022/09/21/Redis-4/","excerpt":"","text":"Stream介绍https://redis.io/docs/data-types/streams-tutorial/ 说明Stream是一个只能添加数据的数据结构；依赖于添加命令XADD，Stream可以添加新的entry到指定流； 每个Stream Entry都是一个field-value； 示例1：XADD使用12127.0.0.1:6379&gt; XADD myStream * sensor-id 12 temperature 11.1&quot;1663848814626-0&quot; 在上面的命令中， XADD为myStream添加了{sensor-id:12, temperature:11.1}属性； 第一个参数myStream为指定的key的名字； 第二个参数是一个ID，每个entry都有一个ID；这里使用“*”，意为让服务器自动生成一个ID； 服务器生成的ID会依据生成先后自动增加； 大多数情况下都使用服务器自动生成的结果作为ID，无需手动提供ID； 后面的参数即field-value，用于提供要保存的键值对。 示例2：XLEN12127.0.0.1:6379&gt; XLEN myStream(integer) 1 XLEN可以获取流的长度。 Entry ID介绍Entry ID的格式如下： 1&lt;millisecondsTime&gt;-&lt;sequenceNumber&gt; millisecondsTime即当前本地的时间； Entry ID都是逐步递增的，如果Redis获取的时间在上个提交的Entry时间之前，Redis将使用最新的进行记录（即上个提交的Entry时间）； 为什么用时间作为ID？。（从文档翻译）用时间作为ID可能会很奇怪，有些读者可能想知道问什么这样做。原因是Redis支持依据ID值的范围进行查询Entry，如果将时间作为ID，就可以很方便地依据时间去查询Entry。（e…Long型的时间好像也不方便…） Entry最小的ID是0-1，Redis不允许ID小于上一次添加的Entry的ID； 示例3：ID可以仅提供milliseconds部分，由系统去生成后半部分如果用的Redis版本是7或以上，可以提供ID的前半部分，后半部分使用*代替，Redis会自动生成后半部分且逐次递增； 123456127.0.0.1:6379&gt; XADD s5 0-* apple 1&quot;0-1&quot;127.0.0.1:6379&gt; XADD s5 0-* apple 2&quot;0-2&quot;127.0.0.1:6379&gt; XADD s5 0-* apple 3&quot;0-3&quot; 示例4：查询的操作可以用时间范围去查询Entry只需要指定两个ID来表示起点和终点，就可以查询一个流； 两个特殊的参数“-”和“+”分别表示最小ID和最大ID。 12345678910111213141516127.0.0.1:6379&gt; XADD s5 0-* apple 1&quot;0-1&quot;127.0.0.1:6379&gt; XADD s5 0-* apple 2&quot;0-2&quot;127.0.0.1:6379&gt; XADD s5 0-* apple 3&quot;0-3&quot;127.0.0.1:6379&gt; xrange s5 - +1) 1) &quot;0-1&quot; 2) 1) &quot;apple&quot; 2) &quot;1&quot;2) 1) &quot;0-2&quot; 2) 1) &quot;apple&quot; 2) &quot;2&quot;3) 1) &quot;0-3&quot; 2) 1) &quot;apple&quot; 2) &quot;3&quot; 每个entry返回一个含有field-value的数组； 在XADD指定ID时使用*，则ID的左半部分表示当时的时间，这将意味着我们可以使用XRANGE去查询一个时间范围内的所有Entry； 因为使用毫秒时间作为ID的左半部分，所以XRANGE查询的时间甚至可以精确到毫秒； 12345678910127.0.0.1:6379&gt; xadd s6 * apple 1&quot;1663850754240-0&quot;127.0.0.1:6379&gt; xadd s6 * apple 2&quot;1663850755536-0&quot;127.0.0.1:6379&gt; xadd s6 * apple 3&quot;1663850756295-0&quot;127.0.0.1:6379&gt; xrange s6 1663850754240 1663850754241 # 查询1毫秒间的日志1) 1) &quot;1663850754240-0&quot; 2) 1) &quot;apple&quot; 2) &quot;1&quot; XRANGE可以限制查询数量有时候，在有些范围内，可能会有特别多的Entry，这样查询起来可能会麻烦； 使用XRANGE的COUNT参数可以限制查询的数量； 12345678910111213127.0.0.1:6379&gt; xadd s6 * apple 1&quot;1663850754240-0&quot;127.0.0.1:6379&gt; xadd s6 * apple 2&quot;1663850755536-0&quot;127.0.0.1:6379&gt; xadd s6 * apple 3&quot;1663850756295-0&quot;127.0.0.1:6379&gt; xrange s6 - + COUNT 21) 1) &quot;1663850754240-0&quot; 2) 1) &quot;apple&quot; 2) &quot;1&quot;2) 1) &quot;1663850755536-0&quot; 2) 1) &quot;apple&quot; 2) &quot;2&quot; XRANGE可以查询接下来的两个Entry； 将查询结果的最后一个ID作为查询的起点，使用“(”前缀，可以查询接下来的两个Entry； 1234567127.0.0.1:6379&gt; xrange s6 (1663850755536-0 + COUNT 21) 1) &quot;1663850756295-0&quot; 2) 1) &quot;apple&quot; 2) &quot;3&quot;# 左括号表示不包含当前项 # +表示最高ID # COUNT 2 表示查询两个Entry XRANGE的复杂度是O(log(N))，返回M个元素则另外包含O(M)，复杂度是对数，这样效率是比较高的，所以可以代替XSCAN； XREVRANGEXREVRANGE等效于XRANGE，不同的是XREVRANGE的顺序是相反的； 通过XREVRANGE获取最新的Entry： 1234127.0.0.1:6379&gt; xrevrange s6 + - COUNT 11) 1) &quot;1663850756295-0&quot; 2) 1) &quot;apple&quot; 2) &quot;3&quot; 示例5：XREAD 监听新元素的添加有时候我们可能不需要通过一个返回从流中获取数据，仅仅只是想获取流中新抵达的元素（订阅流中新抵达的元素）； 这就是Redis的发布&#x2F;订阅； 阻塞队列与Stream是不同的 Stream收到的新的元素，会平等的发送到每个等待的消费者；而在阻塞队列中，消费者获取到的元素是不同的； Stream会将收到的元素无限期地存储在流中（除非用户指定），而阻塞队列在pop后会将元素删除； Streams Consumer Groups提供了Pub&#x2F;Sub的控制级别功能；每个消费者会被手动地分配到不同组，对于不同组，则有不同的访问范围；StreamsConsumerGroups能够记录项目是否被完成，同时记录消费者处理事务的历史，对于每个消费者，只能获取到自己处理的事务； 对于消费者，使用XREAD来监听流的新到元素； 通过XREAD获取流中的最新数据12345678127.0.0.1:6379&gt; XREAD COUNT 2 STREAMS s6 01) 1) &quot;s6&quot; 2) 1) 1) &quot;1663850754240-0&quot; 2) 1) &quot;apple&quot; 2) &quot;1&quot; 2) 1) &quot;1663850755536-0&quot; 2) 1) &quot;apple&quot; 2) &quot;2&quot; 其中，STREAMS是必要参数，用于指定key和一个ID； Redis会返回流中大于指定ID的entry； STREAMS参数后面可以跟多个key，key后面根同等数量的ID，如：STREAMS s1 s2 0 0；因此STREAMS参数必须放在命令的最后面； XREAD可以阻塞网络直到有新的entry被添加添加一个BLOCK参数就可以阻塞网络直到获取到新的被添加entry； BLOCK后面根超时时间，0表示无限等待； 使用“$”表示流内最新的Entry的ID； 在示例中： XREAD被阻塞 0表示无限期等待 STREAMS用于指定key和ID； $表示s6下最新的ID 当XADD执行结束后，XREAD阻塞取消，返回新添加的值； XREAD BLOCK 可以不使用$作为id； 在此模式下，STREAMS可以提供多个key和ID，此时如果其中一个流添加了新的数据，将从该流读取出现的新数据并返回。 XREAD不会删除数据，仅仅只是读取数据。 使用示例添加几个温度记录到Stream 123456789101112131415161718192021222324252627282930313233127.0.0.1:6379&gt; xadd temperatures:table:1001 apple 23.2 bread 18.2 milk 11.2 # 苹果23.2 面包18.2 牛奶11.2 一般这里表示硬件温度；(error) ERR Invalid stream ID specified as stream command argument127.0.0.1:6379&gt; xadd temperatures:table:1001 * apple 23.2 bread 18.2 milk 11.2&quot;1663773543545-0&quot; # 返回的streamID127.0.0.1:6379&gt; xadd temperatures:table:1001 * apple 24.1 bread 14.7 milk 12.3&quot;1663773560847-0&quot;127.0.0.1:6379&gt; xadd temperatures:table:1001 * apple 21.1 bread 12.7 milk 15.3&quot;1663773569889-0&quot;127.0.0.1:6379&gt; xrange temperatures:table:1001 1663773543545-0 + COUNT 3 #查询1) 1) &quot;1663773543545-0&quot; 2) 1) &quot;apple&quot; 2) &quot;23.2&quot; 3) &quot;bread&quot; 4) &quot;18.2&quot; 5) &quot;milk&quot; 6) &quot;11.2&quot;2) 1) &quot;1663773560847-0&quot; 2) 1) &quot;apple&quot; 2) &quot;24.1&quot; 3) &quot;bread&quot; 4) &quot;14.7&quot; 5) &quot;milk&quot; 6) &quot;12.3&quot;3) 1) &quot;1663773569889-0&quot; 2) 1) &quot;apple&quot; 2) &quot;21.1&quot; 3) &quot;bread&quot; 4) &quot;12.7&quot; 5) &quot;milk&quot; 6) &quot;15.3&quot; 在流的尾部，读取100个新的stream entries，如果没有entries被写入则阻塞等待300ms； 1XREAD COUNT 100 BLOCK 300 STREAMS temperatures:table $ 基础命令XADD：添加一个新的entry到stream； XREAD：在给定的位置开始并向前读取，读取一个或多个entries； XRANGE：返回给定两个ID指向的entry之间的entry； XLEN：返回流的长度； 性能添加entry到stream是O(1)； 访问任意单个entry是O(n)，n为ID的length； 其他命令 增 删 查 赋权 XGROUP XINFO 整理 XADD XACK XLEN XAUTOCLAIM CREATE COMSUMERS XTRIM XDEL XPENDING XCLAIM CREATECONSUMER GROUPS XRANGE DELCONSUMER STREAM XREVRANGE DESTROY XREAD SETID XREADGROUP TRIM 整理&#x2F;修剪TRIM key &lt;MAXLEN | MINID&gt; [= | ~] threshold [LIMIT count] TRIM可以使流在需要时移除旧的entries； 参数 MAXLEN：指定流要控制的长度，这样做会移除旧的entries直到流的长度控制为指定长度，长度必须为整数；（在文档里，这里用threshold来表示需要控制的长度） MINID：移除id低于threshold的entries； **~**：仅在使用MAXLEN时使用。使用参数后，Redis可能不会准确地将entries数量修剪到指定长度，而是比指定长度多一点或等于指定长度； 使用~后，Redis会尽早的停止修剪，以促进性能节约； 有时候，用户并非需要精确地将流裁剪为指定长度，可以有些误差，但不能少于指定值，使用“~”后，可以达到要求的同时提高性能。 LIMIT：限制TRIM移除的entries最大大小； 有时候，如果需要修剪entries过多，可能会影响性能，通过LIMIT限制本次操作要清理的entries数量，可以尽快地结束操作进行； 若没有指定LIMIT参数，将以entries的数量x100作为count值； 指定count&#x3D;0，可以禁止移除数量限制。 返回值被移除的entries数量。 使用修剪流使流达到指定长度12127.0.0.1:6379&gt; xtrim s MAXLEN 1000 # 这里指定长度为1000(integer) 0 移除ID小于指定值的entries123456789101112127.0.0.1:6379&gt; xadd s * a 2 b 3 # a=2 b=3&quot;1663845075734-0&quot;127.0.0.1:6379&gt; xadd s * a 12 b 123 # a=12 b=123&quot;1663845081393-0&quot;127.0.0.1:6379&gt; xtrim s MINID 1663845075735 # 修剪1663845075735，这个值比上面第一个大1.(integer) 1127.0.0.1:6379&gt; xrange s 1663845075734-0 + COUNT 3 #输出从1663845075734开始往后数3个1) 1) &quot;1663845081393-0&quot; 2) 1) &quot;a&quot; 2) &quot;12&quot; 3) &quot;b&quot; 4) &quot;123&quot; 增XADD 增加entry到流XADD key [NOMKSTREAM] [&lt;MAXLEN | MINID&gt;] [= | ~] threshold [LIMIT count]] &lt;* | id&gt; field value [field value ...] 添加entry到指定流； 一个entry由一个键值对组成； XRANGE和XREAD可以用来从流中读取数据； XADD可以向流中添加数据； XDEL和XTRIM可以从流中删除数据。 使用使用参数指定Stream ID如果使用“*”指定ID，XADD命令将为流自动生成唯一的Stream ID； ID一般由Redis生成，但也可以自己手动指定ID： ID的格式为：123456789-33 两个数字都是64bit的数字，ID生成过程中，第一个数字使用Unix时间生成，第二部分是一个序列号，用于区分在同一时间生成的不同数据； 可以手动指定一个不完整的id，如：123456789-*。用*表示的第二部分将由Redis去生成； ID保证生成过程是递增的；若在某次插入过程中，指定的ID比之前大得多，在后来的插入过程，将按照这个指定的ID继续进行递增； 限制流的大小若流的内容条数等于指定的允许大小（也就是满了），在新添加内容时，XADD将最旧的条目逐出流，然后将新的条目添加进去； [&lt;MAXLEN | MINID&gt;] [= | ~] threshold [LIMIT count]]的用法详见XTRIM。 参数NOMKSTREAM：若key不存在，不创建新的对象； 删XDELXDEL key id [id ...] 从流中移除指定的entry，返回被移除的entry的数量； 原理XDEL并非真正地将entry从radix tree中移除，仅仅只是将entry标注为被删除； 如果一个宏节点中所有的entry被删除，整个节点会被销毁，内存将会被回收； 对于流来说，为保持流的性能，XDEL仅仅只是将entry标注为deleted，因此会产生大量的碎片，这是一个较为严重的问题； 在未来的版本中，Redis可能会添加垃圾回收机制去清理被删除的节点，但是这样会增加复杂度，这不是一个好主意（即有内存碎片，但是目前不打算解决） 使用123456789101112127.0.0.1:6379&gt; xadd s3 * apple 1 cat 2&quot;1663847348847-0&quot;127.0.0.1:6379&gt; xadd s3 * apple 12 cat 22&quot;1663847354912-0&quot;127.0.0.1:6379&gt; xdel s3 1663847348847-0(integer) 1127.0.0.1:6379&gt; xrange s3 1663847348847-0 + COUNT 101) 1) &quot;1663847354912-0&quot; 2) 1) &quot;apple&quot; 2) &quot;12&quot; 3) &quot;cat&quot; 4) &quot;22&quot; 查XREADXREAD [COUNT count] [BLOCK milliseconds] STREAMS key [key ...] id [id ...] 读取一个或多个流，只返回带有id或大于id的数据表； 参数： COUNT：数量 BLOCK：若当前没有数据则阻塞，直到有新的数据输入，0表示无限期阻塞等待，非0表示超时等待； STREAMS：可以提供多个流和id，将从多个流中读取数据； 123456789127.0.0.1:6379&gt; xadd stream001 * apple 3 stone 5 # 插入一个数据&quot;1664182678233-0&quot;127.0.0.1:6379&gt; xread COUNT 1 STREAMS stream001 0-0 # 查询一个数据1) 1) &quot;stream001&quot; 2) 1) 1) &quot;1664182678233-0&quot; 2) 1) &quot;apple&quot; 2) &quot;3&quot; 3) &quot;stone&quot; 4) &quot;5&quot; 内部命令 XSETID XSETID key last-id [ENTRIESADDED entries_added] [MAXDELETEDID max_deleted_entry_id] 用于让Redis复制最后交付的流的ID； RPC","categories":[],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://zswh33.github.io/tags/Redis/"}]},{"title":"Redis 3 Hash SortedSet","slug":"Redis-3","date":"2022-09-21T01:23:26.000Z","updated":"2022-09-22T03:11:57.351Z","comments":true,"path":"2022/09/21/Redis-3/","link":"","permalink":"http://zswh33.github.io/2022/09/21/Redis-3/","excerpt":"","text":"HashHash用于存储field和value的映射表，适用于存储对象。 每个hash中可以存储2^32-1个field-value pair； 使用&#x2F;场景场景缓存：更直观地维护缓存信息，如用户信息、饰品信息； 例子：存储用户的属性1234567891011121314127.0.0.1:6379&gt; hset user:001 username ZhangSan firstName San lastName zhang age 21 # 在user:001中存储键值对 #其中分别为 username:ZhangSan firstName:San lastName:zhang age:21(integer) 4 # 返回field value对的数量127.0.0.1:6379&gt; hget user:001 username # 查询user:001的username&quot;ZhangSan&quot;127.0.0.1:6379&gt; hgetall user:001 # 获取user:001的所有 field-value pair1) &quot;username&quot;2) &quot;ZhangSan&quot;3) &quot;firstName&quot;4) &quot;San&quot;5) &quot;lastName&quot;6) &quot;zhang&quot;7) &quot;age&quot;8) &quot;21&quot; 例子：存储设备的访问状态123456789101112131415127.0.0.1:6379&gt; hincrby device:2:stats pings 1 # device:2:stats的pings加一(integer) 1127.0.0.1:6379&gt; hincrby device:2:stats pings 1(integer) 2127.0.0.1:6379&gt; hincrby device:2:stats pings 1(integer) 3127.0.0.1:6379&gt; hincrby device:2:stats requests 1 # device:2:stats的requests加一(integer) 1127.0.0.1:6379&gt; hincrby device:2:stats errors 1 # device:2:stats的errors加一(integer) 1127.0.0.1:6379&gt; hget device:2:stats pings # 获取device:2:stats的pings&quot;3&quot;127.0.0.1:6379&gt; hmget device:2:stats requests errors # 获取device:2:stats的requests和errors1) &quot;1&quot;2) &quot;1&quot; 基础命令hset：hash设置值； hget：hash获取值； hmget：hash获取多个值； hincrby：若value可以为整数，则增加value的值。 其他命令 增 删 查 HSET HDEL HGET HSETNX HMGET HINCRBY HEXISTS HINCRBYFLOAT HLEN HSTRLEN HRANDFIELD HSET 设置值 可以多个hset key field value [field value ...] 设置hash的多个field-value对； 返回添加的field-value对数量。 HSETNX 当field不存在则设置值hsetnx key field value 当集合中没有指定field时，为集合添加field-value对；若集合中存在指定field，则不进行操作； 若key对应的set不存在，则创建一个集合； 返回值： 若成功添加返回1； 若field已存在，操作没有执行，返回0。 1234127.0.0.1:6379&gt; hsetnx user:1 age 3(integer) 1127.0.0.1:6379&gt; hsetnx user:1 age 5(integer) 0 HGET 获得field的valuehget key field 获取集合中field对应的值； 若集合中没有field或集合不存在则返回nil； 1234127.0.0.1:6379&gt; hsetnx user:1 age 3 # 设置user:1的age的值为3(integer) 1127.0.0.1:6379&gt; hget user:1 age # 获取user:1的age值&quot;3&quot; HMGET 获取field的value 可以多个hmget key field [field ...] 获取集合中field对应的value。 返回一个数组，包含每个field对应的value； 若field不存在，则为nil； 若key不存在，视作空hash，将返回一个值为nil的数组； 123456789127.0.0.1:6379&gt; hset user:3 name zhangsan age 12 psw 1234565(integer) 3127.0.0.1:6379&gt; hmget user:3 name age pass1) &quot;zhangsan&quot;2) &quot;12&quot;3) (nil)127.0.0.1:6379&gt; hmget user:4 name age1) (nil)2) (nil) HGETALL 获得所有field-valuehgetall key 获取集合中所有的field-value对； 123456789127.0.0.1:6379&gt; hset user:2 name ZhangSan age 12 psw 123456(integer) 3127.0.0.1:6379&gt; hgetall user:21) &quot;name&quot;2) &quot;ZhangSan&quot;3) &quot;age&quot;4) &quot;12&quot;5) &quot;psw&quot;6) &quot;123456&quot; HDEL 删除field 可以多个hdel key field [field ...] 删除集合中的field-value 对； 返回成功删除的field的数量； 若key不存在，则返回0； 123456789101112127.0.0.1:6379&gt; hgetall user:21) &quot;name&quot;2) &quot;ZhangSan&quot;3) &quot;age&quot;4) &quot;12&quot;5) &quot;psw&quot;6) &quot;123456&quot;127.0.0.1:6379&gt; hdel user:2 name age(integer) 2127.0.0.1:6379&gt; hgetall user:21) &quot;psw&quot;2) &quot;123456&quot; HEXISTS 查询field存在hexists key field 若集合中存在field返回1，否则返回0； HLEN 获得field数量hlen key 返回集合field的数量。 HSTRLEN 获得value的长度hstrlen key field 返回集合中field对应的value的长度，若key或field不存在返回0； HINCRBY 增加整型的值hincrby key field increment 增加集合中field整型变量的值； 若key不存在，则自动创建一个集合，若field不存在，则在操作执行前将field的值设为0； （即若key或field不存在，设集合key的field值为1） （increment非可选变量，是必选变量） 1234127.0.0.1:6379&gt; hincrby user:5 age 1(integer) 1127.0.0.1:6379&gt; hget user:5 age&quot;1&quot; HINCRBYFLOAT 增加浮点数的值hincrbyfloat key field increment Hash INCREment FLOAT 功能与hincrby类似，不同的是hincrbyfloat可以增加浮点数。 若increment为负，则为减少指定的值； 若key或field不存在，则在操作执行前，将key集合的field设为0（即操作执行后，值为1） 若field的value的类型不是数字或value的值不可被解析为一个浮点数，将返回错误信息； 若执行成功，返回增加后的值。 12345678127.0.0.1:6379&gt; hset user:6 age 3(integer) 1127.0.0.1:6379&gt; hincrbyfloat user:6 age 1.23&quot;4.23&quot;127.0.0.1:6379&gt; hset user:6 name ZhangSan(integer) 1127.0.0.1:6379&gt; hincrbyfloat user:6 name 1.23(error) ERR hash value is not a float HRANDFIELD 随机获取fieldhrandfield key [count [WITHVALUES]] 获取集合中随机的field值； 若包含WITHVALUES参数，则返回field-value对； 关于count的使用： 若count为正，返回指定数量的field，若count大于集合的基数，则返回集合的基数数量的field； 若count为负，返回|count|数量的field，且返回值可能存在重复；不论count与集合的基数大小关系，返回的结果的数量绝对是|count|； 返回值： 若没有count参数，则返回一个value；若key不存在返回nil； 若有count参数，则返回一个数组，若key不存在返回空数组；若包含WITHVALUES参数，则返回field和它对应的value。 123456789101112127.0.0.1:6379&gt; hrandfield user:7 21) &quot;name&quot;2) &quot;psw&quot;127.0.0.1:6379&gt; hrandfield user:7 101) &quot;name&quot;2) &quot;age&quot;3) &quot;psw&quot;127.0.0.1:6379&gt; hrandfield user:7 2 WITHVALUES1) &quot;name&quot;2) &quot;XiaoMing&quot;3) &quot;psw&quot;4) &quot;xm123&quot; HVALS 获取所有的valuesHVALS key Hash VALueS 返回所有的values； 1234567891011127.0.0.1:6379&gt; hgetall user:71) &quot;name&quot;2) &quot;XiaoMing&quot;3) &quot;age&quot;4) &quot;15&quot;5) &quot;psw&quot;6) &quot;xm123&quot;127.0.0.1:6379&gt; hvals user:71) &quot;XiaoMing&quot;2) &quot;15&quot;3) &quot;xm123&quot; HMSET（弃用） 与hset一致与hset功能相同，即将被弃用 Sorted Set带有排序功能的set； 排序方式：按照scores顺序存储字符串，若字符串有相同scores，则按照字典序存储字符串； 应用举例： 游戏排名最高分； 通过滑动窗口限制同一时间内的API请求数量。 实现Redis Sorted Set实现原理 压缩列表（ziplist）：ziplist是为了提高存储效率而设计的一种特殊编码的双向链表，可以存储字符串或整数；存储整数采用二进制而不是字符串；Ziplist能在O(1)的复杂度下完成list两端的push和pop操作；每次操作都需要重新分配ziplist的内存，实际复杂度与ziplist的内存使用量有关； 跳跃表(zSkiplist)：跳跃表的性能可以保障查找、删除和添加等操作在对数期望时间内完成，跳跃表的复杂度是O(log(n))； 例子：游戏排名最高分1234567891011121314151617127.0.0.1:6379&gt; zadd leaderboard 100 user:1 # 设置user:1的得分是100(integer) 1127.0.0.1:6379&gt; zadd leaderboard 89 user:2 # 设置user:2的得分是89(integer) 1127.0.0.1:6379&gt; zadd leaderboard 201 user:3 # 设置user:3的得分是201(integer) 1127.0.0.1:6379&gt; zadd leaderboard 23 user:4(integer) 1127.0.0.1:6379&gt; zadd leaderboard 111 user:5(integer) 1127.0.0.1:6379&gt; zrange leaderboard 0 2 REV WITHSCORES # 获取范围 0 2，REV逆序，WITHSCORES包含分数1) &quot;user:3&quot;2) &quot;201&quot;3) &quot;user:5&quot;4) &quot;111&quot;5) &quot;user:1&quot;6) &quot;100&quot; 基础命令ZADD：添加新的对象和分数到有序集合中，若对象存在，则更新分数； ZRANGE：返回排序后的对象列表，可以选择排行榜的范围； ZRANK：返回对象所在的排名； ZREVRANK：返回集合在逆序下，对象所在的排名。 性能zrange：O(log(n)) 其他：O(log(n)+m) 其他命令 增 删 查 自增 并 交 差 ZADD ZREM ZCARD ZINCRBY ZUNION ZINTER ZDIFF ZREMRANGEBYLEX ZCOUNT ZUNIONSTORE ZINTERCARD ZDIFFSTORE ZREMRANGEBYRANK ZLEXCOUNT ZINTERSTORE ZREMRANGEBYSCORE ZSCORE ZPOPMAX ZMSCORE ZPOPMIN ZRANDMEMBER ZMPOP ZRANGE ZRANGEBYLEX ZRANGEBYSCORE ZRANGESTORE ZREVRANGE ZREVRANGEBYLEX ZREVRANGEBYSCORE ZRANK ZREVRANK 增ZADD介绍&#x2F;使用ZADD key [MX | XX] [GT | LT] [CH] [INCR] score member [score member ...] 向有序集合中添加指定的对象和scores，可以指定多个member-score对； 如果集合中已存在要添加的member，则更新member的score为新输入的score； 如果key不存在，则创建相应的有序集合并将对象和score放进集合中；若key存在且类型不为有序集合，则返回错误； score的值应为双精度浮点数的string格式； 可以用的参数 XX：仅更新已存在的元素，不添加新的元素； NX：仅添加新的元素，不更新已存在的元素； LT：若输入的score值小于原本的score值，则更新存在的值； GT：若输入的score值大于原本的score值，则更新存在的值； CH：返回值改为更新的元素数量； INCR：将ZADD的作用变为ZINCRBY，此时只能指定一个score-element对； 注意：GT、LT和NX三者是互斥的。 实现Redis采用64位双精度浮点数来表示score，依据IEEE 754实现，能够精确的表示-(2^53 )到+(2^53)之间的数字。 返回值默认返回添加到有序集合的元素数量； 如果指定CH选项，则返回改变的元素的数量； 如果指定incr选项，若执行成功返回对象的score，操作取消则返回nil（被XX或NX选项阻止）。 代码1234567891011121314151617181920212223242526272829127.0.0.1:6379&gt; zadd ss 10 a 20 b # 设置 a=10 b=20(integer) 2127.0.0.1:6379&gt; zadd ss XX CH 20 a 30 b # 仅更新值，不添加新的元素(integer) 1127.0.0.1:6379&gt; zrange ss 0 -1 WITHSCORES1) &quot;a&quot;2) &quot;20&quot;3) &quot;b&quot;4) &quot;30&quot;127.0.0.1:6379&gt; zadd ss NX 5 c 69 b # 仅添加新的元素，不更新值(integer) 1127.0.0.1:6379&gt; zrange ss 0 -1 WITHSCORES1) &quot;c&quot; # c被添加2) &quot;5&quot;3) &quot;a&quot;4) &quot;20&quot;5) &quot;b&quot;6) &quot;30&quot; # b没有被更新127.0.0.1:6379&gt; zadd ss LT 19 a 31 b # 仅当输入值小于原来的值时更新 (integer) 0127.0.0.1:6379&gt; zrange ss 0 -1 WITHSCORES1) &quot;c&quot;2) &quot;5&quot;3) &quot;a&quot;4) &quot;19&quot; # a被更新5) &quot;b&quot;6) &quot;30&quot; # b没有被更新127.0.0.1:6379&gt; zadd ss INCR 1 a # 自增&quot;20&quot; LT : less than &lt; GT : great than &gt; LE : less equal &lt;&#x3D; GE : great equal &gt;&#x3D; 删ZREMZREM key member [member …] 删除指定的对象； 成功返回移除的对象数量，不包含不存在的对象；若key不存在返回错误。 1234567127.0.0.1:6379&gt; zadd ss 1 a 2 b 3 c(integer) 3127.0.0.1:6379&gt; zrem ss a d # 删除a成功， d不存在被忽略(integer) 1127.0.0.1:6379&gt; zrange ss 0 -11) &quot;b&quot;2) &quot;c&quot; ZREMRANGEBYLEXZREMRANGEBYLEX key min max 删除字典序排序从min到max的元素； 返回被移除的元素数量。 123456789127.0.0.1:6379&gt; zadd ss 1 a 2 d 3 e 4 g 5 i 6 w 7 y 8 z(integer) 8127.0.0.1:6379&gt; zremrangebylex ss [e [w(integer) 4127.0.0.1:6379&gt; zrange ss 0 -11) &quot;a&quot;2) &quot;d&quot;3) &quot;y&quot;4) &quot;z&quot; 在命令内部使用 “[字符串”表示范围，如：[assd ZREMRANGEBYSCOREZREMRANGEBYSCORE key min max 删除score值是从min到max的元素。 1234567891011121314151617181920127.0.0.1:6379&gt; zrange ss2 0 -1 WITHSCORES 1) &quot;w&quot; 2) &quot;7&quot; 3) &quot;s&quot; 4) &quot;8&quot; 5) &quot;c&quot; 6) &quot;9&quot; 7) &quot;x&quot; 8) &quot;10&quot; 9) &quot;l&quot;10) &quot;11&quot;127.0.0.1:6379&gt; ZREMRANGEBYSCORE ss2 8 9 # 删除scores范围为 8 ~ 9 的值。(integer) 2127.0.0.1:6379&gt; zrange ss2 0 -1 WITHSCORES1) &quot;w&quot;2) &quot;7&quot;3) &quot;x&quot;4) &quot;10&quot;5) &quot;l&quot;6) &quot;11&quot; ZREMRANGEBYRANKZREMRANGEBYRANK key start stop 删除排名从start到stop的元素； 1234567891011127.0.0.1:6379&gt; zrange ss 0 -11) &quot;a&quot;2) &quot;c&quot;3) &quot;d&quot;4) &quot;w&quot;5) &quot;f&quot;127.0.0.1:6379&gt; zremrangebyrank ss 1 3 # 删除排名位于 1 ~ 3 的元素(integer) 3127.0.0.1:6379&gt; zrange ss 0 -11) &quot;a&quot;2) &quot;f&quot; ZPOPMAX、ZPOPMINZPOPMAX key [count] ZPOPMIN key [count] 移除scores值 MAX最高（MIN最低）的count个元素； 若没有count属性，默认count为1； 返回多个元素，score最大（MAX为最大的，MIN为最小的）的元素在首位，其他依次向下排列； 123456789101112131415127.0.0.1:6379&gt; zrange ss2 0 -1 WITHSCORES1) &quot;w&quot;2) &quot;7&quot;3) &quot;x&quot;4) &quot;10&quot;5) &quot;l&quot;6) &quot;11&quot;127.0.0.1:6379&gt; zpopmax ss2 21) &quot;l&quot;2) &quot;11&quot;3) &quot;x&quot;4) &quot;10&quot;127.0.0.1:6379&gt; zrange ss2 0 -1 WITHSCORES1) &quot;w&quot;2) &quot;7&quot; ZMPOP 依据提供的方向删除指定集合指定数量的元素ZMPOP numkeys key [key …] &lt;MIN | MAX&gt; [COUNT count] 从给定的集合中从前往后寻找非空集合，删除并返回多个元素。 可以指定多个集合； 在MIN下，将对在非空集合中score最低的元素进行pop；MAX反之； COUNT指定要pop的数量； 返回值： 返回一个二维数组（[n][2]），子数组包含删除元素的对象和score； 若没有元素被pop则返回nil 查ZCARDZCARD key 查询集合的基数。 ZCOUNT、ZLEXCOUNTZCOUNT key min max 获取score在min到max之间的元素。O(log(N))。 ZLEXCOUNT key min max 依据字典序获得min到max之间的元素。O(log(N))。 返回指定结果数量； ZSCOREZSCORE key member 返回成员的score； 若成员或key不存在，返回nil； ZMSCOREZMSCORE key member [member ...] 返回多个成员的score； 对于每个成员，若member不存在，则score以nil代替。 12345127.0.0.1:6379&gt; zadd ss 1 a 2 b 3 c(integer) 3127.0.0.1:6379&gt; zmscore ss a b1) &quot;1&quot;2) &quot;2&quot; ZRANDMEMBERZRANDMEMBER key [count [WITHSCORES]] 若只有key参数，则在集合中随机获取一个元素并返回其成员名； 若有count参数， 若count为正数，在集合中随机获取多个元素并返回其成员名，数量取count和基数的最小值； 若count为负数，获取的结果会有重复，返回的数量绝对为count，不受基数大小限制。 若加上WITHSCORES，返回参数包含成员名及其scores。 12345678127.0.0.1:6379&gt; ZRANDMEMBER ss 21) &quot;c&quot;2) &quot;a&quot;127.0.0.1:6379&gt; ZRANDMEMBER ss 2 WITHSCORES1) &quot;b&quot;2) &quot;2&quot;3) &quot;a&quot;4) &quot;1&quot; ZRANGE介绍ZRANGE key start stop [BYSCORE | BYLEX] [REV] [LIMIT offset count] [WITHSCORES] 依据条件进行查询，返回结果顺序默认从低到高；若start大于基数或stop，则返回空集合；若stop大于基数，视为最后一个元素。 ZRANGE可以查询来自不同类型范围的元素； 参数start，stop：值的起点和终点，即值的范围为 start ~ stop； 第一个元素用0表示，第二个为1，其他依次类推； start&#x2F;stop值也可以为负，-1表示倒数第一个，-2表示倒数第二个； 对于不同的排序依据，可以使用的值不同； 默认情况下 start&#x2F;stop表示查询地范围，结果包含start&#x2F;stop索引所在位置的值； 对于BYSCORE 默认情况下，结果包含start&#x2F;stop指定的索引位置，可以通过添加前缀”**(**“来表示不包含start&#x2F;stop指定的索引位置的值； 默认情况下，start表示最小score，stop表示最大score； 也可以为 “+inf”或“-inf”，分别表示正无穷和负无穷。 若使用REV参数，就必须将start和stop的值反过来使用，也就是start &gt; stop，否则将获得一个空的结果；start表示最大score，stop表示最score。 对于BYLEX start&#x2F;stop值必须包含“(”或“[”表示不包含或包含start&#x2F;stop指定的索引位置的值； 可以使用“+”或者“-”表示正无穷和负无穷； 若使用REV参数，就必须将start和stop的值反过来，也就是 start &gt; stop，否则将返回一个空的结果。 BYSCORE：依据score； BYLEX：依据字典序；在此模式下不支持REV参数，会返回错误； REV：查询结果默认排序为从低到高，使用REV参数后排序改为从高到低； LIMIT：在获得结果中取出指定范围的数据进行返回；offset为起点；count为取出的数量，若count为负则取出从offset到最后所有的元素；注意若offset很大，需要遍历从offset到最后一个元素之间的所有元素，时间复杂度为O(N)； WITHSCORES：返回值包含score； 返回值返回数组，包含元素列表；若有WITHSCORES，则同时包含scores。 代码示例12345678910111213141516171819202122232425262728293031323334353637127.0.0.1:6379&gt; zadd ss 12 a 23 b 34 c 45 d 56 e 67 f(integer) 6127.0.0.1:6379&gt; zrange ss 0 -1 # 查询队列中所有的元素1) &quot;a&quot;2) &quot;b&quot;3) &quot;c&quot;4) &quot;d&quot;5) &quot;e&quot;6) &quot;f&quot;127.0.0.1:6379&gt; zrange ss 2 -1 WITHSCORES # 查询队列中从位置2到最后的元素，包含scores1) &quot;c&quot;2) &quot;34&quot;3) &quot;d&quot;4) &quot;45&quot;5) &quot;e&quot;6) &quot;56&quot;7) &quot;f&quot;8) &quot;67&quot;127.0.0.1:6379&gt; zrange ss 45 56 BYSCORE WITHSCORES # 查询score从45到56范围内的元素1) &quot;d&quot;2) &quot;45&quot;3) &quot;e&quot;4) &quot;56&quot;127.0.0.1:6379&gt; zrange ss 56 45 REV BYSCORE WITHSCORES # 逆序，start/stop需要倒过来1) &quot;e&quot;2) &quot;56&quot;3) &quot;d&quot;4) &quot;45&quot;127.0.0.1:6379&gt; zrange ss (c [e REV BYLEX WITHSCORES # 使用BYLEX不能使用WITHSCORES(error) ERR syntax error, WITHSCORES not supported in combination with BYLEX127.0.0.1:6379&gt; zrange ss (c [e REV BYLEX # 使用REV需要将start/stop的值倒过来，否则返回空数组(empty array)127.0.0.1:6379&gt; zrange ss (c [e BYLEX # 不包含c，包含e的结果。1) &quot;d&quot;2) &quot;e&quot;127.0.0.1:6379&gt; zrange ss (c [e BYLEX LIMIT 1 1 # 取出结果中从索引1开始，1个元素1) &quot;e&quot; ZRANGESTOREZRANGESTORE dst src min max [BYSCORE | BYLEX] [REV] [LIMIT offset count] 查询方式与ZRANGE一致； 不同的是，可以将返回结果存储到指定集合中； 返回值为结果集的元素数量； 注意：不能使用WITHSCORES。 123456789101112127.0.0.1:6379&gt; zrange ss 45 56 BYSCORE WITHSCORES1) &quot;d&quot;2) &quot;45&quot;3) &quot;e&quot;4) &quot;56&quot;127.0.0.1:6379&gt; zrangestore ss2 ss 45 56 BYSCORE(integer) 2127.0.0.1:6379&gt; zrange ss2 0 -1 WITHSCORES1) &quot;d&quot;2) &quot;45&quot;3) &quot;e&quot;4) &quot;56&quot; ZRANKZRANK key member 将集合按照score大小进行排序，返回排序结果中member的位置。 排序顺序从小到大； 1234567891011127.0.0.1:6379&gt; zrange ss 0 -11) &quot;a&quot; # 0 52) &quot;b&quot; # 1 43) &quot;c&quot; # 2 3 c的正序位置在2，逆序位置在34) &quot;d&quot; # 3 25) &quot;e&quot; # 4 16) &quot;f&quot; # 5 0127.0.0.1:6379&gt; zrank ss c(integer) 2127.0.0.1:6379&gt; zrevrank ss c(integer) 3 ZREVRANKZREVRANK key member 返回集合按照score排行，反转后的member的位置； 排行按照从高到低； 返回值：若成员存在，返回成员的排行；若成员或key不存在，返回nil； ZRANGEBYLEX、ZRANGEBYSCORE （弃用）将会被ZRANGE取代； ZRANGEBYLEX key min max [LIMIT offset count] ZRANGEBYSCORE key min max [LIMIT offset count] WITHSCORES ZREVRANGE（弃用）ZREVRANGE key start stop [WITHSCORES] ZREVRANGEBYLEX（弃用）ZREVRANGEBYLEX key max min [LIMIT offset count] ZRANGEBYSCORE（弃用）ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count] 并集ZUNIONSTOREZUNIONSTORE destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREAGTE &lt;SUM | MIN MAX&gt;] 计算numkeys个集合的并集结果，对于每个相同的member，将相应的score进行处理（相加，MAX，MIN），然后存储计算结果到destination中； 在提供key和其他参数之前，必须提供numkeys； 参数介绍： 使用WEIGHTS参数，指定多个乘数，将为每个集合的score值在处理之前与指定的乘数相乘，乘法因子默认为1； 如： 设 k1 &#x3D; {a:1,b:2} k2 &#x3D; {b:3,c:4} 如：ZUNIONSTORE out 2 k1 k2 WEIGHTS 2 3 AGGREGATE SUM k1’ &#x3D; {a:2,b:4} k2’ &#x3D; {b:9,c:12} out &#x3D; {a:2,b:13,c:12} 使用AGGREGATE选项，可以指定UNION过程score的处理方法，默认为SUM； SUM：将所有score相加； MAX：取所有score最大值； MIN：取所有score最小值。 若destination中有值，则进行覆盖。 12345678910111213141516171819202122232425262728293031127.0.0.1:6379&gt; zadd s1 1 a 4 b # s1 = &#123;a:1, b:4&#125;(integer) 2127.0.0.1:6379&gt; zadd s2 4 a 5 c # s2 = &#123;a:4, c:5&#125;(integer) 2127.0.0.1:6379&gt; ZUNIONSTORE out1 2 s1 s2 WEIGHTS 2 3 # 将s1和s2进行UNION操作，AGGREGATE为SUM(integer) 3 # 结果集的值的数量127.0.0.1:6379&gt; ZRANGE out1 0 -1 WITHSCORES # 查询1) &quot;b&quot;2) &quot;8&quot; # 4x2 = 83) &quot;a&quot;4) &quot;14&quot; # 1x2 + 4x3 = 145) &quot;c&quot;6) &quot;15&quot; # 5x3 = 15127.0.0.1:6379&gt; ZUNIONSTORE out2 2 s1 s2 WEIGHTS 2 3 AGGREGATE MAX # 将s1和s2进行UNION操作，AGGREGATE为MAX(integer) 3127.0.0.1:6379&gt; ZRANGE out2 0 -1 WITHSCORES1) &quot;b&quot;2) &quot;8&quot; # 4x2 = 83) &quot;a&quot;4) &quot;12&quot; # max(1x2, 4x3) = 125) &quot;c&quot;6) &quot;15&quot; # 5x3 = 15127.0.0.1:6379&gt; ZUNIONSTORE out3 2 s1 s2 WEIGHTS 2 3 AGGREGATE MIN # 将s1和s2进行UNION操作，AGGREGATE为MIN(integer) 3127.0.0.1:6379&gt; ZRANGE out3 0 -1 WITHSCORES1) &quot;a&quot;2) &quot;2&quot; # min(2x1, 3x4) = 23) &quot;b&quot;4) &quot;8&quot;5) &quot;c&quot;6) &quot;15&quot; ZUNIONZUNION numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE &lt;SUM | MIN | MAX&gt;] [WITHSCORES] 功能类似于ZUNIONSTORE，不同的是，ZUNION将计算结果返回到客户端； 交集ZINTERZINTER numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE &lt;SUM | MIN | MAX&gt;][WITHSCORES] 将交集结果返回到客户端； 时间复杂度： O(NK)+O(Mlog(M)) N：最小有序集合 K：有序集合的数量 M：结果集元素数量 返回交集结果。 ZINTERCARDZINTERCARD numkeys key [key ...] [LIMIT limit] 返回结果集的基数； 若key为空，则被视为空集合，返回0； 默认情况下，ZINTERCARD计算集合中所有的数量，可以通过给出参数LIMIT（默认为0）来限制计算数量，这样可以减少计算加速运行； ZINTERSTOREZINTERSTORE destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE &lt;SUM | MIN |MAX&gt;] 计算交集结果并存放在destination中； 若destination原本存在，则进行覆盖。 123456789101112131415127.0.0.1:6379&gt; zrange s1 0 -1 WITHSCORES # s1 = &#123;a:1, b:4&#125;1) &quot;a&quot;2) &quot;1&quot;3) &quot;b&quot;4) &quot;4&quot;127.0.0.1:6379&gt; zrange s2 0 -1 WITHSCORES # s2 = &#123;a:4, c:5&#125;1) &quot;a&quot;2) &quot;4&quot;3) &quot;c&quot;4) &quot;5&quot;127.0.0.1:6379&gt; ZINTERSTORE out4 2 s1 s2 WEIGHTS 2 3 # 将交集计算结果存放到out4中，(integer) 1127.0.0.1:6379&gt; zrange out4 0 -1 WITHSCORES1) &quot;a&quot;2) &quot;14&quot; # 1x2 + 3x4 = 14 差集ZDIFFSTOREZDIFFSTORE destination numkeys key [key ...] 计算第一个集合与其他集合的差集，将结果存放到destination； numkeys为指定key的数量； 若destination存在，则进行覆盖。 与INTER和UNION不同，DIFF不对SCORE进行运算，而是仅使用member作为依据对集合进行差集运算。 123456789101112131415127.0.0.1:6379&gt; zrange s1 0 -1 WITHSCORES1) &quot;a&quot;2) &quot;1&quot;3) &quot;b&quot;4) &quot;4&quot;127.0.0.1:6379&gt; zrange s2 0 -1 WITHSCORES1) &quot;a&quot;2) &quot;4&quot;3) &quot;c&quot;4) &quot;5&quot;127.0.0.1:6379&gt; ZDIFFSTORE out5 2 s1 s2(integer) 1127.0.0.1:6379&gt; zrange out5 0 -1 WITHSCORES # s1与s2的差集为&#123;b:4&#125;1) &quot;b&quot; 2) &quot;4&quot; ZDIFFZDIFF numkeys key [key ...] [WITHSCORES] 功能类似于ZDIFFSTORE，不同的是，ZDIFF将计算结果返回到客户端；","categories":[],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://zswh33.github.io/tags/Redis/"}]},{"title":"Redis 2 List Set","slug":"Redis-2","date":"2022-09-20T11:23:31.000Z","updated":"2022-09-22T03:04:15.051Z","comments":true,"path":"2022/09/20/Redis-2/","link":"","permalink":"http://zswh33.github.io/2022/09/20/Redis-2/","excerpt":"","text":"ListRedis List就是双端链表； Redis List 实现字符串的链表，可以用来： 实现栈和队列； 为后台系统提供队列管理。比如应用将任务push到List队列，工作线程使用pop操作将任务取出并执行。 一些简单的使用实现一个队列（先进先出）123456789101112127.0.0.1:6379&gt; lpush work:queue 1(integer) 1127.0.0.1:6379&gt; lpush work:queue 2(integer) 2127.0.0.1:6379&gt; lpush work:queue 3(integer) 3127.0.0.1:6379&gt; rpop work:queue&quot;1&quot;127.0.0.1:6379&gt; rpop work:queue&quot;2&quot;127.0.0.1:6379&gt; rpop work:queue&quot;3&quot; lpush，左边推入，rpop，右边弹出。 实现一个栈（先进，后出）123456789101112127.0.0.1:6379&gt; lpush work:queue 1(integer) 1127.0.0.1:6379&gt; lpush work:queue 2(integer) 2127.0.0.1:6379&gt; lpush work:queue 3(integer) 3127.0.0.1:6379&gt; lpop work:queue&quot;3&quot;127.0.0.1:6379&gt; lpop work:queue&quot;2&quot;127.0.0.1:6379&gt; lpop work:queue&quot;1&quot; lpush，左边推入，lpop，左边弹出。 获得链表的长度12345678127.0.0.1:6379&gt; lpush q2 1(integer) 1127.0.0.1:6379&gt; lpush q2 2(integer) 2127.0.0.1:6379&gt; lpush q2 3(integer) 3127.0.0.1:6379&gt; llen q2(integer) 3 llen，获取链表长度。 原子性地从一个列表弹出并放进另一个列表12345678910127.0.0.1:6379&gt; lpush q-todo 101(integer) 1127.0.0.1:6379&gt; lpush q-todo 102(integer) 2127.0.0.1:6379&gt; lmove q-todo q-progress LEFT LEFT&quot;102&quot;127.0.0.1:6379&gt; lrange q-todo 0 -11) &quot;101&quot;127.0.0.1:6379&gt; lrange q-progress 0 -11) &quot;102&quot; 先向队列q-todo里面添加101，102； 然后使用lmove，将q-todo里的左边取出移动到q-progress的左边。 即：从一个列表弹出数据并放进另一个列表。 这是一个原子性地不可分割的操作。 LEFT指定左边，RIGHT指定右边 限制最大长度为2^32-1(4_294_967_295)个元素。 命令lpush 添加lpush key element [element ...] 向key依次推入多个element元素； 若key为空则创建队列；若key有值且为其他类型，则返回error； 返回值为push后的队列长度。 lpushx 没有则添加lpushx key element [element ...] 与lpush类似，不同的是： 仅当key存在时，才会执行； 若key不存在则不会执行 返回值为push后的长度 lrange 查询lrange key start stop 返回指定范围的key队列内的元素，start从0开始，-1表示最后一个元素； 若超出范围不会发生错误，若start超出列表长度，则返回一个空列表；若stop大于列表长度，Redis会视为列表的最后一个元素。 获取的值是否包含stop所在位置，依据不同编程语言进行处理。 lrem 删除返回数量lrem key count element 删除key队列里指定数量的element count值决定删除的数量和删除的起点 count &gt; 0 ，从起点开始寻找并删除队列里与element相同的值，删除数量为count； count &lt; 0 ，从队列尾部删除值； count &#x3D; 0 ，删除所有的与element相同的值。 返回值为删除的数量。 1234567891011121314151617127.0.0.1:6379&gt; lpush c 1 2 3 4 2 3 2 1 4 2 3 4 2 5 2(integer) 15127.0.0.1:6379&gt; lrem c 3 2(integer) 3127.0.0.1:6379&gt; lrange c 0 -1 1) &quot;5&quot; 2) &quot;4&quot; 3) &quot;3&quot; 4) &quot;4&quot; 5) &quot;1&quot; 6) &quot;2&quot; 7) &quot;3&quot; 8) &quot;2&quot; 9) &quot;4&quot;10) &quot;3&quot;11) &quot;2&quot;12) &quot;1&quot; lset 设置lset key index element 设置key的index位置的值为element。 ltrim 截取ltrim key start stop 使队列仅包含指定范围的值。 超出范围不会报错；若start大于length或start大于stop，会变成空队列（即删除这个队列）；若stop大于length，则视为最后一个元素。 12345678127.0.0.1:6379&gt; lpush q2 a b c d e # q2中有 e d c b a(integer) 5127.0.0.1:6379&gt; ltrim q2 1 3 # 取出其中的1~3OK127.0.0.1:6379&gt; lrange q2 0 -1 # 即 d c b1) &quot;d&quot;2) &quot;c&quot;3) &quot;b&quot; lpop 删除并返回值lpop key [count] 删除指定数量的元素并返回指定数量的元素。 1234127.0.0.1:6379&gt; lpop c 31) &quot;5&quot;2) &quot;4&quot;3) &quot;3&quot; lpos 寻找lpos key value [RANK level] [COUNT num-matches] 说明 检索指定值的位置； 在key数列中寻找value的位置，返回位置的索引； 参数 RANK，数列中可能有多个与value相同的值，RANK指定返回第几个value的值； COUNT，指定要返回的数量。 RANK可以和COUNT一起使用，将返回从第level个开始，COUNT数量个值。 返回值 若成功匹配，返回一个数组； 若未使用COUNT且没有匹配到value，则返回nil； 若使用COUNT没有匹配到value，返回空数列。 1234567891011121314151617181920127.0.0.1:6379&gt; lrange c 0 -11) &quot;4&quot;2) &quot;1&quot;3) &quot;2&quot;4) &quot;3&quot;5) &quot;2&quot;6) &quot;4&quot;7) &quot;3&quot;8) &quot;2&quot;9) &quot;1&quot;127.0.0.1:6379&gt; lpos c 2 RANK -2 #获取c中的“2”，从尾部到头部第二个(integer) 4127.0.0.1:6379&gt; lpos c 2 COUNT 3 #获取c中的&quot;2&quot;，获取3个。1) (integer) 22) (integer) 43) (integer) 7127.0.0.1:6379&gt; lpos c 2 count 3 rank -1 #从尾部的第一个开始，获取三个数量的位置1) (integer) 72) (integer) 43) (integer) 2 lmove 移动到另一个队列lmove source destination &lt;LEFT | RIGHT&gt; &lt;LEFT | RIGHT&gt; 将source的元素移动到destination中； LEFT表示左边，RIGHT表示右边； lmpop 多key弹出lmpop numkeys key [key ...] &lt;LEFT |RIGHT&gt; [COUNT count] 依次从多个key对应的队列中弹出数据，可以指定数量和方向； numkeys：输入的key的数量； 举例： 1234lmpop 2 q1 q2 LEFT COUNT 3 # 2为key的数量，这里有两个key：q1 q2# LEFT为方向，也可以是RIGHT# 3为数量，这里指一次弹出三个值。 运行过程： 首先判断q1中是否有元素，若有则弹出； 若数量不足三个，则弹出剩余的值； 若q1为空，则从q2中弹出； 若q1的数量不足三个，不用q2中的补足数量； 若数量不足三个，弹出剩余的值。 若都为空，则返回nil； 示例： 123456789101112131415161718192021222324252627282930313233127.0.0.1:6379&gt; lpush q1 1 2 3 4 5 #首先在q1中输入 1 2 3 4 5(integer) 5127.0.0.1:6379&gt; lpush q2 a b c d e # 在q2中输入 a b c d e(integer) 5# 方向RIGHT 数量4 key数量为2 两个key：q1 q2127.0.0.1:6379&gt; lmpop 2 q1 q2 RIGHT COUNT 4 1) &quot;q1&quot;2) 1) &quot;1&quot; 2) &quot;2&quot; 3) &quot;3&quot; 4) &quot;4&quot;# 弹出q1中右边开始的4个值# 方向RIGHT，数量4 key数量2 两个key: q1 q2127.0.0.1:6379&gt; lmpop 2 q1 q2 RIGHT COUNT 41) &quot;q1&quot;2) 1) &quot;5&quot;# q1中只剩下5 ，则弹出# 方向RIGHT，数量4 key数量2 两个key: q1 q2127.0.0.1:6379&gt; lmpop 2 q1 q2 RIGHT COUNT 41) &quot;q2&quot;2) 1) &quot;a&quot; 2) &quot;b&quot; 3) &quot;c&quot; 4) &quot;d&quot;# 弹出q2中右边开始的4个值127.0.0.1:6379&gt; lmpop 2 q1 q2 RIGHT COUNT 41) &quot;q2&quot;2) 1) &quot;e&quot;# q2中只剩下一个“e”，所以弹出127.0.0.1:6379&gt; lmpop 2 q1 q2 RIGHT COUNT 4(nil)# 若两个队列都为空，则返回nil llen 长度llen key 获取队列长度。 linsert 插入到已知值附近linsert key &lt;BEFORE | AFTER&gt; pivot element 插入element到key对应队列的值为pivot的前面或后面。 pivot：参考位置的值； 返回值： 若成功，返回队列的长度； 若pivot没有被找到，返回-1； 1234567891011121314127.0.0.1:6379&gt; lpush q1 1 2 3 4 5 # q1中有5 4 3 2 1(integer) 5127.0.0.1:6379&gt; linsert q1 BEFORE 3 q # 在3的前面插入q(integer) 6127.0.0.1:6379&gt; linsert q1 after 4 w # 在4的后面插入w(integer) 7127.0.0.1:6379&gt; lrange q1 0 -1 # 获取所有值1) &quot;5&quot;2) &quot;4&quot;3) &quot;w&quot; # w在4的后面4) &quot;q&quot; # q在3的前面5) &quot;3&quot;6) &quot;2&quot;7) &quot;1&quot; lindex 依据索引获得值lindex key index 返回索引为index的位置的值； 1234127.0.0.1:6379&gt; lpush q1 1 2 3 4 5 # q1为 5 4 3 2 1 (integer) 5127.0.0.1:6379&gt; lindex q1 3 # 返回索引为4的值&quot;2&quot; R系列 从右边开始操作RPOP key [count]：从队列右边弹出指定数量的数据，空则返回nil； RPUSH key element [element ...]：从队列右边添加数据，返回操作后队列的长度，若key不存在则创建队列； RPUSHX key element [element ...]：类似于RPUSH，若key不存在则不执行任何操作。 blmove 阻塞的元素移动blmove source destination &lt;LEFT | RIGHT&gt; &lt;LEFT | RIGHT&gt; timeout lmove的带阻塞功能的版本； 可以将队列中的数据从一个队列A移动到另一个队列B； 阻塞功能：若队列A为空，Redis会对连接进行阻塞，直到另一个客户端为队列A加入内容； timeout最长等待时间，为零可以无限期阻塞； 返回值为一组字符串；若timeout到达时，返回null； blmpop 阻塞的多数据弹出blmpop timeout numkeys key [key ...] &lt;LEFT | RIGHT&gt; [COUNT count] 超时返回nil； blpop 阻塞的数据弹出BLPOP key [key ...] timeout 相对于lpop，可以有多个key，Redis将依照key依次检索，直到有key的队列不为空，弹出并返回； timeout可以为0，表示无限期等待。 brpop 阻塞的数据弹出，从右边开始BRPOP key [key ...] timeout SetRedis Set通过哈希表实现；添加、删除、查找的复杂度都是O(1)； Redis Set是String的无序集合，集合成员是惟一的，不可重复的； 可以用来 标签，为用户添加标签； 点赞、踩、收藏的数量，用set实现； 集合的操作：并集、交集和差集。 例子 存储A和B喜欢的书的id 12345678127.0.0.1:6379&gt; sadd user:A:favorites 1 # 用户A喜欢id为1的书籍(integer) 1127.0.0.1:6379&gt; sadd user:A:favorites 2 # 用户A喜欢id为2的书籍(integer) 1127.0.0.1:6379&gt; sadd user:A:favorites 3 # 用户A喜欢id为3的书籍(integer) 1127.0.0.1:6379&gt; sadd user:B:favorites 2 # 用户B喜欢id为2的书籍(integer) 1 检查用户A是否喜欢书籍2和书籍5 1234127.0.0.1:6379&gt; sismember user:A:favorites 2 # A喜欢书2(integer) 1127.0.0.1:6379&gt; sismember user:A:favorites 5 # A不喜欢书5(integer) 0 用户A和用户B有共同喜欢的书 12127.0.0.1:6379&gt; sinter user:A:favorites user:B:favorites 1) &quot;2&quot; # A和B都喜欢书2 用户A喜欢几本书 12127.0.0.1:6379&gt; scard user:A:favorites(integer) 3 限制最大大小2^32-1个成员 基本命令SADD 将新成员添加到集合中； SREM 从集合中删除指定成员； SISMEMBER 测试集合中是否存在某个成员； SINTER 返回两个或多个集合共有成员集合（交集）； SCARD 返回集合大小。 完整命令SADD 添加SADD key member [member ...] 添加指定的成员作为集合到key中； 若成员原本就在集合中，则不添加； 若key不存在，则创建一个集合并将成员添加到集合中； 若key存在且不是一个set，则返回错误； 返回添加到集合成员的数量，不包含原本在集合的成员。 12345678127.0.0.1:6379&gt; sadd s1 q w e r t(integer) 5127.0.0.1:6379&gt; smembers s11) &quot;r&quot;2) &quot;e&quot;3) &quot;w&quot;4) &quot;q&quot;5) &quot;t&quot; SMOVE 移动成员SMOVE source destination member 移动成员member从source到destination中； 这是一个原子性操作，在执行期间，对于其他客户端，这个成员将同时属于source和destination； 如果source不存在或不包含指定元素，操作将不会执行且返回0； 若指定元素已经存在于destination中，则元素仅仅从source中删除； 若source或destination不是set类型，则返回错误。 返回1表示执行成功，0表示操作未执行； 1234567891011121314127.0.0.1:6379&gt; sadd s1 q w e(integer) 3127.0.0.1:6379&gt; sadd s2 z x c(integer) 3127.0.0.1:6379&gt; smove s1 s2 w # 将w从s1移动到s2(integer) 1127.0.0.1:6379&gt; smembers s11) &quot;e&quot;2) &quot;q&quot;127.0.0.1:6379&gt; smembers s21) &quot;x&quot;2) &quot;z&quot;3) &quot;w&quot;4) &quot;c&quot; SREM 移除成员srem key member [member ...] 从set中移除指定成员； 若指定成员不存在，则忽略； 若key不存在将返回0。 成功返回移除的数量，不包括之前本就不存在的对象。 12345678127.0.0.1:6379&gt; sadd s1 q w e r t(integer) 5127.0.0.1:6379&gt; srem s1 w e # 从q1中移除了w和e(integer) 2127.0.0.1:6379&gt; smembers s11) &quot;r&quot;2) &quot;q&quot;3) &quot;t&quot; SPOP 移除并返回成员spop key [count] 从set移除并返回一个或多个随机成员； 若不指定数量，默认弹出一个成员； 若提供数量，将移除并返回指定数量的成员； 返回值： 若没有指定count，则返回删除的对象，若key不存在返回nil； 若指定了count，则返回删除的对象，若key不存在返回一个空数组。 12345678910111213127.0.0.1:6379&gt; smembers s1 # s1的所有对象1) &quot;r&quot;2) &quot;q&quot;3) &quot;t&quot;127.0.0.1:6379&gt; spop s1 2 # 弹出s1中两个对象1) &quot;q&quot;2) &quot;r&quot;127.0.0.1:6379&gt; spop s1 2 # 弹出s1中两个对象，目前只剩下一个对象，所以弹出一个对象；1) &quot;t&quot;127.0.0.1:6379&gt; spop s1 2 # 指定count，返回空数组(empty array)127.0.0.1:6379&gt; spop s1 # 不指定count，返回nil(nil) SCARD 成员数量scard key 返回集合中成员的数量 1234127.0.0.1:6379&gt; sadd s1 q w e r t(integer) 5127.0.0.1:6379&gt; scard s1(integer) 5 SDIFFsdiff key [key ...] 返回第一个set与其他指定set的差集 123456789127.0.0.1:6379&gt; sadd s1 q w e r t(integer) 5127.0.0.1:6379&gt; sadd s2 a w e d f(integer) 5127.0.0.1:6379&gt; sadd s3 q z x c g(integer) 5127.0.0.1:6379&gt; sdiff s1 s2 s3 # s1与s2、s3的差集1) &quot;r&quot;2) &quot;t&quot; SDIFFSTOREsdiffstore destination key [key ...] 功能类似于sdiff，不同的是，sdiffstore会将差集结果存放到destination里，返回值变为差集结果的长度； 若destination中已存在值，则覆盖。 123456789127.0.0.1:6379&gt; sadd s1 q w e r t(integer) 5127.0.0.1:6379&gt; sadd s2 q w e(integer) 3127.0.0.1:6379&gt; sdiffstore s3 s1 s2(integer) 2127.0.0.1:6379&gt; smembers s31) &quot;r&quot;2) &quot;t&quot; SINTERsinter key [key ...] 返回给定所有set的交集； 不存在的键被认为是空集，即结果也为空集。 1234567127.0.0.1:6379&gt; sadd s1 q w e r t(integer) 5127.0.0.1:6379&gt; sadd s2 q w z x c(integer) 5127.0.0.1:6379&gt; sinter s1 s21) &quot;w&quot;2) &quot;q&quot; SINTERCARDsintercard numkeys key [key ...] [LIMIT limit] numkeys：key的数量； 功能类似于sinter，返回多个集合交集结果集的元素数量，； limit可以限制计算数量，若计算数量达到limit，则返回limit； 1234127.0.0.1:6379&gt; sintercard 2 s1 s2(integer) 2127.0.0.1:6379&gt; sintercard 2 s1 s2 limit 1(integer) 1 SINTERSTOREsinterstore destination key [key ...] numskeys：key的数量； 功能类似于sinter，不同的是sinterstore将交集的结果存放到destination，返回值为长度； 若destination已存在，则进行覆盖。 12345678910127.0.0.1:6379&gt; sadd q1 q w e r t(integer) 5127.0.0.1:6379&gt; sadd q2 q w e a s(integer) 5127.0.0.1:6379&gt; sinterstore q3 q1 q2(integer) 3127.0.0.1:6379&gt; smembers q31) &quot;q&quot;2) &quot;w&quot;3) &quot;e&quot; SISMEMBERsismember key member Set IsMember 判断在集合中是否存在member； 存在返回1，不存在返回0。 12345678127.0.0.1:6379&gt; smembers q31) &quot;q&quot;2) &quot;w&quot;3) &quot;e&quot;127.0.0.1:6379&gt; sismember q3 w(integer) 1127.0.0.1:6379&gt; sismember q3 t(integer) 0 SMEMBERSsmembers key 返回集合中所有对象。 当sinter中只有一个key，则等价于sinter。 SMISMEMBERsmismember key member [member ...] Set Multi Member 同时判断集合中是否存在多个指定的对象。 返回一个数组，数组中元素依次表示对象是否包含在集合中，1表示包含，0表示不包含。 123456789127.0.0.1:6379&gt; smembers q31) &quot;q&quot;2) &quot;w&quot;3) &quot;e&quot;127.0.0.1:6379&gt; smismember q3 q w s d1) (integer) 12) (integer) 13) (integer) 04) (integer) 0 SRANDMEMBERSRANDMEMBER key [count] Set RANdom Member 基数：集合中对象的数量。 随机取出集合中指定数量的对象； 若count为正，返回count数量的对象，若集合基数小于count，则返回基数个对象； 若count为负，返回count绝对值数量的对象，若集合基数小于count的绝对值，则仍旧返回count绝对值数量的对象。 负数的count返回的对象中存在重复的对象。 返回值： 若有count属性，返回一个数组，若key不存在或为空，返回空数组； 若没有count属性，返回一个对象，若key不存在或为空，返回nil。 123456789101112131415161718192021222324252627282930127.0.0.1:6379&gt; smembers q1 # q1中所有对象1) &quot;q&quot;2) &quot;w&quot;3) &quot;r&quot;4) &quot;e&quot;5) &quot;t&quot;127.0.0.1:6379&gt; srandmember q1 3 # q1中随机取出3个对象1) &quot;w&quot;2) &quot;e&quot;3) &quot;r&quot;127.0.0.1:6379&gt; srandmember q1 10 # q1中随机取出10个对象，由于q1基数为5，所以取出5个对象1) &quot;q&quot;2) &quot;w&quot;3) &quot;r&quot;4) &quot;e&quot;5) &quot;t&quot;127.0.0.1:6379&gt; srandmember q1 -3 # q1中随机取出 |-3| 个对象，负数count取出的内容中存在重复1) &quot;r&quot;2) &quot;r&quot;3) &quot;e&quot;127.0.0.1:6379&gt; srandmember q1 -9 # |-9|大于基数5，取出9个对象，内有重复。1) &quot;w&quot;2) &quot;q&quot;3) &quot;w&quot;4) &quot;w&quot;5) &quot;e&quot;6) &quot;q&quot;7) &quot;w&quot;8) &quot;e&quot;9) &quot;q&quot; SUNIONsunion key [key ...] 返回多个集合的并集； 若key不存在视集合为空集； 1234567891011121314151617181920127.0.0.1:6379&gt; smembers q11) &quot;q&quot;2) &quot;w&quot;3) &quot;t&quot;4) &quot;e&quot;5) &quot;r&quot;127.0.0.1:6379&gt; smembers q21) &quot;q&quot;2) &quot;w&quot;3) &quot;e&quot;4) &quot;s&quot;5) &quot;a&quot;127.0.0.1:6379&gt; sunion q1 q21) &quot;q&quot;2) &quot;w&quot;3) &quot;t&quot;4) &quot;e&quot;5) &quot;s&quot;6) &quot;a&quot;7) &quot;r&quot; SUNIONSTOREsunionstore destination key [key ...] 等价于sunion，不同的是，sunionstore会将并集的结果存放于destination中。","categories":[],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://zswh33.github.io/tags/Redis/"}]},{"title":"Redis 1 介绍 结构 bitmaps","slug":"Redis-1","date":"2022-09-19T08:08:26.000Z","updated":"2022-09-23T08:10:56.924Z","comments":true,"path":"2022/09/19/Redis-1/","link":"","permalink":"http://zswh33.github.io/2022/09/19/Redis-1/","excerpt":"","text":"Redishttps://pdai.tech/md/db/nosql-redis/db-redis-overview.html https://redis.io/docs/data-types/ 介绍Redis是一种支持key-value等多种数据结构的存储系统。可用于缓存，事件发布或订阅、高速队列等场景，支持网络，提供字符串、哈希、列表、队列、集合结构直接存取，基于内存，可持久化。 数据结构 基础数据类型 Redis数据类型：String、List、Set、Hash、Sorted set、Stream。 结构类型 结构存储的值 结构的读写能力 String 可以是字符串、整数或浮点数 对字符串或字符串的一部分进行操作；对整数或浮点数进行自增或自建操作 List 一个链表，链表上每个节点都包含一个字符串 对链表的两端进行push和pop操作；读取单个或多个元素；根据值查找或删除元素； Set 包含字符串的无序集合 字符串的集合，包含基础的方法：添加、删除、查询、isExist；支持交集，并集，差集等； Hash 包含键值对的无序散列表 添加、获取、删除 Zset 与Hash一样，存储键值对 字符串成员与浮点数分数之间的有序映射；元素的排列依据分数大小排序决定；包含添加、删除、获取；查询支持按照score范围或成员来获取元素。 简述对于Redis来说，所有key都是字符串； StringString存储字节序列，可以是文本、序列化对象和二进制数组； 通常用于缓存； 可以进行按位操作。 使用&#x2F;场景一些场景缓存：把常用信息，字符串、图片或饰品等信息放到redis，Redis作为缓存层，MySQL作为持久化层，均衡MySQL的读写压力； 计数器：Redis是单线程模型，一个命令执行完才会去执行下一个； Session：使用SpringSession+Redis实现Session共享。 设置值、获取值12345127.0.0.1:6379&gt; set user:1 uwupuOK127.0.0.1:6379&gt; get user:1&quot;uwupu&quot;127.0.0.1:6379&gt; set user:1 uwupu ：设置user:1的值为uwupu； get user:1：获取user:1的值。 存储一个序列化JSON字符串，并设定100秒后过期12127.0.0.1:6379&gt; set ticket:1 &quot;&#123;&#x27;username&#x27;:&#x27;zhangsan&#x27;,&#x27;name&#x27;:&#x27;zs123&#x27;&#125;&quot; EX 100OK 设置一个ticket:1并在100秒后过期； 一个计数器1234567127.0.0.1:6379&gt; incr views:page:2(integer) 1127.0.0.1:6379&gt; incrby views:page:2 10(integer) 11127.0.0.1:6379&gt; incrby views:page:2 5(integer) 16127.0.0.1:6379&gt; incr views:page:2：设置一个计数器； incrby views:page:2 10：使得计数器增加。 限制默认情况下，单个Redis字符串最大为512MB。 基本命令获取和设置字符串 SET：存储一个字符串值。 set apple 3 SETNX：当键不存在时，存储字符串值，可以用于实现锁。 SETNX apple 3 GET：获取&#x2F;检索字符串值。 GET apple &gt; 3 MGET：在单个操作中获取多个字符串值 1234567891011127.0.0.1:6379&gt; set a 1OK127.0.0.1:6379&gt; set b 2OK127.0.0.1:6379&gt; set c 3OK127.0.0.1:6379&gt; mget a b c1) &quot;1&quot;2) &quot;2&quot;3) &quot;3&quot;127.0.0.1:6379&gt; 管理计数器INCR：创建一个计数器； INCRBY：使得计数器增加指定值。 12345678127.0.0.1:6379&gt; incr apple(integer) 1127.0.0.1:6379&gt; incr apple(integer) 2127.0.0.1:6379&gt; incrby apple 3(integer) 5127.0.0.1:6379&gt; incrby apple 7(integer) 12 其他命令 APPEND key value：追加字符串到key的后面，如果key不存在则创建key并将值赋值；返回添加后value的长度； 123456127.0.0.1:6379&gt; set a 123OK127.0.0.1:6379&gt; append a qwe(integer) 6127.0.0.1:6379&gt; get a&quot;123qwe&quot; DECR key：若key为整数，则将减一的值赋值给key。仅支持64位有符号整数。返回结果值； 1234127.0.0.1:6379&gt; set a 123OK127.0.0.1:6379&gt; decr a(integer) 122 DECRBY key value：若key为整数，将key减少指定大小； GETDEL key：获得值然后删除该变量； GETEX key [EX 秒 | PX 毫秒]：获得Key值并为key设定过期时间；返回key，若key不存在返回nil。 12127.0.0.1:6379&gt; getex a EX 300&quot;122&quot; GETRANGE key start end：截取字符串并返回。start和end可以为负，若为负表示从字符串末尾截取； 12345678127.0.0.1:6379&gt; set asd &quot;This is a Obsidian&quot;OK127.0.0.1:6379&gt; GETRANGE asd 0 6&quot;This is&quot;127.0.0.1:6379&gt; GETRANGE asd 4 10&quot; is a O&quot;127.0.0.1:6379&gt; GETRANGE asd -5 -1&quot;idian&quot; GETSET key value：返回当前值，然后设置新的值； 123456127.0.0.1:6379&gt; set a 123OK127.0.0.1:6379&gt; getset a 234&quot;123&quot;127.0.0.1:6379&gt; get a&quot;234&quot; INCR key：若值为整数，则赋值加一后的结果。返回值为结果值； INCRBY key increment：为值增加指定的整数； INCRBYFLOAT key increment：若值可以为浮点数，则设置值为原来的值加上increment；这个可以增加浮点数。 1234127.0.0.1:6379&gt; set a 123OK127.0.0.1:6379&gt; incrbyfloat a 1.23&quot;124.23&quot; LCS key1 key2 [LEN] [IDX] [MINMATCHLEN len][WITHMATCHLEN]：实现最长公共子序列算法。 匹配的字符串不需要连续，如：”asdqwe”和”asqzxe”的结果是”asqe”。 123456127.0.0.1:6379&gt; set a asdqweOK127.0.0.1:6379&gt; set b asqzxeOK127.0.0.1:6379&gt; lcs a b&quot;asqe&quot; 一般用于比较两个序列之间的相似程度。 算法O(N*M)复杂度较高，尽量运行在较小的字符串上； 加上LEN会返回匹配的长度； 1234127.0.0.1:6379&gt; mset a asdqwe b asqzxeOK127.0.0.1:6379&gt; lcs a b LEN(integer) 4 加上IDX将返回匹配的位置 12345678910111213141516127.0.0.1:6379&gt; lcs a b IDX1) &quot;matches&quot;2) 1) 1) 1) (integer) 5 2) (integer) 5 2) 1) (integer) 5 2) (integer) 5 2) 1) 1) (integer) 3 2) (integer) 3 2) 1) (integer) 2 2) (integer) 2 3) 1) 1) (integer) 0 2) (integer) 1 2) 1) (integer) 0 2) (integer) 13) &quot;len&quot;4) (integer) 4 其中，在**2)中有1),2),3)**三组序列，每组序列表示一组匹配列表； 12341) 1) (integer) 5 2) (integer) 52) 1) (integer) 5 2) (integer) 5 这个是在 2) -&gt; 1)下的内容，其中1）下的两个值为在key1中匹配的起点终点，2）下的两个值时在key2中匹配的起点和重点，其他依次类推。 MGET key [key ...]：一次获得多个值。 12345127.0.0.1:6379&gt; mset a 10 b 20OK127.0.0.1:6379&gt; mget a b1) &quot;10&quot;2) &quot;20&quot; MSET key value[ key value …]：一次设置多个key和值 MSETNX key value[ key value …]：一次声明且设置多个之前不存在的key和值；若key存在，则失败，返回0；若成功，则返回1。 12345678127.0.0.1:6379&gt; msetnx x 1 y 2(integer) 1127.0.0.1:6379&gt; msetnx x 1 z 3(integer) 0127.0.0.1:6379&gt; mget x y z1) &quot;1&quot;2) &quot;2&quot;3) (nil) PSETEX key milliseconds value：设置key和value，并设置过期时间，单位为毫秒。与setex不同的是，时间以毫秒为单位，setex时间以秒为单位。即将被弃用 123456127.0.0.1:6379&gt; psetex a 1000 bOK127.0.0.1:6379&gt; get a&quot;b&quot;127.0.0.1:6379&gt; get a(nil) SET key value [NX | XX] [GET] [EX 秒 | PX 毫秒 | EXAT unit-time-sexonds | PXAT unit-time-milliseconds | KEEPTTL] 设置key和value。若key不为 EX：设置指定的过期时间，单位秒； PX：设置指定的过期时间，单位毫秒； EXAT：Unix时间，单位秒； PXAT：Unit时间，单位毫秒； NX：当Key不存在时设置； XX：当key存在时设置； KEEPTTL：获取Key的过期时间； GET：返回key原来的值，若key不存在返回nil。 返回值： OK：成功返回ok； nil：若get的值为nil，则返回nil；若因为NX或XX导致SET未执行操作，返回nil； 字符串：若get的值不为nil，返回原来字符串的值。 SETEX、SETNX：设置过期时间，即将被弃用。 SETRANGE key offset value：从key值的offset位置开始，设置值为value。 12345678127.0.0.1:6379&gt; set key &quot;HelloWorld&quot;OK127.0.0.1:6379&gt; set a &quot;HelloWorld&quot;OK127.0.0.1:6379&gt; setrange a 5 Redis(integer) 10127.0.0.1:6379&gt; get a&quot;HelloRedis&quot; STRLEN key：获取字符串长度。 1234127.0.0.1:6379&gt; set a &quot;HelloWorld&quot;OK127.0.0.1:6379&gt; strlen a(integer) 10 SUBSTR key start end：截取字符串。 1234127.0.0.1:6379&gt; set a &quot;HelloWorld&quot;OK127.0.0.1:6379&gt; substr a 2 5&quot;lloW&quot; bitmaps 通过二进制修改&#x2F;获取String的值将String编码为二进制格式，bitmaps可以获取或设定二进制数列的每个位置的值。 SETBIT key offset 0&#x2F;1：设定key的二进制位第offset位的值； GETBIT key offset：获取key的二进制位第offset位的值； offset在二进制数列里，从前往后数。0为起始位置。 12345678910111213141516171819202122127.0.0.1:6379&gt; set num 0OK127.0.0.1:6379&gt; getbit num 0(integer) 0127.0.0.1:6379&gt; getbit num 1(integer) 0127.0.0.1:6379&gt; getbit num 2(integer) 1127.0.0.1:6379&gt; getbit num 3(integer) 1127.0.0.1:6379&gt; getbit num 4(integer) 0127.0.0.1:6379&gt; getbit num 5(integer) 0127.0.0.1:6379&gt; getbit num 6(integer) 0127.0.0.1:6379&gt; getbit num 7(integer) 0127.0.0.1:6379&gt; setbit num 5 1(integer) 0127.0.0.1:6379&gt; get num&quot;4&quot; 先**设置num的值为’0’**， 然后获取0-7位置上的二进制数字，分别为：00110000，对应’0’的ansi码； 设置第5位的二进制数位为1后，获取num的值，值变成了4。 其他命令bitcount返回字节位数； 1234127.0.0.1:6379&gt; set apple sweet,niceOK127.0.0.1:6379&gt; bitcount apple(integer) 43 bitfield将字符串作为位数组，允许对位域的值进行获取、修改和自增自减。 子命令列表 GET type offset 获取位域的值，以十进制返回； SET type offset value 设置位域的值，并返回原来的值； INCRBY type offset increment，自增\\自减指定位域的值并返回新值。 type offset 解释 type：即位域的类型； i表示有符号整数，u表示无符号整数。 例： i8：8位有符号整数； u8：8位无符号整数； i16：16位有符号整数。 offset：即位移偏移量。 使用 GET 123456789127.0.0.1:6379&gt; set apple sweetAndNiceOK127.0.0.1:6379&gt; bitfield apple GET i8 01) (integer) 115127.0.0.1:6379&gt; bitfield apple GET i8 81) (integer) 119127.0.0.1:6379&gt; bitfield apple GET i8 161) (integer) 101127.0.0.1:6379&gt; 设定apple的值为sweetAndNice后； 以有符号整数的形式获取位于0,8,16位域的值，分别为115,119,101，分别对应s、w、e。 SET 设置位域的值，并返回原来的值； 1234127.0.0.1:6379&gt; bitfield apple set i8 0 1171) (integer) 115127.0.0.1:6379&gt; get apple&quot;uweetAndNice&quot; 以i8形式设置位置0的位域的值为117。 INCRBY 1234127.0.0.1:6379&gt; bitfield apple incrby i8 0 31) (integer) 120127.0.0.1:6379&gt; get apple&quot;xweetAndNice&quot; 以i8形式为位置0的位域的值增加3。 OVERFLOW 改变当INCRBY子命令发生溢出情况时的行为。 可以有的值：WRAP SAT FAIL WRAP：默认值。若为无符号数，则按照最大值进行取模运算；若为有符号数，对于结果的取值，上溢取溢出值与最小值相加的值，下溢取最大值与溢出值相减的值，与C语言类似； SAT：若上溢，则使值控制在最大值；若下溢，则使值控制在最小值。如：若最大值为127，则120 加 10结果为127； FAIL：若发生溢出，取消本次操作，返回null向调用者发送错误信号。 123456789OK127.0.0.1:6379&gt; bitfield a OVERFLOW WRAP INCRBY i8 0 12341) (integer) 3127.0.0.1:6379&gt; bitfield a OVERFLOW SAT INCRBY i8 0 12341) (integer) 127127.0.0.1:6379&gt; bitfield a OVERFLOW FAIL INCRBY i8 0 12341) (nil)127.0.0.1:6379&gt; get a&quot;\\x7f23&quot; bitfield_ro类似于bitfield，但是只接受get子命令； 因为bitfield有改变数值的选项，所以在技术上被标记为redis的写入命令； （存疑）Redis可以有主节点和副本节点，副本节点是主节点的副本； 若bitfield命令向副本节点发送操作，副本节点会将操作转发到主节点进行操作，而不是在副本中操作； bitfield_ro命令也会向副本节点发送操作，但bitfield_ro的操作不会被转发到主节点，在副本节点中获取数据后直接返回。（可能会存在旧数据） bitopBITOP支持四种与运算：AND、OR、XOR和NOT。 dest 目标 src 来源 BITOP AND destkey srckey1 srckey2 srckey3 … srckeyN BITOP OR destkey srckey1 srckey2 srckey3 … srckeyN BITOP XOR destkey srckey1 srckey2 srckey3 … srckeyN BITOP NOT destkey srckey NOT只需要一个参数。 运算结果存放在dest中，依据srckey进行计算。 bitpos1BITPOS key bit [start [end [BYTE | BIT]]] 将字符串数据作为一个位数组，获取指定范围第一个1或0的位置。 bit值为1&#x2F;0，表示指定1或者0； 使用start和end指定范围；","categories":[],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://zswh33.github.io/tags/Redis/"}]},{"title":"SpringBoot 一些杂项","slug":"SpringBoot-一些杂项","date":"2022-09-18T08:50:00.000Z","updated":"2022-10-05T13:11:43.217Z","comments":true,"path":"2022/09/18/SpringBoot-一些杂项/","link":"","permalink":"http://zswh33.github.io/2022/09/18/SpringBoot-%E4%B8%80%E4%BA%9B%E6%9D%82%E9%A1%B9/","excerpt":"","text":"Spring Cachehttps://docs.spring.io/spring-framework/docs/current/reference/html/integration.html#cache-annotations Spring提供了能够缓存方法调用结果的注解：@Cacheable，@CacheEvict，@CachePut，@Caching，@CacheConfig。 该注解可以用在任何方法中。 @Cacheable使用@Cacheable可以注解在需要缓存的方法上。 通过@Cacheable可以设定： 缓存使用的CacheName 缓存存放的key； 缓存的条件； 设定注解的value后，当方法被调用，Spring会把返回值存放在名为CacheName的缓存中，将参数Hash后的值作为key，返回值作为value。 当下次以相同参数调用方法时，Spring将从缓存中取出上次的结果，然后将结果返回，本次不调用该方法。 一个示例123456789@SpringBootApplication@EnableCaching //需要在启动类或@Configuration类上添加@EnableCaching注解表示启用缓存public class SpringBootGetIpStudyApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBootGetIpStudyApplication.class, args); &#125;&#125; 12345678@RestControllerpublic class SpringBootCacheStudyController &#123; @GetMapping(&quot;/get&quot;) @Cacheable(&quot;cache_study&quot;) public String get(int s)&#123; return UUID.randomUUID().toString().substring(0,10); &#125;&#125; 在一次运行过程中，多次请求https://127.0.0.1/get?s=1，获取的结果都是一致的。 缓存中的key缓存的实现本质是键值存储。 若方法没有参数，将以SimpleKey.EMPTY作为key将结果存放； 若方法有一个参数，则直接以这个参数作为key； 若方法有多个参数，则返回一个包含所有参数的SimpleKey。（hashCode()的结果） 若方法有多个参数，可以指定一个SpEL表达式作为SimpleKey进行存储。 12345@GetMapping(&quot;/get5&quot;)@Cacheable(cacheNames = &quot;cache_study&quot;,key = &quot;#a&quot;)public String get5(int a,int b,int c)&#123; return UUID.randomUUID().toString().substring(0,10);&#125; 无论b和c为多少，只有a改变时，缓存才会发生改变。 同步缓存在多线程环境中，可能会有多个线程同时调用同一个方法； 默认缓存不锁定任何东西，可能会导致多次调用，然后达到同样的缓存结果。 对于这种情况，可以使用sync属性； 添加该属性后，在多个线程调用方法时，只有一个线程用于计算，其他线程被阻塞直到缓存被更新。 12@Cacheable(cacheNames=&quot;foos&quot;, sync=true) public Foo executeExpensiveOperation(String id) &#123;...&#125; 条件缓存可以设定达到指定的条件再进行缓存，使用参数condition。使用SpEL表达式作为值。 根据参数进行条件缓存condition12345@GetMapping(&quot;/get2&quot;)@Cacheable(cacheNames = &quot;cache_study&quot;,condition = &quot;#s&gt;10&quot;)public String get2(int s)&#123; return UUID.randomUUID().toString().substring(0,10);&#125; 当s的值大于10，则进行缓存。 12345@GetMapping(&quot;/get3&quot;)@Cacheable(cacheNames = &quot;cache_study&quot;,condition = &quot;#s.length()&gt;3&quot;)public String get3(String s)&#123; return UUID.randomUUID().toString().substring(0,10);&#125; 当字符串s长度大于3时进行缓存。 unlessunless发生在方法调用结束之后，也用来判断是否需要缓存，这个属性不会控制方法是否被调用。 unless的属性值表现方式与condition相反，译为“如果不”，则进行缓存。 可以使用#result来代表返回的对象，填充属性值。 1234567891011121314@GetMapping(&quot;/get4&quot;)@Cacheable(cacheNames = &quot;cache_study&quot;,unless = &quot;#result.id&gt;10&quot;)public Water get4(int id)&#123; return new Water(id);&#125;class Water&#123; int id; String uuid; public Water(int id) &#123; this.id = id; this.uuid = UUID.randomUUID().toString().substring(0,10); &#125; //getter,setter,toStirng方法省略。&#125; 当方法调用返回的对象的id小于等于10，则返回缓存的结果，本地调用返回的结果丢弃。 反之，将本次调用的结果存到缓存中。 SpEL表达式可以用的元参数 Name Location Description Example methodName Root object 被调用的方法名 #root.methodName method Root object 被调用的方法 #root.method.name target Root object 被调用的目标对象 #root.target targetClass Root object 目标对象的class #root.targetClass args Root object 被调用的参数列表 #root.args[0] caches Root object 当前方法调用使用的缓存列表。（如@Cacheable（{“cache1”,“cache2”}）） #root.caches[0].name Argument name Evaluation context 方法参数的名字，使用#参数名，也可以使用#p0或#a0，0代表参数的索引 #apple #p0 #a1 result Evaluation context 方法执行后的返回值 #result @CachePut使用@CachePut注解的方法，方法总会被调用执行，并且会将调用结果放到缓存中。 @CacheEvict使用@CacheEvict注解可以对缓存进行清理。 可以指定一个或多个缓存清理，允许指定key或条件进行缓存，另可以带一个参数allEntries表示是否需要清理所有的缓存。 12@CacheEvict(cacheNames=&quot;books&quot;, allEntries=true) public void loadBooks(InputStream batch) 清理cacheNames为books的缓存。 @Caching@Caching注解可以让多个相同的注解进行嵌套。 12@Caching(evict = &#123; @CacheEvict(&quot;primary&quot;), @CacheEvict(cacheNames=&quot;secondary&quot;, key=&quot;#p0&quot;) &#125;)public Book importBooks(String deposit, Date date) @CacheConfig@CacheConfig注解用在类上，可以为整个类共享一个CacheName。 在方法上的@Cachable注解不需要添加CacheName属性，就可以实现缓存； 若类里面有一个方法的@Cachable注解有CacheName属性，则该方法使用自己的CacheName，不共享类的CacheName。 若方法没有被@Cachable注解，则不会进行缓存。 @EnableCaching要使以上的注解生效，需要在启动类或配置类上添加@EnableCaching注解。","categories":[],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://zswh33.github.io/tags/SpringBoot/"}]},{"title":"Java 一些杂项","slug":"Java-一些杂项","date":"2022-09-18T04:55:48.000Z","updated":"2022-09-18T07:57:17.414Z","comments":true,"path":"2022/09/18/Java-一些杂项/","link":"","permalink":"http://zswh33.github.io/2022/09/18/Java-%E4%B8%80%E4%BA%9B%E6%9D%82%E9%A1%B9/","excerpt":"","text":"获取客户端（用户）真实IPhttps://dirask.com/posts/Spring-Boot-get-client-IP-address-from-request-HttpServletRequest-pBv9Bp 两种情况： 服务器IP暴露，客户端通过IP直接访问服务器； 服务器前面有一层或多层反向代理，客户端通过代理访问服务器。 对于第一种情况，使用request.getRemoteAddr()可以直接获得客户端IP。不过不常用。 因为目前流行的架构中，基本上服务器不会直接把自己的IP暴露出去。 一些代理软件用的标头 代理软件 使用默认HeaderName Apache Proxy-Client-IP Weblogic WL-Proxy-Client-IP 有些代理服务器 HTTP_CLIENT_IP Nginx X-Real-IP 有些网络可以通过多层代理，那么获得到的IP就会有多个，一般用“,”分割开来。 测试从代理获得的标头12345678910111213141516171819@RestControllerpublic class HelloController &#123; @GetMapping(&quot;/&quot;) public String hello(HttpServletRequest request)&#123; //通过request直接获得IP System.out.println(&quot;\\n&lt;br&gt;通过request.getRemoteAddr()获得IP：&quot; + request.getRemoteAddr()); System.out.println(&quot;\\n&lt;br&gt;通过request.getRemoteHost()获得IP：&quot; + request.getRemoteHost()); //将所有标头返回到页面 Enumeration&lt;String&gt; headerNames = request.getHeaderNames(); System.out.println((&quot;\\nHeader List:&quot;)); String headerName; while (headerNames.hasMoreElements())&#123; headerName = headerNames.nextElement(); System.out.println(&quot;\\n&quot; + headerName + &quot;: &quot; + request.getHeader(headerName)); &#125; return &quot;Hello&quot;; &#125;&#125; 123456789&lt;br&gt;通过request.getRemoteAddr()获得IP：127.0.0.1&lt;br&gt;通过request.getRemoteHost()获得IP：127.0.0.1Header List:host: 192.168.227.1x-real-ip: 127.0.0.1x-forwarded-for: 192.168.227.129, 127.0.0.1, 127.0.0.1, 127.0.0.1connection: closeuser-agent: curl/7.81.0accept: */* 图中可以了解，x-forwarded-for存放了转发过程中的所有IP。 获取用户真实IP123456789101112131415161718192021222324252627@GetMapping(&quot;/ip&quot;)public String getIp(HttpServletRequest request)&#123; String[] IP_HEADERS = &#123; &quot;X-Forwarded-For&quot;, &quot;Proxy-Client-IP&quot;, &quot;WL-Proxy-Client-IP&quot;, &quot;HTTP_X_FORWARDED_FOR&quot;, &quot;HTTP_X_FORWARDED&quot;, &quot;HTTP_X_CLUSTER_CLIENT_IP&quot;, &quot;HTTP_CLIENT_IP&quot;, &quot;HTTP_FORWARDED_FOR&quot;, &quot;HTTP_FORWARDED&quot;, &quot;HTTP_VIA&quot;, &quot;REMOTE_ADDR&quot; // you can add more matching headers here ... //你可以在这里添加更多的标头 &#125;; for (String header : IP_HEADERS)&#123; String value = request.getHeader(header); if (value == null || StringUtils.isEmpty(value))&#123; continue; &#125; String part = value.split(&quot;,&quot;)[0]; return part; &#125; return request.getRemoteAddr();&#125; equalsIgnoreCase()将字符串与指定的对象比较，忽略大小写。阿萨德","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://zswh33.github.io/tags/Java/"}]},{"title":"Java 多线程 Note","slug":"Java-多线程-Note","date":"2022-09-17T09:38:53.000Z","updated":"2022-09-18T03:30:04.817Z","comments":true,"path":"2022/09/17/Java-多线程-Note/","link":"","permalink":"http://zswh33.github.io/2022/09/17/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B-Note/","excerpt":"","text":"ThreadLocal本地线程变量，为当前线程填充的变量； 变量对其他线程而言是封闭且隔离的，ThreadLocal为变量在每个线程中创建了一个副本，这样每个线程都可以访问自己内容的副本变量； 方法**T get()**：返回当前线程本地变量的当前线程的副本中的值； **void remove()**：移除此线程的本地变量； **void set()**：设置此线程本地变量的值； &lt;S&gt; ThreadLocal&lt;S&gt;：创建一个线程局部变量。 使用123456789101112131415161718public class ThreadLocalStudy &#123; public static ThreadLocal&lt;Apple&gt; threadLocal = new ThreadLocal&lt;&gt;(); public static void main(String[] args) throws InterruptedException &#123; //创建5个线程 输出threadLocal.get() for (int i = 0; i &lt; 5; i++) &#123; new Thread(()-&gt;&#123; threadLocal.set(new Apple()); System.out.println(Thread.currentThread().getName()+&quot;:&quot;+threadLocal.get()); &#125;,String.valueOf(i)).start(); &#125; TimeUnit.SECONDS.sleep(3); &#125;&#125;class Apple&#123;&#125; 12345670:com.yn.Apple@4f0c47072:com.yn.Apple@7e1296041:com.yn.Apple@192815614:com.yn.Apple@4388eabf3:com.yn.Apple@90472a2Process finished with exit code 0 对于不同的线程，theradLocal中值不同。 原理文字介绍 描述：在Thread内部有个threadLocals引用，在使用ThreadLocal时， ThreadLocal会为threadLocals创建ThreadLocalMap的对象， 然后将自己的hash作为Map的key，将要存放的值作为value，存放在threadLocals里的table表里。 当要取用时，从Thread的threadLocals中，将自己的hash作为key，取出Entry对象，然后取出My Object。 内存泄露问题在线程中，当一个ThreadLocal引用指向变成null，意味着这个ThreadLocal对象不再需要； 在threadLocals的table中，若key为null，value仍在堆中，在下次的ThreadLocalMap.set\\get()方法执行都会清理漏掉的value； 但如果ThreadLocalMap.set\\get()方法没有被执行，value一直未被清理，就有可能发生内存泄露问题。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public class ThreadLocal&lt;T&gt; &#123; public ThreadLocal() &#123; &#125; //get方法 public T get() &#123; //从当前线程获得ThreadLocalMap Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); //如果map为空则返回null if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings(&quot;unchecked&quot;) T result = (T)e.value; return result; &#125; &#125; return setInitialValue(); &#125; //set方法 public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);//如果没有map则创建map &#125; public void remove() &#123; ThreadLocalMap m = getMap(Thread.currentThread()); if (m != null) m.remove(this);//删除value &#125; ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals; &#125; void createMap(Thread t, T firstValue) &#123; t.threadLocals = new ThreadLocalMap(this, firstValue); &#125; /* ThreadLocalMap的实现类似于HashMap，都有自动扩容和初始容量的概念； 不同的是，ThreadLocalMap的map实现采用Entry数组实现，Entry是一个弱引用；ThreadLocal采用开放地址法，可以减少地址碰撞。 */ static class ThreadLocalMap &#123; private Entry[] table;//map ... static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123; /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal&lt;?&gt; k, Object v) &#123; super(k); value = v; &#125; &#125; ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123; table = new Entry[INITIAL_CAPACITY]; int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1); table[i] = new Entry(firstKey, firstValue); size = 1; setThreshold(INITIAL_CAPACITY); &#125; private Entry getEntry(ThreadLocal&lt;?&gt; key) &#123;...&#125; private void set(ThreadLocal&lt;?&gt; key, Object value) &#123;...&#125; private void remove(ThreadLocal&lt;?&gt; key) &#123;...&#125; ... &#125;&#125; WeakReference 弱引用https://brightloong.github.io/2018/05/27/%E5%85%B3%E4%BA%8EJava%E4%B8%AD%E7%9A%84WeakReference/#more 当一个对象仅仅被weak reference，而没有任何其他strong reference指向的时候； 如果gc运行，不论内存空间是否足够，这个对象都会被回收； 认识弱引用WeakReference类继承Reference，有两个构造函数。 123456789101112public class WeakReference&lt;T&gt; extends Reference&lt;T&gt; &#123; //创建一个弱引用对象，指向给定的对象。 public WeakReference(T referent) &#123; super(referent); &#125; //创建一个弱引用指向给定的对象，注册到给定的队列； //当引用被回收，指向给定对象的WeakReference将会被放到队列里。 public WeakReference(T referent, ReferenceQueue&lt;? super T&gt; q) &#123; super(referent, q); &#125;&#125; 创建一个弱引用WeakReference对象，指向给定的对象T； 当给定的对象T被回收，WeakReference对象会被放到ReferenceQueue队列里面，若没有给定ReferenceQueue，则不会发生。 代码示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class WeakReferenceStudy &#123; public static void main(String[] args) throws InterruptedException &#123; //创建一个弱引用对象 //创建一个瓶子把水装进去 Bottle bottle = new Bottle(new Water(&quot;Pure Water&quot;)); System.out.println(bottle);//输出瓶子 System.out.println(bottle.get());//输出水 System.gc();//进行一次gc TimeUnit.SECONDS.sleep(5);//休息5秒，确保gc进行结束 System.out.println(bottle);//输出瓶子 System.out.println(bottle.get());//输出水 &#125;&#125;//带有名字的水class Water&#123; String name; public Water(String name)&#123; this.name = name; &#125; public String getName()&#123; return name; &#125; @Override protected void finalize() throws Throwable &#123; System.out.println(getName()+&quot;：我被回收了。&quot;); super.finalize(); &#125; @Override public String toString() &#123; return &quot;Water&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125;//可以装水的瓶子//extends WeakReference&lt;water&gt; 可能会漏水class Bottle extends WeakReference&lt;Water&gt;&#123; public Bottle(Water referent) &#123; super(referent); &#125;&#125; 12345678com.yn.Bottle@1b6d3586Water&#123;name=&#x27;Pure Water&#x27;&#125;Pure Water：我被回收了。com.yn.Bottle@1b6d3586nullProcess finished with exit code 0 首先Bottle对象和Water对象正常输出； 然后进行一次gc，Water被回收了； 再次输出的时候，Bottle正常输出，Water变成null。 ReferenceQueue123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class WeakReferenceStudy2 &#123; public static void main(String[] args) throws InterruptedException &#123; //一个引用队列 ReferenceQueue&lt;Water2&gt; referenceQueue = new ReferenceQueue&lt;&gt;(); //创建两个弱引用对象，分别指向一个Water2对象 WeakReference&lt;Water2&gt; reference1 = new WeakReference&lt;Water2&gt;(new Water2(&quot;pure water&quot;),referenceQueue); WeakReference&lt;Water2&gt; reference2 = new WeakReference&lt;Water2&gt;(new Water2(&quot;dirty water&quot;),referenceQueue); //输出 System.out.println(reference1); System.out.println(reference2); System.out.println(reference1.get()); System.out.println(reference2.get()); //进行一次gc System.gc(); TimeUnit.SECONDS.sleep(4);//休息4秒 //输出两个Water2对象 System.out.println(reference1.get()); System.out.println(reference2.get()); //输出队列里的内容 Reference&lt;? extends Water2&gt; reference; while ((reference = referenceQueue.poll()) != null)&#123; System.out.println(reference); &#125; &#125;&#125;//一个对象//一个水class Water2&#123; String name; public String getName() &#123; return name; &#125; public Water2(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return &quot;Water2&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125; @Override protected void finalize() throws Throwable &#123; System.out.println(name+&quot;被回收了&quot;); &#125;&#125; 12345678910111213java.lang.ref.WeakReference@1b6d3586java.lang.ref.WeakReference@4554617cWater2&#123;name=&#x27;pure water&#x27;&#125;Water2&#123;name=&#x27;dirty water&#x27;&#125;dirty water被回收了pure water被回收了nullnulljava.lang.ref.WeakReference@1b6d3586java.lang.ref.WeakReference@4554617cProcess finished with exit code 0 首先创建一个引用队列；然后创建两个弱引用对象，创建Water2对象，将Water2对象和referenceQueue一起传入构造方法； 在输出中，两个引用对象和Water2对象正常输出； 两个Water2被回收，输出中为null； 输出referenceQueue发现两个弱引用对象，与之前的一致。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://zswh33.github.io/tags/Java/"}]},{"title":"Mysql Note","slug":"Mysql-Note","date":"2022-09-17T03:48:17.000Z","updated":"2022-09-17T09:21:47.814Z","comments":true,"path":"2022/09/17/Mysql-Note/","link":"","permalink":"http://zswh33.github.io/2022/09/17/Mysql-Note/","excerpt":"","text":"InnoDB 行格式https://dev.mysql.com/doc/refman/8.0/en/innodb-row-format.html#innodb-row-format-redundant 行格式ROW_FORMATROW_FORMAT决定一行数据在磁盘中的存储方式，因而影响查询和DML操作的性能。 当一行数据放在同一张盘页，请求和索引查询会更快。 InnoDB存储引擎支持四种行格式：REDUNDANT、COMPACT、DYNAMIC和COMPRESSED。 （冗余、紧凑、动态、压缩） REDUNDANT 冗余REDUNDANT 冗余n. 存储可变长读列时（varchar、varbinary、blob、text），在B树节点中存储前768个字节，剩余部分存放在溢出页； 大于768字节的定长列值会被编码为可变长度列，放在页外存储； 若列值小于768字节，则不使用溢出页，列的值全部存储在B树节点中，这样可以节省IO（去溢出页取数据）； Blob短值友好，但只存储数据，不存储键值，效率会变低。 特点 每个索引记录包含一个6字节的标头，使用标头将连续的记录链接在一起，用于行级锁定； 聚集索引的记录会包含用户定义列的所有字段。除此之外，还有一个6字节的transaction ID字段和7字节的roll pointer字段； 如果表没有定义主键，每个聚集索引记录还会包含6字节的行id字段； 每个二级索引中包含的是聚集索引定义的主键值，而非每一行的数据； 记录包含指向每个字段的指针。 如果字段的长度小于128字节，指针为1字节，否则两个字节。 这样的指针数组称为记录目录，指针指向的是记录的数据部分。 大于或等于768字节的固定长度列编码为可变长度列，存储在页外； null值使用记录目录的一个或两个字节。 如果是可变长列，在记录的数据区null值占用0字节； 如果是定长列，会在数据区保留定长字段需要的长度。当数据从null变成非null值，保留空间被新的数据替代，这样就可以避免造成索引页碎片产生。 COMPACT 紧凑相对REDUNDANT方式，COMPACT方式节约了约20%的存储空间，但是增加了CPU的使用。 如果工作量被击中缓存和磁盘速度限制，COMPACT格式相对更快； 如果工作量被CPU速度限制，COMPACT相对会更慢； 特点 每个索引包含5字节的头 hole…. Mysql BLOB在MySQL中Blob是一个二进制对象，可以存储大量数据的容器（图片、音乐等）。 Blob对象分为四种 TinyBlob，最大可以存储255B的数据； Blob，最大存储65KB的数据； MediumBlob，最大存储16MB的数据； LongBlob，最大容纳4GB的数据。 应用场景 存储图片或文件与数据表中数据有高度相关性，存在一起方便后续维护； 如：学校学生花名册的图片，产品手册中产品的照片以及PDF说明书等； 这种存储方式，对于数据的导入导出，数据迁移等操作来说非常便捷、安全、完整； mysql在索引比较大的Blob和Text时，对MySQL性能影响较大； 原因 Blob数据量较大，影响MySQL的查询效率； 如何解决 优先考虑压缩； 将Blob列单独做一张表，当需要查询时再引用； 可以将有Blob列的表存储到不同的存储设备甚至单独的数据库示例； 一些情况下，使用varchar代替blob； 为了避免blob列长文本内容进行比较，使用md5或crc32将hash存入另一列；查询时，查询比较其hash值，在比较blob列内容是否正确。 KEYkey是数据库的物理结构，作用： 约束作用，约束数据的唯一性、完整性； 索引作用，用于建立索引，优化查询速度。 有四种：普通key，primary key，unique key，foreign key，index； 普通key没有约束作用，但会在此key上建立索引； unique key唯一约束，是指所有记录中字段的值不能重复出现，比如id； 会建立索引。 primary key主键，一个表可以有一个主键，主键可以为单一主键和复合主键； 可以规定一个存储主键，规范数据的唯一性。 会在此key上建立一个索引。 foreign key外键，规范数据的引用完整性； 会建立索引。 indexkey作用的一个维度，可以替代关键字key。","categories":[],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://zswh33.github.io/tags/Mysql/"}]},{"title":"行业的现状以及未来 2019-11","slug":"Day24-复习","date":"2022-09-16T07:46:07.000Z","updated":"2022-09-16T08:34:53.127Z","comments":true,"path":"2022/09/16/Day24-复习/","link":"","permalink":"http://zswh33.github.io/2022/09/16/Day24-%E5%A4%8D%E4%B9%A0/","excerpt":"","text":"https://www.bilibili.com/video/BV1PE411i7CV 三层架构 ： MVC架构的目的：解耦 开发框架： Spring IOC AOP IOC：控制反转 AOP：切面（本质：动态代理） 为了不影响业务本来的情况下，实现动态增加功能，大量应用在日志，事务、、等等方面。 Spring 是一个轻量级的Java开源框架，容器； 目的：解决企业开发的复杂性问题 缺点：复杂的配置文件 Spring Boot 简化Spring的操作 自动配置Spring的许多东西，拿来即用； 新一代JavaEE的开发标准，开箱即用； 特性：约定大于配置 随着公司体系越来越大，用户越来越多！ 微服务架构 全新的架构：模块化、功能化！ 用户、支付、签到、娱乐； 负载均衡 一些问题 这么多服务，客户端如何去访问？ 这么多服务，服务之间如何通信？ 如何治理？如何统一管理？ 服务宕机，如何处理？ 解决方案： Spring SpringCloud Netflix：是一套生态，解决以上分布式架构的四个问题。 API网关，zuul组件 Feign —&gt; HttpClient —&gt; HTTP的通信方式 服务注册与发现，Eureka。 熔断机制 2018年年底，Netflix宣布无限期停止维护，生态不再维护。 Apache Dubbo zookeeper 新的解决方案 API：没有！借助第三方组件&#x2F;自己实现 Dubbo：高性能的基于Java实现的RPC通信框架； 服务注册与发现，zookeeper 没有熔断机制，借助Hystrix SpringCloud Alibaba 新的一站式解决方案 （展望未来）下一代微服务标准：服务网格，Server Mesh 代表解决方案：istio（未来可能需要掌握！） 这些东西，出现的目标&#x2F;要解决的问题 API网关，服务路由； HTTP，RPC框架，异步调用； 服务注册与发现，高可用； 熔断机制，服务降级。","categories":[],"tags":[{"name":"SpringBoot Java","slug":"SpringBoot-Java","permalink":"http://zswh33.github.io/tags/SpringBoot-Java/"}]},{"title":"Day23 分布式 Dubbo Zookeeper","slug":"Day23-分布式-Dubbo-Zookeeper","date":"2022-09-15T08:27:39.000Z","updated":"2022-09-16T02:41:05.430Z","comments":true,"path":"2022/09/15/Day23-分布式-Dubbo-Zookeeper/","link":"","permalink":"http://zswh33.github.io/2022/09/15/Day23-%E5%88%86%E5%B8%83%E5%BC%8F-Dubbo-Zookeeper/","excerpt":"","text":"分布式分布式系统是若干独立计算机的集合，这些计算机对于用户来说就像单个相关系统 分布式系统是由一组通过网络进行通信，为了完成共同的任务而协调工作的计算机节点组成的系统。分布式系统的出现是为了用廉价的、普通的机器完成单个计算机无法完成的计算、存储任务。其目的是利用 更多的机器，处理更多的数据。 场景 只有当单个节点的处理能力无法满足日益增长的计算、存储任务的时候， 且硬件的提升高昂到得不偿失的时候、 应用程序也不能进一步优化的时候，需要考虑分布式系统。 架构的发展单一应用框架 当网站流量很小时，只需要一个应用，将所有功能部署在一起，以减少部署节点和成本； 此时，用于简化增删改查工作量的数据访问框架（ORM）是关键。 适用于小型网站，小型管理系统； 缺点： 性能扩展难； 协同开发问题 不利于升级维护 垂直应用架构 将应用拆成互不相干的几个应用，以提升效率； 此时，用于加速前端页面开发的Web框架（MVC）是关键。 优点：通过切分业务来实现各个模块的独立部署，降低了维护和部署的难度，团队各司其职容易管理，性能扩展更加方便； 缺点：公用模块无法重复利用，开发性的浪费。 分布式服务架构 当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快的响应多变的市场需求。 此时，提升分布式服务框架（RPC）是关键。 流动计算架构 增加一个调度中心基于访问压力实时管理集群容量，提高集群的利用率。 此时，用于提高机器利用率的资源调度和治理中心（SOA）是关键。 RPCRemote Procedure Call RPC，远程过程调用，是进程间的通信方式。 是一种思想，而不是规范。 允许程序调用另一个地址空间（通常是共享网络的另一个机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。RPC允许像调用本地方法一样调用远程方法； RPC两个核心模块：通信、序列化。 序列化：数据传输需要转换； DubboApache Dubbo 是一个高性能的基于Java的开源RPC框架 https://dubbo.apache.org/ 三大核心能力 面向接口的远程方法调用； 智能容错和负载均衡； 服务自动注册和发现。 Dubbo结构图 服务提供者（Provider）：暴露服务的提供方，服务提供者在启动时，向注册中心注册自己提供的服务； 服务消费者（Consumer）：调用远程服务的服务消费方，服务消费者在启动时，向注册中心订阅自己所需的服务，服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，若调用失败，再选另一台调用； 注册中心（Registry）：注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者； 监控中心（Monitor）：服务消费者和提供者，在内存中累计调用次数和调用时间，定期每分钟发送一次统计数据到监控中心。 ZooKeeper ZooKeeper是一个分布式的，开放源代码的分布式应用程序协调服务。 是一个为分布式应用提供一致性服务的软件，功能包括：配置维护、域名服务、分布式同步、组服务等。 是Hadoop和Hbase的重要组件。 第一次运行Zookeeper到北京理工大学镜像站下载Zookeeper软件：https://mirror.bit.edu.cn/apache/zookeeper/zookeeper-3.8.0/ （带bin为可执行程序，不带bin为源代码+可执行程序） 到conf目录下，将zoo_sample.cfg复制一份，名为zoo.cfg； 到bin目录下： zkServer：Zookeeper的服务端程序，（Windows以管理员身份）打开即可开启服务； zkCli：Zookeeper的测试用的客户端程序。 Dubbo-admin是Dubbo的一个监控管理后台。 可以查看注册了哪些服务，哪些服务被消费了。 一个Maven项目。 下载使用https://mirror.bit.edu.cn/apache/dubbo/dubbo-admin/0.4.0/ https://github.com/apache/dubbo-admin 解压； mvn clean package -Dmaven.test.skip=true 将项目打包。也可直接下载打包好的直接运行； 使用java -jar 文件名 运行。 一些要注意的地方Dubbo服务默认启用一个AdminServer端口为8080； Dubbo-admin的默认端口也是8080。 若在同一台主机上使用，可能会出现端口占用。需要修改其中一个端口解决问题。 Dubbo的AdminServer服务端口修改: zoo.cfg 1admin.serverPort=8888 Dubbo-admin端口修改： application.properties 1server.port=8081","categories":[],"tags":[{"name":"SpringBoot Dubbo Zookeeper","slug":"SpringBoot-Dubbo-Zookeeper","permalink":"http://zswh33.github.io/tags/SpringBoot-Dubbo-Zookeeper/"}]},{"title":"Day23 Task SpringBoot异步任务 发送邮件 定时执行任务 Cron表达式","slug":"Day23-Task","date":"2022-09-15T06:12:34.000Z","updated":"2022-09-15T08:26:05.909Z","comments":true,"path":"2022/09/15/Day23-Task/","link":"","permalink":"http://zswh33.github.io/2022/09/15/Day23-Task/","excerpt":"","text":"SpringBoot的异步任务使用 在需要异步执行的方法上面添加注解@Async 123456//告诉Sping这是一个异步的方法@Asyncpublic void hello() throws InterruptedException &#123; Thread.sleep(3000); System.out.println(&quot;数据正在处理...&quot;);&#125; 在主方法的类上面添加注解@EnableAsync 1234567@EnableAsync //开启异步任务功能@SpringBootApplicationpublic class SpringBootStudy4TaskApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBootStudy4TaskApplication.class, args); &#125;&#125; 表现： 创建一个Controller调用Service的hello()方法； 1234567891011@Controllerpublic class AsyncController &#123; @Autowired AsyncService service; @ResponseBody @RequestMapping(&quot;/async&quot;) public String hello() throws InterruptedException &#123; service.hello(); return &quot;OK&quot;; &#125;&#125; 在网页加载过程中，没有等待3000毫秒，直接加载出OK； 3000毫秒后，日志输出“数据正在处理…”。 service.hello()执行过程没有阻塞线程，而是在新线程中运行。 SpringBoot发送邮件步骤 在application.properties下配置相关配置 123spring.mail.username=xxxx@qq.comspring.mail.password=xxxxxxxxxxxxxxxspring.mail.host=smtp.qq.com username为邮箱名，password为邮件服务器给的密钥，host为邮件服务器的smtp域名。 发送邮件 1234567891011@AutowiredJavaMailSenderImpl mailSender;//创建一个JavaMailSenderImpl引用并使用@Autowired注解@Testvoid contextLoads() &#123; SimpleMailMessage mailMessage = new SimpleMailMessage(); mailMessage.setSubject(&quot;这也是一个标题&quot;); mailMessage.setText(&quot;这个是一个文本这个是一个文本这个是一个文本这个是一个文本这个是一个文本&quot;); mailMessage.setTo(&quot;uwupu@qwe.asd&quot;); mailMessage.setFrom(&quot;uwupu@asd.qwe&quot;); mailSender.send(mailMessage);&#125; 创建一个JavaMailSenderImpl引用并使用@Autowired注解； 使用SimpleMailMessage新建一个邮件对象，设定邮件的Subject、Text、来源和去向，然后使用send方法将邮件发出； 发送邮件2 1234567891011121314151617@Testvoid contextLoads2() throws MessagingException &#123; //一个复杂的邮件 MimeMessage mimeMessage = mailSender.createMimeMessage(); //组装 MimeMessageHelper helper = new MimeMessageHelper(mimeMessage,true,&quot;utf-8&quot;); helper.setSubject(&quot;这个又又是一个标题&quot;); helper.setText(&quot;&lt;p style=&#x27;color:red&#x27;&gt;这是一个测试学习用的邮件&lt;/p&gt;&quot;,true); //附件 helper.addAttachment(&quot;1.jpg&quot;,new File(&quot;D:/Document/pictures/youji.jpg&quot;)); helper.addAttachment(&quot;2.gif&quot;,new File(&quot;D:/Document/pictures/t.gif&quot;)); //来源 目的邮箱 helper.setTo(&quot;目的邮箱&quot;); helper.setFrom(&quot;来源邮箱&quot;); //发送 mailSender.send(mimeMessage);&#125; 这是一个创建复杂邮件的过程，相对简单邮件，这里可以添加内容为html内容、添加附件等； 创建一个MimeMessage对象，然后使用MimeMessageHelper包装MimeMessage对象，使用MimeMessageHelper对象对邮件进行一些配置，最后将邮件发出。 定时执行任务步骤 在主程序添加@EnableScheduling定时任务功能注解； 1234567@EnableScheduling //开启定时任务功能的注解@SpringBootApplicationpublic class SpringBootStudy4TaskApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBootStudy4TaskApplication.class, args); &#125;&#125; 在需要定时执行的任务上方添加@Scheduled注解； 12345//在一个特定的时间执行这个方法@Scheduled(cron = &quot;cron表达式&quot;)public void hello()&#123; System.out.println(&quot;hello，执行一个定时任务..中！&quot;);&#125; 在时间到达cron表达式指向的时间时，就会触发执行这个方法。 Cron表达式简单示例12 0 * * * * 0-7# 秒分 时日月 星期 表示在 星期1-7 每月 每日 每时 每分 0秒 这个时间触发一次。 （也就是 每到一个秒数为0的时间，触发一次） 基本格式通过Cron表达式可以实现指定一个、一段、一些时间去触发某些任务； 1秒 分 时 日 月 周 通过一个空格隔开，分别表示一个单位，每个单位通过一个简易的表达式表现在哪些时间执行任务。 单个格式 10/5，从10开始，每过5个单位触发一次； 30/5 0 0 * * ? 每天的0时0分，从30秒开始，每过5秒执行一次； 0 0/5 * * * ? 每过5分钟执行一次； 10-30，表示在10-30区间； 10,20，表示10和20两个值； *，表示任意值； ?，只能用在日和周上，因为日和周会互相影响，若要取消影响，只需在不需要的属性上添加“？”。如： 0 0 0 1 * ? 表示每月的1日0点触发； 0 0 0 ? * 3 表示每周三的0点触发； 0 0 0 * * ? 每天的0点触发。 6#3，只能用在周上，表示第三个星期五。 0 0 0 ? * 6#3，每月的第三个星期五的0点触发。 L，可以放在日和周上， 日上表示最后一天； 0 0 0 L * ? 表示每月的最后一天的0点； 周上表示最后周几，使用”数字L”表达； 0 0 0 ? * 5L 表示每月的最后一个星期四的0点； L不要和 - 或 ,一起使用，否则会出现意想不到的结果。 3W，放在日上，表示距离3号最近的工作日； LW，放在日上，表示最后一个工作日。 范围 域 字段 取值 特殊字符 是否必须 备注 秒 Seconds 0-59 , - * &#x2F; 是 分 Minutes 0-59 , - * &#x2F; 是 时 Hours 0-23 , - * &#x2F; 是 日 DayofMonth 1-31 , - * &#x2F; ? L W 是 月 Month 1-12 或 JAN-DEC , - * &#x2F; 是 星期 DayofWeek 1-7 或 SUN-SAT , - * &#x2F; ? L # 是 日 1 2 3 4 5 6 年 Year 1980-2099 , - * &#x2F; 否","categories":[],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://zswh33.github.io/tags/SpringBoot/"}]},{"title":"Day22 Swagger 1","slug":"Day22-Swagger-1","date":"2022-09-14T09:54:10.000Z","updated":"2022-09-15T06:10:36.153Z","comments":true,"path":"2022/09/14/Day22-Swagger-1/","link":"","permalink":"http://zswh33.github.io/2022/09/14/Day22-Swagger-1/","excerpt":"","text":"Swaggerhttps://swagger.io/ 简介 号称世界上最流行的Api框架。 Restful Api 文档在线自动生成工具 -&gt; Api文档与Api定义同步更新 直接运行，可以在线测试API接口； 支持多种语言：Java，PHP… 依赖12345678910&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt;&lt;/dependency&gt; 集成 创建SpringBoot项目 添加依赖 编写HelloController 配置SwaggerConfig 1234@Configuration@EnableSwagger2 //开启Swagger2public class SwaggerConfig &#123;&#125; 测试运行。默认URL：http://localhost:8080/swagger-ui.html 配置配置Swagger依据Swagger的bean实例Docket； 配置Docket Bean先配置一个默认的配置12345678910@Configuration@EnableSwagger2 //开启Swagger2public class SwaggerConfig &#123; //配置了Swagger Docket的Bean实例 @Bean public Docket docket()&#123; return new Docket(DocumentationType.SWAGGER_2); &#125;&#125; 创建一个SwaggerConfig，使用**@Configuration注解和@EnableSwagger2注解** 配置Bean Docket。返回值为**new Docket(DocumentationType.SWAGGER_2)**。 这样就完成了默认的配置。 apiInfo() 自定义Swagger页面介绍部分内容123456789101112131415161718192021222324@Configuration@EnableSwagger2 //开启Swagger2public class SwaggerConfig &#123; //配置了Swagger Docket的Bean实例 @Bean public Docket docket()&#123; return new Docket(DocumentationType.SWAGGER_2).apiInfo(uwupu_apiInfo()); &#125; //配置Swagger信息 apiInfo private ApiInfo uwupu_apiInfo()&#123; return new ApiInfo( &quot;uwupu的Swagger API 文档&quot;, &quot;这个作者有点...懒，什么也没有留下。&quot;, &quot;1.0&quot;, &quot;https://uwupu.tk/&quot;, new Contact(&quot;uwupu&quot;, &quot;https://uwupu.tk&quot;, &quot;yyn33@qq.com&quot;), //作者信息 &quot;Apache 2.0&quot;, &quot;http://www.apache.org/licenses/LICENSE-2.0&quot;, new ArrayList&lt;VendorExtension&gt;() ); &#125;&#125; 使用Docket的方法apiInfo传入一个自定义的ApiInfo对象，即可实现自定义； 自定义的ApiInfo对象可以调整的内容： 标题 描述 版本 team链接 联系方式 new Contact(名字，连接，Email) 许可 许可Url … select() 配置扫描接口的方式使用方式： 1234567891011121314@Beanpublic Docket docket()&#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(uwupu_apiInfo()) //配置扫描接口的方式 .select() //RequestHandlerSelectors配置扫描接口的方式 //basePackage配置通过包扫描接口 一般用这个 .apis(RequestHandlerSelectors.basePackage(&quot;com.yn.controller&quot;)) //过滤指定路径 //通过路径指定过滤路径 .paths(PathSelectors.ant(&quot;/hello/**&quot;)) .build();&#125; apis() 通过类与方法的包或注解选择扫描的方式 **RequestHandlerSelectors.basePackage(“com.yn.controller”)**：通过包方式扫描接口； **RequestHandlerSelectors.withClassAnnotation(Controller.class)**：通过类上的注解配置要扫描的类； **RequestHandlerSelectors.withMethodAnnotation(GetMapping.class)**：通过方法上的注解配置要扫描的方法； **RequestHandlerSelectors.any()**：所有； **RequestHandlerSelectors.none()**：都不扫描。 paths() 通过url配置扫描的方式 **PathSelectors.ant(“&#x2F;hello&#x2F;**“)**：配置扫描的指定路径； *PathSelectors.regex(“.“)**：通过正则配置扫描的路径； PathSelectors.any() 所有 PathSelectors.none() 没有 enable(false); 默认关闭Swagger页面可以配置是否启用Swagger， true，Swagger不能在浏览器访问； false，Swagger可以在浏览器访问。 123456@Beanpublic Docket docket()&#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(uwupu_apiInfo()) .enable(false);&#125; groupName(“第一个组”)分组命名1234@Beanpublic Docket docket3()&#123; return new Docket(DocumentationType.SWAGGER_2).groupName(&quot;第三个组&quot;);&#125; 为当前组命名，影响页面右上角切换组的时候显示的名字。 配置API文档分组 一个Docket就表示一个分组，只需要配置多个Docket，并且都放进Bean，就可实现多个分组。 一个Docket可以配置多个内容，包括页面显示内容、扫描的类或方法、是否开启等，各个Docket之间互不影响。 （在实际情况下，每个部分都配置一个Docket，都可以配置不同的页面显示内容。） 当一个Docket的enable处于false，其他的处于true，则页面不显示处于false的Docket。 代码123456789101112131415161718@Beanpublic Docket docket3()&#123; return new Docket(DocumentationType.SWAGGER_2).groupName(&quot;第三个组&quot;);&#125;@Beanpublic Docket docket2()&#123; return new Docket(DocumentationType.SWAGGER_2).groupName(&quot;第二个组&quot;);&#125;//配置了Swagger Docket的Bean实例@Beanpublic Docket docket(Environment environment)&#123; return new Docket(DocumentationType.SWAGGER_2) .groupName(&quot;uwupu&quot;); .apiInfo(uwupu_apiInfo()));&#125; 效果 通过注解添加注释@ApiModel、@ApiModelProperty为实体类添加注释1234567@ApiModel(&quot;用户实体类&quot;)public class User &#123; @ApiModelProperty(&quot;用户名&quot;) private String username; @ApiModelProperty(&quot;密码&quot;) private String password;&#125; 其他注解 @Api：将一个类标记为Swagger资源（Swagger不会因为这个扫描这个类）。可以指定在文档中类所在的路径。待完善.. @ApiImplicitParam： @ApiImplicitParams： @ApiOperation：声明API资源中的单个操作。 12345678910@RequestMapping(value = &quot;/hello&quot;)@ApiOperation( value = &quot;Hello方法&quot;, notes = &quot;用于测试项目正常运行的第一个方法&quot;, response = String.class, responseContainer = &quot;none&quot;)public String hello()&#123; return &quot;hello&quot;;&#125; @ApiParam：为操作参数添加注释 123456789@RequestMapping(value = &quot;/hello&quot;)public String hello( @ApiParam( value = &quot;用户名&quot;,//参数备注 required=true//是否必要 ) String username)&#123; return &quot;hello&quot;;&#125; @ApiResponses、@ApiResponse：描述操作可能的响应。 12345678910@RequestMapping(value = &quot;/hello&quot;)@ApiResponses( &#123; @ApiResponse(code=400,message = &quot;错误的输入&quot;), @ApiResponse(code=404,message = &quot;未找到用户&quot;) &#125;)public String hello(String username)&#123; return &quot;hello&quot;;&#125; @Authorization、@AuthorizationScope：这些仅用于@Api和@ApiOperation的输入，而不是直接的资源操作。用来指定需要哪种授权方案。 对于一个API的近似完整的注释123456789101112131415@RequestMapping(value = &quot;/hello&quot;)@ApiOperation( value = &quot;Hello方法&quot;, notes = &quot;用于测试项目正常运行的第一个方法&quot;, response = String.class, responseContainer = &quot;none&quot;)@ApiResponses( &#123;@ApiResponse(code=400,message = &quot;错误的输入&quot;), @ApiResponse(code=404,message = &quot;未找到用户&quot;)&#125;)public String hello( @ApiParam(value = &quot;用户名&quot;,required=true)String username)&#123; return &quot;hello&quot;;&#125; 注意如何让Swagger扫描到pojo类只要在Controller中有返回值为pojo类的Mapping就可 1234@RequestMapping(&quot;/user&quot;)public User user()&#123; return new User();&#125; 从源码介绍ApiInfo配置页面的显示内容1234567891011121314151617181920212223242526272829303132333435363738394041public class ApiInfo &#123; public static final Contact DEFAULT_CONTACT = new Contact(&quot;&quot;, &quot;&quot;, &quot;&quot;); public static final ApiInfo DEFAULT = new ApiInfo(&quot;Api Documentation&quot;, &quot;Api Documentation&quot;, &quot;1.0&quot;, &quot;urn:tos&quot;, DEFAULT_CONTACT, &quot;Apache 2.0&quot;, &quot;http://www.apache.org/licenses/LICENSE-2.0&quot;, new ArrayList&lt;VendorExtension&gt;()); private final String version;//版本 private final String title;//标题 private final String description;//描述 private final String termsOfServiceUrl; private final String license;// private final String licenseUrl; private final Contact contact; private final List&lt;VendorExtension&gt; vendorExtensions; /** * Deprecated in favor of richer contact object * @deprecated @since 2.4.0 * * @param title title * @param description description * @param version version * @param termsOfServiceUrl terms of service * @param contactName contact name * @param license licence text * @param licenseUrl license url */ @Deprecated public ApiInfo( String title, String description, String version, String termsOfServiceUrl, String contactName, String license, String licenseUrl) &#123; this(title, description, version, termsOfServiceUrl, new Contact(contactName, &quot;&quot;, &quot;&quot;), license, licenseUrl, new ArrayList&lt;VendorExtension&gt;()); &#125;//getter，setter，...&#125; 总结 通过Swagger可以实时创建一个接口文档， 可以给接口进行注释， 可以在线测试 注意：在生产环境下，关闭Swagger。 题 我只希望我的Swagger在生产环境中使用，发布时不使用？ 方法1： 为生产环境和开发环境配置不同的配置； 通过下面的方式可以获得当前是否为指定环境，传值到enable方法里，就可以在开发环境下开启Swagger，其他环境下关闭Swagger。 1234567891011121314//配置了Swagger Docket的Bean实例@Beanpublic Docket docket(Environment environment)&#123; //依据环境切换Swagger的状态：dev：开启 pro：关闭 //获取配置 Profiles profiles = Profiles.of(&quot;dev&quot;,&quot;test&quot;); //判断是否处于指定的运行环境 final boolean flag = environment.acceptsProfiles(profiles); return new Docket(DocumentationType.SWAGGER_2) .enable(flag);&#125; Profiles.of(&quot;dev&quot;,&quot;test&quot;)可以获得指定环境的配置对象Profiles，然后使用environment.acceptsProfiles(profiles)判断是否为指定环境运行，返回值为布尔值。 123Profiles profiles = Profiles.of(&quot;dev&quot;,&quot;test&quot;);//判断是否处于指定的运行环境final boolean flag = environment.acceptsProfiles(profiles); Docket.enable方法可以设定开启或关闭Swagger。 方法2： Hole…. 其他前后端分离 后端：控制层、服务层、数据访问层 【后端团队】 前端：前端控制层、视图层 【前端团队】 伪造后端数据，json。已经存在，不需要后端，前端工程能够跑起来。 前后端交互：API 前后端相对独立，松耦合； 前后端可以部署在不同的服务器上； 缺点： 前后端集成联调，前端人员和后端人员无法做到及时协调，尽早解决，最后导致问题集中爆发。 解决方案：制定一个schema（计划的提纲），实时更新最新的API，降低集成的风险。","categories":[],"tags":[{"name":"Swagger","slug":"Swagger","permalink":"http://zswh33.github.io/tags/Swagger/"}]},{"title":"Day21 Shiro 1","slug":"Day21-Shiro-1","date":"2022-09-13T12:07:08.000Z","updated":"2022-09-14T09:11:29.928Z","comments":true,"path":"2022/09/13/Day21-Shiro-1/","link":"","permalink":"http://zswh33.github.io/2022/09/13/Day21-Shiro-1/","excerpt":"","text":"Shirohttps://shiro.apache.org/ 介绍 Shiro与SpringSecurity类似； Apache Shiro是一个Java的安全（权限）框架； Shiro可以完成认证、授权、加密、会话管理、Web集成、缓存等。 subject：应用代码直接交互的对象Subject，即Shiro的对外API核心就是Subject，Subject代表了当前的用户。 SecurityManager：安全管理器，管理所有的Subject，负责与Shiro其他组件交互。 Realm：Shiro从Realm获取安全数据（用户，角色，权限）。SecurityManager要验证用户身份，需要从Realm获取相应的用户进行比较。 第一个Shiro程序依赖pom.xml1234567891011121314151617181920212223242526&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-core&lt;/artifactId&gt; &lt;version&gt;1.9.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Shiro uses SLF4J for logging. We&#x27;ll use the &#x27;simple&#x27; binding in this example app. See http://www.slf4j.org for more info. --&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-simple&lt;/artifactId&gt; &lt;version&gt;1.7.36&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.36&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;jcl-over-slf4j&lt;/artifactId&gt; &lt;version&gt;1.7.21&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; shiro.ini123456789101112131415161718192021222324# =============================================================================# Tutorial INI configuration## Usernames/passwords are based on the classic Mel Brooks&#x27; film &quot;Spaceballs&quot; :)# =============================================================================# -----------------------------------------------------------------------------# Users and their (optional) assigned roles# username = password, role1, role2, ..., roleN# -----------------------------------------------------------------------------[users]root = secret, adminguest = guest, guestlunch = lunch, eaterwater = water, drinker# -----------------------------------------------------------------------------# Roles with assigned permissions# roleName = perm1, perm2, ..., permN# -----------------------------------------------------------------------------[roles]admin = *eater = eat:*drinker = drink:kola:nosugar 主程序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import org.apache.shiro.SecurityUtils;import org.apache.shiro.authc.*;import org.apache.shiro.config.IniSecurityManagerFactory;import org.apache.shiro.mgt.SecurityManager;import org.apache.shiro.session.Session;import org.apache.shiro.subject.Subject;import org.apache.shiro.util.Factory;import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class Hello &#123; private static final transient Logger log = LoggerFactory.getLogger(Hello.class); public static void main(String[] args) &#123; log.info(&quot;My First Apache Shiro Application&quot;); //1. 获得安全管理器Factory Factory&lt;SecurityManager&gt; factory = new IniSecurityManagerFactory(&quot;classpath:shiro.ini&quot;); //2. 获得安全管理器实例 SecurityManager securityManager = factory.getInstance(); //3. 设置安全管理器 SecurityUtils.setSecurityManager(securityManager); Subject currentUser = SecurityUtils.getSubject();//获取当前用户 //若当前用户没有登录 if (!currentUser.isAuthenticated())&#123; UsernamePasswordToken token = new UsernamePasswordToken(&quot;root&quot;,&quot;secret&quot;); token.setRememberMe(true); try &#123; currentUser.login(token); &#125; catch (UnknownAccountException e) &#123; log.info(&quot;未知用户名&quot;); &#125;catch (IncorrectCredentialsException ice)&#123; log.info(&quot;错误的密码&quot;); &#125;catch (LockedAccountException lae)&#123; log.info(&quot;锁定的账户&quot;); &#125; &#125; Session session = currentUser.getSession();//获取当前用户的Session session.setAttribute(&quot;key&quot;,&quot;value&quot;);//设置key和value String value = (String) session.getAttribute(&quot;key&quot;);//获取key-value if (&quot;value&quot;.equals(value))&#123; log.info(&quot;正确：&quot;+value); &#125; log.info(&quot;当前用户名：&quot;+currentUser.getPrincipal());//获得当前用户名 //当前用户是否拥有角色 if (currentUser.hasRole(&quot;admin&quot;))&#123; log.info(&quot;管理员？&quot;); &#125;else &#123; log.info(&quot;不是管理员&quot;); &#125; //测试单权限 if (currentUser.isPermitted(&quot;eat:Obsidian&quot;))&#123; log.info(&quot;请不要饮食过度&quot;); &#125;else &#123; log.info(&quot;你不能吃饭。&quot;); &#125; //权限组 if (currentUser.isPermitted(&quot;drink:SnowGreen&quot;))&#123; log.info(&quot;请不要过度饮雪&quot;); &#125;else&#123; log.info(&quot;你不能喝格林雪&quot;); &#125; &#125;&#125; 运行结果123456789[main] INFO com.yn.Hello - My First Apache Shiro Application[main] INFO org.apache.shiro.session.mgt.AbstractValidatingSessionManager - Enabling session validation scheduler...[main] INFO com.yn.Hello - 正确：value[main] INFO com.yn.Hello - 当前用户名：root[main] INFO com.yn.Hello - 管理员？[main] INFO com.yn.Hello - 请不要饮食过度[main] INFO com.yn.Hello - 请不要过度饮雪Process finished with exit code 0 Subject对象的方法在Shiro里，Subject对象用来表示一个用户； 可以使用SecurityUtils.getSubject()方法获得这个对象。 方法 **isAuthenticated()**：返回boolean，当前用户是否经过验证（登录）； **login(token)**：登录一个用户，通过try-catch捕获登录错误时的操作 UnknownAccountException：没有这个用户 IncorrectCredentialsException：错误的密码 LockedAccountException：锁定的账户 getSession()：获取当前用户的Session。可以使用Session的setAttribute方法和getAttribute方法存或取值。 **getPrincipal()**：获取当前用户名； **hasRole(“admin”)**：当前用户是否拥有角色admin； **isPermitted(“eat:Obsidian”)：是否被允许有“eat:Obsidian”权限。另外一个如：isPermitted(“drink:Cola”)**则为是否拥有drink:Cola权限； **logout()**：登出。 SpringBoot与Shiro集成可能是Spring与Shiro集成？！ 简易配置 创建ShiroConfig配置类和UserRealm; UserRealm类继承AuthorizingRealm对象，重写相关方法； 123456789101112131415161718//一个自定义的UserRealm//继承AuthorizingRealm对象public class UserRealm extends AuthorizingRealm &#123; @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) &#123; System.out.println(&quot;执行了 -&gt; 授权 PrincipalCollection&quot;); //授权 return null; &#125; @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123; System.out.println(&quot;执行了 -&gt; 认证 AuthenticationToken&quot;); //有用户登录时会进入这里 //这里负责判断账号密码正确与否 return null; &#125;&#125; ShiroConfig下创建三个@Bean， 1234567891011121314151617181920212223242526272829303132333435@Configurationpublic class ShiroConfig &#123; //@Bean方式 创建 Realm 对象 自定义类 @Bean public UserRealm userRealm()&#123; return new UserRealm(); &#125; //DefaultWebSecurityManager @Bean public DefaultWebSecurityManager getDefaultWebSessionManager(@Qualifier(&quot;userRealm&quot;) UserRealm realm)&#123; DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager(); //关联UserRealm securityManager.setRealm(realm); return securityManager; &#125; //ShiroFilterFactoryBean @Bean public ShiroFilterFactoryBean getShiroFilterFactoryBean( @Qualifier(&quot;getDefaultWebSessionManager&quot;)DefaultWebSecurityManager securityManager)&#123; ShiroFilterFactoryBean bean = new ShiroFilterFactoryBean(); //关联securityManager 设置安全管理器 bean.setSecurityManager(securityManager); //这里进行一些授权的配置，如：url与角色的绑定 //配置登录API和登录页相关信息 return bean; &#125;&#125; 分别返回UserRealm、DefaultWebSecurityManager、ShiroFilterFactoryBean三个对象，其中： UserRealm直接新建一个刚刚创建的Realm并返回就可； DefaultWebSecurityManager，使用@Qualifier注解将刚刚创建的Realm Bean作为方法的参数，新建一个DefaultWebSecurityManager对象，使用setRealm方法绑定刚刚绑定的Realm，然后返回； ShiroFilterFactoryBean，使用@Qualifier注解将刚刚创建的DefaultWebSecurityManager Bean作为方法的参数，新建一个ShiroFilterFactoryBean对象，使用setSecurityManager方法绑定刚刚创建的DefaultWebSecurityManager，然后返回。 配置结束。 配置UserRealm创建一个UserRealm类，继承AuthorizingRealm类，重写： protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) 两个方法。 doGetAuthorizationInfo(PrincipalCollection principals)这个方法负责授权。 下面的方法执行结束后，会执行这个方法，负责为登录的用户添加权限（加载权限）。 这里要做的事： 创建SimpleAuthorizationInfo对象。 1SimpleAuthorizationInfo info = new SimpleAuthorizationInfo(); 从principals中获取用户的权限列表。（下面的方法为当前用户配置了principals属性，这里指用户的User对象，这里通过User.getPerms()获得用户的权限） 123//拿到当前登录的对象Subject subject = SecurityUtils.getSubject();User currentUser = (User) subject.getPrincipal(); 为用户添加权限 12//设置当前用户的权限info.addStringPermission(currentUser.getPerms());//currentUser.getPerms()是从user对象获取用户的权限 返回AuthorizationInfo对象。 示例1234567891011@Overrideprotected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) &#123; System.out.println(&quot;执行了 -&gt; 授权 PrincipalCollection&quot;); SimpleAuthorizationInfo info = new SimpleAuthorizationInfo(); //拿到当前登录的对象 Subject subject = SecurityUtils.getSubject(); User currentUser = (User) subject.getPrincipal(); //设置当前用户的权限 info.addStringPermission(currentUser.getPerms()); return info;&#125; doGetAuthenticationInfo(AuthenticationToken token)这个方法负责认证。 有用户登录时会进入这个方法。 这里要做的事： 从数据库中获取用户相关信息； 判断用户是否存在，不存在返回null； 创建一个AuthenticationInfo类型的对象，将主体对象和密码传入，然后将该对象返回。 （将密码交给Shiro，由Shiro完成密码判断和其他操作。） 示例1234567891011121314151617181920//认证@Overrideprotected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123; //一旦进行了登录，就会执行这个方法 System.out.println(&quot;执行了 -&gt; 认证 AuthenticationToken&quot;); UsernamePasswordToken usernamePasswordToken = (UsernamePasswordToken) token; //从数据库获取用户 userService是service层用于与mapper层交互的对象。 User user = userService.queryUserByUsername(usernamePasswordToken.getUsername()); if(user==null)&#123; //没有这个用户 return null;//返回null，在登录方法（这里是Controller的login POST中）会抛出异常UnknownAccountException &#125; //判断密码是否正确 //加密方式： MD5 MD5盐值加密 //MD5盐值加密：将密码和用户名都进行加密 //密码认证交给shiro处理 有加密功能 //参数1表示当前用户的主体对象，这里user是主体对象。用于在doGetAuthorizationInfo(PrincipalCollection principals)方法中获取用户的一些信息（如：权限）。 return new SimpleAuthenticationInfo(user, user.getPassword(), &quot;&quot;);&#125; 首先将AuthenticationToken token强制转换为UsernamePasswordToken对象，然后就可以获取到登录用户的一些信息 **getUsername()**：用户名 **getPassword()**：密码 然后通过用户名从数据库中获取用户； 最后创建一个验证对象将密码传入然后将对象返回。 ShiroConfig创建一个@Configuration配置类，用于存放Shiro类的一些@Bean配置。 （这里设置类名为ShiroConfig用于示例） UserRealm1234@Beanpublic UserRealm userRealm()&#123; return new UserRealm();&#125; 创建UserRealm对象并返回。 DefaultWebSecurityManager123456789@Beanpublic DefaultWebSecurityManager getDefaultWebSessionManager(@Qualifier(&quot;userRealm&quot;) UserRealm realm)&#123; DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager(); //关联UserRealm securityManager.setRealm(realm); return securityManager;&#125; 创建Bean DefaultWebSecurityManager getDefaultWebSessionManager(@Qualifier(&quot;userRealm&quot;) 用于创建SecurityManager，绑定realm，并返回对象。 创建SecurityManager对象 （指定SecurityManager） 绑定realm （指定realm对象） ShiroFilterFactoryBean12345678910111213141516171819202122232425262728293031@Beanpublic ShiroFilterFactoryBean getShiroFilterFactoryBean( @Qualifier(&quot;getDefaultWebSessionManager&quot;)DefaultWebSecurityManager securityManager)&#123; ShiroFilterFactoryBean bean = new ShiroFilterFactoryBean(); //关联securityManager 设置安全管理器 bean.setSecurityManager(securityManager); /** * 添加Shiro的内置过滤器 * 一些用于示例的角色 * anon：无需认证； * authc：必须认证 */ //进行配置 Map&lt;String,String&gt; filterMap = new LinkedHashMap&lt;&gt;();//配置 bean.setFilterChainDefinitionMap(filterMap); //授权 url和角色的绑定 filterMap.put(&quot;/user/add&quot;,&quot;anon&quot;);//设置url可访问角色 filterMap.put(&quot;/user/update&quot;,&quot;authc&quot;); //配置登录API和登录页相关信息 //设置登录请求 bean.setLoginUrl(&quot;/login&quot;); //设置用户进入未经授权的页面要跳转的页面 bean.setUnauthorizedUrl(&quot;/noauth&quot;); //返回对象 return bean;&#125; 创建ShiroFilterFactoryBean对象，并将SecurityManager绑定到对象； &#96;&#96;&#96;javaShiroFilterFactoryBean bean &#x3D; new ShiroFilterFactoryBean();&#x2F;&#x2F;关联securityManager 设置安全管理器bean.setSecurityManager(securityManager);12345678910- 进行“授权”相关的配置：绑定url和角色； - ```java //进行配置 Map&lt;String,String&gt; filterMap = new LinkedHashMap&lt;&gt;();//配置 bean.setFilterChainDefinitionMap(filterMap); //授权 url和角色的绑定 filterMap.put(&quot;/user/add&quot;,&quot;anon&quot;);//设置url可访问角色 filterMap.put(&quot;/user/update&quot;,&quot;authc&quot;); 配置登录API和登录页相关配置 &#96;&#96;&#96;java&#x2F;&#x2F;配置登录API和登录页相关信息&#x2F;&#x2F;设置登录请求bean.setLoginUrl(“&#x2F;login”);&#x2F;&#x2F;设置用户进入未经授权的页面要跳转的页面bean.setUnauthorizedUrl(“&#x2F;noauth”);12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667- 返回ShiroFilterFactoryBean对象。### shiro.ini配置```ini# =======================# Shiro INI configuration# =======================[main]# 放一些配置# 配置密码编码：sha256sha256Matcher = org.apache.shiro.authc.credential.Sha256CredentialsMatcheriniRealm.credentialsMatcher = $sha256Matcher[users]# 放一些静态用户 ，一般在数据库中，不在这里编写。# 用户名 = 密码,角色1,角色2yn = 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92,admin,eater[roles]# 这里放角色以及一些权限# 角色名 = 权限# 访客可以注册账户，登录账户guest = user:reg,login# 登录用户可以更新自己的信息user = user:update# vip1可以自定义主页CSSvip1 = user:index:update:css# vip2可以自定义主页HTML和CSSvip2 = user:index:update:html,css# vip3可以自定义主页的HTML、CSS和JS（JS需要经过审核）vip3 = user:index:update:*# admin可以为所欲为admin = *#[urls]# 为url绑定 角色/权限# 允许任何人访问根目录/ = anon# 允许任何人创建用户/user/create = anon# 允许任何人进行登录/user/login = anon# 仅允许登录的用户进入/user/根目录下页面/user/* = authc# 仅允许管理员且被认证的用户进入/admin/下所有页面/admin/** = authc,roles[admin]# 拥有user:index:update:html权限的用户可以进入/user/index/html/user/index/html = perms[user:index:update:html]/user/index/css = perms[user:index:update:css]/user/index/js = perms[user:index:update:js] 一些Filter Filter Name Class（基于org.apache.shiro.web.filter） 介绍 anon authc.AnonymousFilter 匿名用户 authc authc.FormAuthenticationFilter 认证用户 authcBasic authc.BasicHttpAuthenticationFilter authcBearer authc.BearerHttpAuthenticationFilter invalidRequest InvalidRequestFilter 无效请求 logout authc.LogoutFilter 登出请求 noSessionCreation session.NoSessionCreationFilter 在此页面不能创建Session perms authz.PermissionsAuthorizationFilter 当用户具有指定权限，则允许访问 port authz.PortFilter 位于特定端口上的过滤器。 rest authz.HttpMethodPermissionFilter RESTful环境 roles authz.RolesAuthorizationFilter 判断用户拥有指定角色 ssl authz.SslFilter 必须使用ssl访问 user authc.UserFilter 若是已知用户且已登录，则允许访问该页面，否则不允许访问。 Thymeleaf与Shiro集成https://github.com/theborakompanioni/thymeleaf-extras-shiro 依赖HTML12&lt;html xmlns:shiro=&quot;http://www.pollix.at/thymeleaf/shiro&quot;&gt; &lt;!-- 已经不能用了 后续如果找到能用的 再改 --&gt; pom.xml12345&lt;dependency&gt; &lt;groupId&gt;com.github.theborakompanioni&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-extras-shiro&lt;/artifactId&gt; &lt;version&gt;$&#123;thymeleaf-shiro.version&#125;&lt;/version&gt;&lt;/dependency&gt; 配置类12345//整合ShiroDialect：用来整合shiro和thymeleaf@Beanpublic ShiroDialect getShiroDialect()&#123; return new ShiroDialect();&#125; 添加一个返回ShiroDialect对象的@Bean方法就可。 可以放在ShrioConfig类下。 作用 可以在Thymeleaf下的HTML文件里添加Shiro为JSP设计的页面控制标签； 1&lt;shiro:guest&gt;未登录的标志&lt;/shiro:guest&gt; 可以将标签作为属性写在HTML元素中。 1&lt;p shiro:guest&gt;未登录的标志2&lt;/p&gt; 一些标签&#x2F;属性guest当前用户是访客，未登录状态； 1&lt;shiro:guest&gt;请登录&lt;/shiro:guest&gt; 1&lt;p shiro:guest&gt;请登录&lt;/p&gt; user当前用户已登录； 1&lt;shiro:user&gt;Welcome back！张三&lt;/shiro:user&gt; 1&lt;p shiro:user&gt;Welcome back！张三&lt;/p&gt; authenticated在当前会话期间，用户通过身份验证。（与user不同，authenticated不能在只有remember-me没有会话的情况下有效，如：重新打开浏览器&#x2F;会话关闭） 1&lt;shiro:authenticated&gt;身份通过验证，可以访问隐私内容&lt;/shiro:authenticated&gt; 1&lt;p shiro:authenticated&gt;身份通过验证，可以访问隐私内容&lt;/p&gt; notAuthenticated在当前会话期间未成功验证。（与authenticated相反） 1&lt;shiro:notAuthenticated&gt;需要二次验证才能访问当前内容 / 请登录&lt;/shiro:notAuthenticated&gt; 1&lt;p shiro:notAuthenticated&gt;需要二次验证才能访问当前内容 / 请登录&lt;/p&gt; principal将输出在后端配置的principal属性，toString()方法的返回值； 1234567&lt;shiro:principal&gt;&lt;/shiro:principal&gt;&lt;shiro:principal/&gt;&lt;shiro:principal type=&quot;com.foo.User&quot; property=&quot;firstName&quot;/&gt;&lt;p shiro:principal&gt;&lt;/p&gt;&lt;!-- thymeleaf-extras-shiro插件不支持type属性和property属性？ --&gt; 类型type指定principal的类型，指定后将按照不同方式进行输出。不指定则按照toString输出。 1&lt;principal type=&quot;java.lang.Integer&quot;/&gt; 属性值property若principal是一个对象，可以通过这种方式指定要输出的对象的属性值。 1&lt;shiro:principal type=&quot;User&quot; property=&quot;lastname&quot;/&gt; hasRole用户拥有指定角色时。 1&lt;shiro:hasRole name=&quot;admin&quot;&gt;管理员你好&lt;/shiro:hasRole&gt; 1&lt;p shiro:hasRole=&quot;admin&quot;&gt;管理员你好&lt;/p&gt; lacksRole用户没有指定角色时。 1&lt;shiro:lacksRole name=&quot;admin&quot;&gt;你不是管理员吧？&lt;/shiro:lacksRole&gt; 1&lt;p shiro:lackRole=&quot;admin&quot;&gt;闲杂人等不得入内&lt;/p&gt; 缺少admin角色的用户会看到上面的内容。 hasAnyRoles用户拥有以下任意角色时。 1&lt;shiro:hasAnyRoles name=&quot;developer, project manager, administrator&quot;&gt;你好，管理员&lt;/shiro:hasAnyRoles&gt; 1&lt;p shiro:hasAnyRoles=&quot;developer, project manager, administrator&quot;&gt;你好，管理员&lt;/p&gt; 当访问这是developer, project manager, administrator其中任意一种角色时，可以看到上面内容。 hasAllRoles用户拥有以下所有角色时。 1&lt;shiro:hasAllRoles name=&quot;developer, project manager, administrator&quot;&gt;拥有前面所有角色的用户能看得见&lt;/shiro:hasAllRoles&gt; 123&lt;p shiro:hasAllRoles=&quot;developer, project manager, administrator&quot;&gt; 拥有前面所有角色的用户能看得见&lt;/p&gt; hasPermission用户拥有具有指定的权限。（暗示：通过角色获取的权限） 123&lt;shiro:hasPermission name=&quot;user:create&quot;&gt; &lt;a href=&quot;createUsers&quot;&gt;Create a new User&lt;/a&gt;&lt;/shiro:hasPermission&gt; 123&lt;p shiro:hasPermission=&quot;user:create&quot;&gt; &lt;a href=&quot;createUsers&quot;&gt;Create a new User&lt;/a&gt;&lt;/p&gt; lacksPermission用户缺少指定权限时。 123&lt;shiro:lacksPermission name=&quot;user:delete&quot;&gt; Sorry, you are not allowed to delete user accounts.&lt;/shiro:lacksPermission&gt; 123&lt;p shiro:lacksPermission=&quot;user:create&quot;&gt; &lt;a href=&quot;createUsers&quot;&gt;Create a new User&lt;/a&gt;&lt;/p&gt;","categories":[],"tags":[{"name":"Shiro","slug":"Shiro","permalink":"http://zswh33.github.io/tags/Shiro/"}]},{"title":"Day21 Linux 一些软件用法","slug":"Day21-Linux-一些软件用法","date":"2022-09-13T04:25:01.000Z","updated":"2022-09-13T07:28:47.969Z","comments":true,"path":"2022/09/13/Day21-Linux-一些软件用法/","link":"","permalink":"http://zswh33.github.io/2022/09/13/Day21-Linux-%E4%B8%80%E4%BA%9B%E8%BD%AF%E4%BB%B6%E7%94%A8%E6%B3%95/","excerpt":"","text":"Screen可以在Linux系统下开启多个作业，并放到后台运行。 参数 参数 介绍 -S &lt;作业名&gt; 创建新的作业 -r &lt;作业名&gt; 恢复离线的作业 -ls 查看所有的作业 -wipe 删除无法使用的作业 -R 尝试恢复离线的作业，若找不到，则建立新的作业 快捷键 快捷键 介绍 ctrl + a d 离开终端 Dockerdocker pull ubuntu 载入ubuntu的镜像 docker run -it ubuntu &#x2F;bin&#x2F;bash 以命令行方式进入容器 容器使用运行、停止、重启、进入 参数 介绍 -i 交互式操作 -t 终端 ps -a 查看所有容器 -d 后台运行 –name 设定名字 start 容器id 启动一个停止的容器 stop 容器id 停止一个容器 restart 容器id 重启一个容器 attach 容器id 进入容器。退出后会使容器停止。 exec 容器id 进入容器。exit后容器不会停止。 导入、导出、删除、增加、清除 参数 介绍 export 容器id &gt; ubuntu.tar 导出容器的快照到本地文件ubuntu.tar cat docker&#x2F;ubuntu.tar | docker import - test&#x2F;ubuntu:v1 将快照ubuntu.tar导入到镜像test&#x2F;ubuntu:v1 import http://xx.xx/xxx.tgz example&#x2F;imagerepo 从url导入 rm -f 容器id 删除容器 run 镜像名 参数 （如：run -d -P training&#x2F;webapp python q.py） 从镜像运行容器 container prune 清理所有处于终止状态的容器。 其他参数 参数 介绍 -P 将容器内部使用的网络端口随机映射到使用的主机上。 -p 设置端口映射。-p 5001:5000 将容器的5000端口映射到主机的5001端口 logs id&#x2F;name 查看应用输出 logs -f id&#x2F;name 以tail -f方式查看输出 top 查看进程 inspect 查看状态 镜像使用https://hub.docker.com/ 查看，下载，删除 参数 介绍 images 查看本机上的镜像 pull 下载镜像。docker pull ubuntu:13.10 rmi 删除镜像 保存、加载 保存镜像 保存镜像：docker save [options] images [images…] 示例： docker save -o nginx.tar nginx:latest docker save &gt; ngin.tar ngin:latest 加载镜像 加载镜像：docker load [options] 示例： docker load -i nginx.tar docker load &lt; nginx.tar 更新docker commit -m&#x3D;”has update” -a&#x3D;”zhansan” 容器id zhangsan&#x2F;ubuntu:v2 先创建一个容器， 然后在容器内将需要更新的内容修改， 最后使用以下命令提交一个新的镜像。 1docker commit -m=&quot;has update&quot; -a=&quot;zhansan&quot; bbbbbbbbbbb zhangsan/ubuntu:v2 docker commit：提交更新的命令 -m：提交的描述信息 -a：指定镜像作者 bbbbbbbbbbb：容器id zhangsan&#x2F;ubuntu:v2：要创建的镜像名 然后就可以使用docker run -ti zhangsan&#x2F;ubuntu:v2 &#x2F;bin&#x2F;bash来启动一个容器。 构建镜像docker build https://www.runoob.com/docker/docker-image-usage.html hole… 容器连接端口映射参数 -P：随机端口映射。 -p：指定端口映射。 5000:4000将容器的4000端口映射到主机的5000端口。 指定容器网络地址，如127.0.0.1:5000:4000。主机可以使用127.0.0.1:5000访问容器。 指定协议。127.0.0.1:5000:4000&#x2F;udp； 查看端口绑定docker port 容器name 其他 参考文献 https://www.runoob.com/docker/","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://zswh33.github.io/tags/Linux/"}]},{"title":"一些配置模板","slug":"一些配置模板","date":"2022-09-11T09:42:56.000Z","updated":"2022-09-11T09:46:12.311Z","comments":true,"path":"2022/09/11/一些配置模板/","link":"","permalink":"http://zswh33.github.io/2022/09/11/%E4%B8%80%E4%BA%9B%E9%85%8D%E7%BD%AE%E6%A8%A1%E6%9D%BF/","excerpt":"","text":"MyBatisMapper XML模板112345678910111213141516171819202122232425262728&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!-- 为这个mapper指定一个唯一的namespace，namespace的值习惯上设置成包名+sql映射文件名，这样就能够保证namespace的值是唯一的 --&gt;&lt;mapper namespace=&quot;cn.mybatis.mapper.UserMapper&quot;&gt; &lt;!-- 添加数据 --&gt; &lt;insert id=&quot;add&quot; parameterType=&quot;cn.mybatis.beans.User&quot;&gt; insert into t_user(name,age) value(#&#123;name&#125;,#&#123;age&#125;) &lt;/insert&gt; &lt;!-- 删除数据 --&gt; &lt;delete id=&quot;del&quot; parameterType=&quot;int&quot;&gt; delete from t_user where id = #&#123;id&#125; &lt;/delete&gt; &lt;!-- 修改数据 --&gt; &lt;update id=&quot;update&quot; parameterType=&quot;cn.mybatis.beans.User&quot;&gt; update t_user set name=#&#123;name&#125;,age=#&#123;age&#125; where id=#&#123;id&#125; &lt;/update&gt; &lt;!--根据id查询得到一个user对象--&gt; &lt;select id=&quot;getUser&quot; parameterType=&quot;int&quot; resultType=&quot;cn.mybatis.beans.User&quot;&gt; select * from t_user where id=#&#123;id&#125; &lt;/select&gt; &lt;/mapper&gt; 模板212345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.yn.Mapper&quot;&gt; &lt;resultMap id=&quot;employeeMapper&quot; type=&quot;com.yn.pojo.Employee&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;eid&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;ename&quot;/&gt; &lt;result property=&quot;age&quot; column=&quot;eage&quot;/&gt; &lt;result property=&quot;position&quot; column=&quot;eposition&quot;/&gt; &lt;/resultMap&gt; &lt;select id=&quot;getListById&quot; resultMap=&quot;employeeMapper&quot; parameterType=&quot;int&quot;&gt; select * from employee where eid = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt;","categories":[],"tags":[{"name":"templates","slug":"templates","permalink":"http://zswh33.github.io/tags/templates/"}]},{"title":"Day19 SpringBoot 7 SpirngBootMyBatis SpringSecurity Thmeleaf与SpringSecurity","slug":"Day19-SpringBoot-7","date":"2022-09-11T09:24:16.000Z","updated":"2022-09-13T12:15:50.426Z","comments":true,"path":"2022/09/11/Day19-SpringBoot-7/","link":"","permalink":"http://zswh33.github.io/2022/09/11/Day19-SpringBoot-7/","excerpt":"","text":"SpringBoot MyBatis整合MyBatis的starter是MyBatis官方搞得，不是SpringBoot官方搞的 依赖123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.2.2&lt;/version&gt;&lt;/dependency&gt; 使用&#x2F;代码 添加依赖； 在application配置中添加DataSource配置和mybatis配置； 添加mybatis的type-aliases-package和mapper-locations。其中type-aliases-package是pojo类的包名，mapper-locations是mapper文件的位置； 123mybatis: type-aliases-package: com.yn.springbootwebstudy4_mybatis.pojo mapper-locations: classpath:mybatis/mapper/*.xml # 这里是resources下的mybatis/mapper文件夹下的所有xml文件 添加DataSource配置。添加spring.datasource下的username、password、url和driver-class-name配置。 123456spring: datasource: username: root # 用户名 password: 123456 url: jdbc:mysql://localhost:3306/springbootstudy?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8 driver-class-name: com.mysql.cj.jdbc.Driver 创建Mapper接口，使用@Mapper注解和@Repository注解； 12345678910@Mapper //表示这是一个MyBatis的Mapper类@Repositorypublic interface UserMapper &#123; List&lt;User&gt; queryUserList(); User queryUserById(Integer id); int addUser(User user); int updateUser(User user); int deleteUser(Integer id);&#125; 在mapper-locations指定的位置创建Mapper的xml文件，并配置相关内容。 123456789101112131415161718&lt;mapper namespace=&quot;com.yn.springbootwebstudy4_mybatis.mapper.UserMapper&quot;&gt; &lt;cache/&gt; &lt;select id=&quot;queryUserList&quot; resultType=&quot;User&quot; useCache=&quot;true&quot;&gt; select * from user; &lt;/select&gt; &lt;select id=&quot;queryUserById&quot; parameterType=&quot;int&quot; resultType=&quot;User&quot;&gt; select * from user where id=#&#123;id&#125; &lt;/select&gt; &lt;insert id=&quot;addUser&quot; parameterType=&quot;User&quot;&gt; insert into user(username,password,nickname,regDate) values(#&#123;username&#125;,#&#123;password&#125;,#&#123;nickname&#125;,#&#123;regDate&#125;) &lt;/insert&gt; &lt;delete id=&quot;deleteUser&quot; parameterType=&quot;int&quot;&gt; delete from user where id=#&#123;id&#125; &lt;/delete&gt; &lt;update id=&quot;updateUser&quot; parameterType=&quot;User&quot;&gt; update user set username=#&#123;username&#125;,password=#&#123;password&#125;,nickname=#&#123;nickname&#125;,regDate=#&#123;regDate&#125; where id=#&#123;id&#125;; &lt;/update&gt;&lt;/mapper&gt; 使用@Autowired注解使用即可 12345678910111213141516171819202122232425262728@RestControllerpublic class UserController &#123; @Autowired private UserMapper userMapper; @GetMapping(&quot;/user/list&quot;) public List&lt;User&gt; queryUserList()&#123; List&lt;User&gt; users = userMapper.queryUserList(); return users; &#125; @GetMapping(&quot;/user/get/&#123;id&#125;&quot;) public User queryUserById(@PathVariable(&quot;id&quot;) Integer id)&#123; return userMapper.queryUserById(id); &#125; @GetMapping(&quot;/user/add&quot;) public int addUser(User user)&#123; return userMapper.addUser(user); &#125; @GetMapping(&quot;/user/delete/&#123;id&#125;&quot;) public int deleteUser(@PathVariable(&quot;id&quot;) Integer id)&#123; return userMapper.deleteUser(id); &#125; @GetMapping(&quot;/user/update&quot;) public int updateUser(User user)&#123; return userMapper.updateUser(user); &#125;&#125; ResultMap复习12345678910111213141516171819202122232425262728293031323334&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.yn.springbootwebstudy2.mapper.EmployeeMapper&quot;&gt; &lt;resultMap id=&quot;Employee&quot; type=&quot;Employee&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot; /&gt; &lt;result column=&quot;lastname&quot; property=&quot;lastName&quot;/&gt; &lt;result column=&quot;email&quot; property=&quot;email&quot; /&gt; &lt;result column=&quot;gender&quot; property=&quot;gender&quot;/&gt; &lt;result column=&quot;birth&quot; property=&quot;birth&quot; jdbcType=&quot;DATE&quot; javaType=&quot;Date&quot;/&gt; &lt;collection property=&quot;department&quot; ofType=&quot;Department&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;dname&quot; property=&quot;departmentName&quot;/&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;insert id=&quot;add&quot; parameterType=&quot;Employee&quot;&gt; insert into employee(lastName,email,gender,department,birth) values(#&#123;lastName&#125;,#&#123;email&#125;,#&#123;gender&#125;,#&#123;department.id&#125;,#&#123;birth&#125;) &lt;/insert&gt; &lt;select id=&quot;get&quot; resultMap=&quot;Employee&quot;&gt; select * from employee where id=#&#123;id&#125; &lt;/select&gt; &lt;select id=&quot;getList&quot; parameterType=&quot;Integer&quot; resultMap=&quot;Employee&quot;&gt; SELECT e.id id,lastname,email,gender,birth,department,departmentname &#x27;dname&#x27; from department d,employee e WHERE d.id=e.department; &lt;/select&gt; &lt;delete id=&quot;delete&quot; parameterType=&quot;int&quot;&gt; delete from employee where id=#&#123;id&#125; &lt;/delete&gt; &lt;update id=&quot;update&quot; parameterType=&quot;Employee&quot;&gt; update employee set lastname=#&#123;lastName&#125;,email=#&#123;email&#125;,gender=#&#123;gender&#125;,birth=#&#123;birth&#125;,department=#&#123;department.id&#125; where id=#&#123;id&#125; &lt;/update&gt;&lt;/mapper&gt; Spring Security（安全）sudo rm -rf /* 以管理员身份sudo 删除ReMove -垃圾文件RubbishFile 根目录下&#x2F;所有文件* Spring Security is a powerful and highly customizable authentication and access-control framework. It is the de-facto standard for securing Spring-based applications. Spring Security是一个强大的可高度自定义的认证和访问控制框架。它是对于保护Spring应用实际上的标准。 引入实现方式：shiro、SpringSecurity。 认证、授权 原理：AOP切面 简介Spring Security是针对Spring项目的安全框架，也是Spring Boot底层安全模块默认的计数选型，可以实现强大的Web安全控制。对于安全控制，仅需要引入spring-boot-starter-security模块，进行少量的配置，即可实现强大的安全管理。 WebSecurityConfigurerAdapter：自定义的Security策略； AuthenticationManagerBuilder：自定义认证策略； @EnableWebSecurity：开启WebSecurity模式 Spring Security的两个主要目标：认证、授权（访问控制）。 认证：Authentication 授权：Authorization 依赖12345&lt;!--Security--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt; 认证和授权（新）2022.09.13 来自WebSecurityConfigurerAdapter的启示 123DeprecatedUse a SecurityFilterChain Bean to configure HttpSecurity or a WebSecurityCustomizer Bean to configure WebSecurity 使用一个SecurityFilterChain Bean去配置HttpSecurity； 使用一个WebSecurityCustomizer Bean去配置WebSecurity； 方法 创建配置类使用@EnableWebSecurity注解； 创建@Bean，两个： 认证：为角色分配可访问的页面 123456789101112131415161718192021222324@Beanpublic SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception &#123; http.authorizeHttpRequests() .antMatchers(&quot;/&quot;).permitAll()//为所有用户授权根目录 .antMatchers(&quot;/level1/**&quot;).hasRole(&quot;vip1&quot;)//为vip1授权/level1/**目录。 .antMatchers(&quot;/level2/**&quot;).hasRole(&quot;vip2&quot;) .antMatchers(&quot;/level3/**&quot;).hasRole(&quot;vip3&quot;); http.formLogin();//使用默认生成的登录页面 http.csrf().disable();//禁用csrf防御 http.logout().logoutSuccessUrl(&quot;/&quot;);//登出后跳到根目录页面 http.rememberMe();//“记住我”，在浏览器添加一个cookie，默认保存两周时间 //在此之前，一律为关闭浏览器即关闭会话，会自动退出登录。 http.formLogin().loginPage(&quot;/login&quot;)//自定义登录页 .loginProcessingUrl(&quot;/loginxx&quot;)//修改登录时post的url，默认/login .usernameParameter(&quot;u&quot;)//修改表单的用户名的key，默认username .passwordParameter(&quot;p&quot;);//修改表单的密码的key，默认password// .failureForwardUrl(&quot;/login&quot;)//失败时跳转，默认/login?error。// .successForwardUrl(&quot;/&quot;)//成功时跳转页面，默认为登录前页面，若没有登录前页面，则为主页。 return http.build();&#125; 授权： 12345678910@Beanpublic UserDetailsService userDetailsService() &#123; BCryptPasswordEncoder passwordEncoder = new BCryptPasswordEncoder(); UserDetails[] user = &#123; User.withDefaultPasswordEncoder().username(&quot;root&quot;).password(&quot;123456&quot;).roles(&quot;vip1&quot;,&quot;vip2&quot;,&quot;vip3&quot;).build(), User.withDefaultPasswordEncoder().username(&quot;zhangsan&quot;).password(&quot;123456&quot;).roles(&quot;vip1&quot;,&quot;vip2&quot;).build(), User.withDefaultPasswordEncoder().username(&quot;lisi&quot;).password(&quot;123456&quot;).roles(&quot;vip1&quot;).build() &#125;; return new InMemoryUserDetailsManager(user);&#125; HttpSecurity的一些方法 .antMatchers(“&#x2F;“).permitAll()&#x2F;&#x2F;为根目录允许所有 .antMatchers(“&#x2F;level1&#x2F;**“).hasRole(“vip1”)&#x2F;&#x2F;为level1目录分配vip1角色 **http.formLogin()：若没有使用FormLoginConfigurer.logPage(String)**指定登录页，将生成一个默认的登录页； **http.csrf().disable()**：禁用csrf防御； **http.logout().logoutSuccessUrl(“&#x2F;“)**：登出成功后跳到根目录页面。 **http.rememberMe()**：在登录页添加“记住我”checkbox，若为true，则登录时会在浏览器添加一个cookie，默认保存两周时间，保持用户登录。在此之前，一律为关闭浏览器即关闭会话，会自动退出登录。 http.rememberMe().rememberMeParameter(“rem”) 修改”记住我”的key，默认为remember-me **http.formLogin()**，可以定义登录API的相关参数 loginPage(“&#x2F;login”)&#x2F;&#x2F;自定义登录页 .loginProcessingUrl(“&#x2F;loginxx”) 修改登录时post的url，默认&#x2F;login .usernameParameter(“u”) 修改表单的用户名的key，默认username .passwordParameter(“p”) 修改表单的密码的key，默认password .failureForwardUrl(“&#x2F;login”) 失败时跳转，默认&#x2F;login?error。 .successForwardUrl(“&#x2F;“) 成功时跳转页面，默认为登录前页面，若没有登录前页面，则为主页。 完整代码123456789101112131415161718192021222324252627282930313233343536373839@EnableWebSecurity@Configurationpublic class FormLoginSecurityConfig&#123; @Bean public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception &#123; http.authorizeHttpRequests() .antMatchers(&quot;/&quot;).permitAll() .antMatchers(&quot;/level1/**&quot;).hasRole(&quot;vip1&quot;) .antMatchers(&quot;/level2/**&quot;).hasRole(&quot;vip2&quot;) .antMatchers(&quot;/level3/**&quot;).hasRole(&quot;vip3&quot;); http.formLogin();//使用默认生成的登录页面 http.csrf().disable();//禁用csrf防御 http.logout().logoutSuccessUrl(&quot;/&quot;);//登出后跳到根目录页面 http.rememberMe();//“记住我”，在浏览器添加一个cookie，默认保存两周时间 //在此之前，一律为关闭浏览器即关闭会话，会自动退出登录。 http.formLogin().loginPage(&quot;/login&quot;)//自定义登录页 .loginProcessingUrl(&quot;/loginxx&quot;)//修改登录时post的url，默认/login .usernameParameter(&quot;u&quot;)//修改表单的用户名的key，默认username .passwordParameter(&quot;p&quot;);//修改表单的密码的key，默认password// .failureForwardUrl(&quot;/login&quot;)//失败时跳转，默认/login?error。// .successForwardUrl(&quot;/&quot;)//成功时跳转页面，默认为登录前页面，若没有登录前页面，则为主页。 return http.build(); &#125; @Bean public UserDetailsService userDetailsService() &#123; BCryptPasswordEncoder passwordEncoder = new BCryptPasswordEncoder(); UserDetails[] user = &#123; User.withDefaultPasswordEncoder().username(&quot;root&quot;).password(&quot;123456&quot;).roles(&quot;vip1&quot;,&quot;vip2&quot;,&quot;vip3&quot;).build(), User.withDefaultPasswordEncoder().username(&quot;zhangsan&quot;).password(&quot;123456&quot;).roles(&quot;vip1&quot;,&quot;vip2&quot;).build(), User.withDefaultPasswordEncoder().username(&quot;lisi&quot;).password(&quot;123456&quot;).roles(&quot;vip1&quot;).build() &#125;; return new InMemoryUserDetailsManager(user); &#125;&#125; 自定义登录页在@Bean的SecurityFilterChain securityFilterChain(HttpSecurity http)下使用http.formLogin().loginPage(&quot;/login&quot;)指定登录页后，登录页需要适配springBoot的api。 API默认url:http://127.0.0.1:8080/login form:username&#x3D;root&amp;password&#x3D;123456&amp;remember-me&#x3D;on 12345&#123; username:&quot;root&quot;, password:&quot;123456&quot;, &quot;remember-me&quot;:&quot;on&quot;&#125; 上面的示例url:http://127.0.0.1:8080/loginxx form:u&#x3D;root&amp;p&#x3D;123456&amp;rem&#x3D;on 12345&#123; u:&quot;root&quot;, p:&quot;123456&quot;, rem:&quot;on&quot;&#125; Thmeleaf与Spring Security整合可以在templates下页面上使用sec属性标签来控制页面内容。 依赖pom.xml123456789101112&lt;!--Security-thymeleaf整合--&gt;&lt;dependency&gt; &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-extras-springsecurity5&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--Security--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt; html12&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot; xmlns:sec=&quot;http://www.thymeleaf.org/extras/spring-security&quot;&gt; 使用方法以sec:authorize=&quot;isAuthenticated()&quot;为例 添加依赖和html的xmlns； 代码： 1&lt;div sec:authorize=&quot;isAuthenticated()&quot;&gt;asd&lt;/div&gt; 这里表示，若已登录，则显示该部分div，否则不显示该部分div。 一些属性 **sec:authorize&#x3D;””**：内含判断条件，若条件成立，则显示该部分组件。如： 1&lt;div sec:authorize=&quot;isAuthenticated()&quot;&gt;asd&lt;/div&gt; 则表示当SpringSecurity的验证系统登录后，则显示该部分内容。 **isAuthenticated()**：是否已经登录； **hasRole(‘vip2’)**：登录的用户是否拥有role vip2。 … **sec:authentication&#x3D;””**：内含一些变量，运行后会将变量的值放在元素的innerHTML中； name：用户名； principal.authorities：用户的角色，为数组。 其他MVCM：数据和业务 C：交接 V：HTML 认证和授权（旧）WebSecurityConfigurerAdapter过时 方法 创建SecurityConfig配置类，使用@EnableWebSecurity注解，继承WebSecurityConfigurerAdapter类 12@EnableWebSecuritypublic class WebSecurityConfig extends WebSecurityConfigurerAdapter &#123;...&#125; 重写configure的两个方法，分别为configure(HttpSecurity http)和configure(AuthenticationManagerBuilder auth)。第一个用于认证，即为不同url分配不同的角色。第二个用于授权，为不同的用户分配不同的角色。 1234567891011121314151617181920212223242526//授权@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; http.authorizeHttpRequests() .antMatchers(&quot;/&quot;).permitAll()//为根目录允许所有 .antMatchers(&quot;/level1/**&quot;).hasRole(&quot;vip1&quot;)//为level1目录分配vip1角色 .antMatchers(&quot;/level2/**&quot;).hasRole(&quot;vip2&quot;) .antMatchers(&quot;/level3/**&quot;).hasRole(&quot;vip3&quot;); http.formLogin();//使用默认生成的登录页面 http.csrf().disable();//禁用csrf防御 http.logout().logoutSuccessUrl(&quot;/&quot;);//登出后跳到根目录页面&#125;//认证，SpringBoot//密码编码：PasswordEncoder@Overrideprotected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; //应该在数据库中，这里用自定义用于演示 auth.inMemoryAuthentication().passwordEncoder(new BCryptPasswordEncoder()) .withUser(&quot;lisi&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip2&quot;,&quot;vip3&quot;)//为用户名lisi分配角色vip2和vip3. .and()//拼接 .withUser(&quot;zhangsan&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip1&quot;) .and() .withUser(&quot;root&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip1&quot;,&quot;vip2&quot;,&quot;vip3&quot;);&#125; HttpSecurity的一些方法 .antMatchers(“&#x2F;“).permitAll()&#x2F;&#x2F;为根目录允许所有 .antMatchers(“&#x2F;level1&#x2F;**“).hasRole(“vip1”)&#x2F;&#x2F;为level1目录分配vip1角色 **http.formLogin()：若没有使用FormLoginConfigurer.logPage(String)**指定登录页，将生成一个默认的登录页； **http.csrf().disable()**：禁用csrf防御； **http.logout().logoutSuccessUrl(“&#x2F;“)**：登出成功后跳到根目录页面。 完整代码123456789101112131415161718192021222324252627282930313233343536package com.yn.config;import ...; @EnableWebSecuritypublic class WebSecurityConfig extends WebSecurityConfigurerAdapter &#123; //授权 @Override protected void configure(HttpSecurity http) throws Exception &#123; http.authorizeHttpRequests() .antMatchers(&quot;/&quot;).permitAll() .antMatchers(&quot;/level1/**&quot;).hasRole(&quot;vip1&quot;) .antMatchers(&quot;/level2/**&quot;).hasRole(&quot;vip2&quot;) .antMatchers(&quot;/level3/**&quot;).hasRole(&quot;vip3&quot;); //没有权限，默认到登录页面 http.formLogin(); &#125; //认证，SpringBoot //密码编码：PasswordEncoder //SpringSecurity 5.0+ 新增许多加密方式 @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; //应该在数据库中，这里用自定义用于演示 auth.inMemoryAuthentication().passwordEncoder(new BCryptPasswordEncoder()) .withUser(&quot;lisi&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip2&quot;,&quot;vip3&quot;) .and() .withUser(&quot;zhangsan&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip1&quot;) .and() .withUser(&quot;root&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip1&quot;,&quot;vip2&quot;,&quot;vip3&quot;); &#125;&#125;","categories":[],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://zswh33.github.io/tags/SpringBoot/"}]},{"title":"Day19 SpringBoot 6 SpringDate JdbcTemplate Alibaba的Druid","slug":"Day19-SpringBoot-6","date":"2022-09-11T06:20:01.000Z","updated":"2022-09-11T09:24:53.949Z","comments":true,"path":"2022/09/11/Day19-SpringBoot-6/","link":"","permalink":"http://zswh33.github.io/2022/09/11/Day19-SpringBoot-6/","excerpt":"","text":"接下来要学习的SpringBoot整合 JDBC MyBatis Druid Shiro：安全 Spring Security：安全 异步任务、邮件发送、定时任务 Swgger Dubbo + Zookeepr Spring Boot 数据库Spring Data？ Spring、Spring Boot、Spring Cloud、Spring Data！ 对于数据访问层，无论是SQL（关系型数据库）还是NOSQL（非关系型数据库），SpringBoot底层都采用Spring Data方式统一处理； MySQL使用 在application.yml中添加数据源配置； 123456spring: datasource: username: root password: 123456 url: jdbc:mysql://localhost:3306/springbootstudy?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=UTC driver-class-name: com.mysql.cj.jdbc.Driver 在要使用的类中直接创建一个引用，使用@Autowired注解。 123456789101112131415161718@SpringBootTestclass SpringBootWebStudy3DataApplicationTests &#123; @Autowired //自动注入 DataSource dataSource;//可以直接使用的数据源 @Test void contextLoads() throws SQLException &#123; //查看默认数据源 System.out.println(dataSource.getClass()); //获取数据库连接 Connection connection = dataSource.getConnection(); System.out.println(connection); connection.close(); &#125;&#125; 测试 12class com.zaxxer.hikari.HikariDataSourceHikariProxyConnection@1744190758 wrapping com.mysql.cj.jdbc.ConnectionImpl@536b71b4 链接url参数解释1jdbc:mysql://localhost:3306/springbootstudy?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=UTC jdbc:mysql://：协议名 localhost:3306/：地址 springbootstudy：数据库名 useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=UTC：参数，其中 useUnicode=true和characterEncoding=utf-8解决编码问题； serverTimezone=UTC解决时区问题。若运行过程中出错，显示时区错误，可以通过这个参数解决； 目前测试8.x版本，没有遇到相关问题，这些参数可以不加。 一些知识默认数据源：HikariDataSource SpringBoot相关类DataSourceProperties、DataSourceAutoConfiguration。 JdbcTemplateSpring对JDBC进行封装，使用JdbcTemplate可以非常方便的进行数据库操作。 使用在SpringBoot下配置之后，DataSource和JdbcTemplate通过@Autowired可以直接操作数据库。 12@AutowiredJdbcTemplate template; 代码示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556@RestControllerpublic class JDBCController &#123; @Autowired JdbcTemplate template; //查询数据库所有信息 并显示在网页上 //没有实体类 数据库中的数据如何获取 @RequestMapping(&quot;/user/list&quot;) public List&lt;Map&lt;String,Object&gt;&gt; userList()&#123; String sql = &quot;select * from user&quot;; List&lt;Map&lt;String, Object&gt;&gt; list_maps = template.queryForList(sql); return list_maps; &#125; @GetMapping(&quot;/user/add&quot;) public String addUser(User user)&#123; //username=ZhangSan&amp;password=zs1234556&amp;nickname=zs&amp;regdate=2022-02-22 System.out.println(user); String sql = String.format(&quot;insert into `springbootstudy`.`user`(`username`,`password`,`nickname`,`regdate`) values(&#x27;%s&#x27;,&#x27;%s&#x27;,&#x27;%s&#x27;,&#x27;%s&#x27;)&quot;, user.getUsername(), user.getPassword(), user.getNickname(), new SimpleDateFormat(&quot;yyyy-MM-dd&quot;).format(user.getRegdate()) ); System.out.println(sql); try &#123; return String.valueOf(template.update(sql)); &#125;catch (Exception e)&#123; return sql; &#125; &#125; @GetMapping(&quot;/user/delete/&#123;id&#125;&quot;) public String deleteUser(@PathVariable(&quot;id&quot;) Integer id)&#123; //id=1 String sql = &quot;delete from user where id=?&quot;; return String.valueOf(template.update(sql,id)); &#125; @GetMapping(&quot;/user/update&quot;) public String updateUser(User user)&#123; //username=ZhangSan&amp;password=zs1234556&amp;nickname=zs&amp;regdate=2022-02-22 System.out.println(user); String sql = &quot;update user set username=?,password=?,nickname=? where id=?&quot;; //封装 Object[] objects = &#123; user.getUsername(), user.getPassword(), user.getNickname(), user.getId() &#125;; return String.valueOf(template.update(sql,objects)); &#125;&#125; Alibaba的Druid数据源Hikari和Druid都是当前Java Web上最优秀的数据源。Hikari有优秀的速度，Druid有优秀的日志监控功能。 Druid特色：添加优秀的监控功能，拥有使用Web页面查看监控项目功能。 （Druid的监控功能不是监控数据库的，是监控Java应用的） 依赖Druid需要两个依赖：com.alibaba.druid和log4j.log4j。 123456789101112&lt;!--druid--&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.2.11&lt;/version&gt;&lt;/dependency&gt;&lt;!--log4j--&gt;&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt; 指定SpringBoot使用阿里巴巴的Druid数据源两种方式， 方式1：在SpringBoot下添加配置在SpringBoot下的配置里添加以下内容。 123spring: datasource: type: com.alibaba.druid.pool.DruidDataSource 方式2：创建配置类在config包下创建DruidConfig类，并添加druidDataSource方法，使用@Bean注解和@ConfigurationProperties(prefix &#x3D; “spring.datasource”)注解，自定义数据源。 123456789@Configuration//声明配置类public class DruidConfig &#123; @Bean//声明Bean @ConfigurationProperties(prefix = &quot;spring.datasource&quot;)//使用application的配置 public DataSource druidDataSource()&#123; return new DruidDataSource();//数据源 &#125;&#125; 使用alibaba的Druid监控功能配置监控页面（Web） 在config下创建DruidConfig类 使用@Configuration注解DruidConfig类。 12@Configurationpublic class DruidConfig &#123;...&#125; 配置数据源，并使数据源依赖于alibaba.druid。 12345@Bean@ConfigurationProperties(prefix = &quot;spring.datasource&quot;)public DataSource druidDataSources()&#123; return new DruidDataSource();&#125; 配置后台监控功能 123456789101112131415161718//后台监控功能@Beanpublic ServletRegistrationBean statViewServlet()&#123; ServletRegistrationBean&lt;StatViewServlet&gt; bean = new ServletRegistrationBean&lt;&gt;(new StatViewServlet(), &quot;/druid/*&quot;);//监控的url地址，这里为http://127.0.0.1/druid/ //增加配置 HashMap&lt;String, String&gt; initParameters = new HashMap&lt;&gt;(); //后台账号和密码配置 key是固定值不能变 loginUsername用户名 loginPassword密码 initParameters.put(&quot;loginUsername&quot;,&quot;root&quot;); initParameters.put(&quot;loginPassword&quot;,&quot;123456&quot;); //允许访问 initParameters.put(&quot;allow&quot;,&quot;&quot;);//若参数为空，表示所有人可以访问 bean.setInitParameters(initParameters);//设置初始化参数 return bean;&#125; （可选）配置Filter，使Druid不统计指定的数据。 123456789101112//通过filter配置不需要druid统计的数据@Beanpublic FilterRegistrationBean webStatFilter()&#123; FilterRegistrationBean&lt;Filter&gt; bean = new FilterRegistrationBean&lt;&gt;(); bean.setFilter(new WebStatFilter()); //不进行统计的数据 Map&lt;String,String&gt; initParameters = new HashMap&lt;&gt;(); initParameters.put(&quot;exclusions&quot;,&quot;*.js,*.css,/druid/*&quot;);//不统计符合表达式的数据，这里指所有的js和css文件。 bean.setInitParameters(initParameters); return bean;&#125; 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142@Configurationpublic class DruidConfig &#123; @Bean @ConfigurationProperties(prefix = &quot;spring.datasource&quot;) public DataSource druidDataSources()&#123; return new DruidDataSource(); &#125; //后台监控功能 @Bean public ServletRegistrationBean statViewServlet()&#123; ServletRegistrationBean&lt;StatViewServlet&gt; bean = new ServletRegistrationBean&lt;&gt;(new StatViewServlet(), &quot;/druid/*&quot;); //增加配置 HashMap&lt;String, String&gt; initParameters = new HashMap&lt;&gt;(); //后台账号和密码配置 key是固定值 loginUsername用户名 loginPassword密码 initParameters.put(&quot;loginUsername&quot;,&quot;root&quot;); initParameters.put(&quot;loginPassword&quot;,&quot;123456&quot;); //允许访问 initParameters.put(&quot;allow&quot;,&quot;&quot;);//若参数为空，表示所有人可以访问 bean.setInitParameters(initParameters);//设置初始化参数 return bean; &#125; //通过filter配置不需要druid统计的数据 @Bean public FilterRegistrationBean webStatFilter()&#123; FilterRegistrationBean&lt;Filter&gt; bean = new FilterRegistrationBean&lt;&gt;(); bean.setFilter(new WebStatFilter()); //不进行统计的数据 Map&lt;String,String&gt; initParameters = new HashMap&lt;&gt;(); initParameters.put(&quot;exclusions&quot;,&quot;*.js,*.css,/druid/*&quot;); bean.setInitParameters(initParameters); return bean; &#125;&#125; 界面展示 其他示例用的SQL1234567891011121314151617181920CREATE DATABASE springbootstudy;CREATE TABLE USER(id INT PRIMARY KEY AUTO_INCREMENT,username CHAR(30),PASSWORD CHAR(30),nickname CHAR(30),regdate date);INSERT INTO user(`username`,`PASSWORD`,`nickname`,`regdate`) VALUES(&#x27;zs123&#x27;,&#x27;123456&#x27;,&#x27;ZhangSan&#x27;,&#x27;2022-2-22&#x27;),(&#x27;ls123&#x27;,&#x27;123456&#x27;,&#x27;LiSi&#x27;,&#x27;2022-2-23&#x27;),(&#x27;yb123&#x27;,&#x27;123456&#x27;,&#x27;YuBan&#x27;,&#x27;2022-2-24&#x27;),(&#x27;xh123&#x27;,&#x27;123456&#x27;,&#x27;XiaoHong&#x27;,&#x27;2022-2-25&#x27;),(&#x27;xm123&#x27;,&#x27;123456&#x27;,&#x27;XiaoMing&#x27;,&#x27;2022-2-26&#x27;);select * from user;","categories":[],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://zswh33.github.io/tags/SpringBoot/"}]},{"title":"Day18 SpringBoot 5 Lombok thymeleaf国际化 locale springboot拦截器 springboot错误页面 session","slug":"Day18-SpringBoot-5","date":"2022-09-10T02:05:58.000Z","updated":"2022-09-11T06:19:28.546Z","comments":true,"path":"2022/09/10/Day18-SpringBoot-5/","link":"","permalink":"http://zswh33.github.io/2022/09/10/Day18-SpringBoot-5/","excerpt":"","text":"LombokLombok通过注解可以直接实现getter、setter、equals、toString等方法，不需要手动写这些方法。 注解名 介绍 @Data 整合了Getter、Setter、ToString、EqualsAndHashCode、RequiredArgsConstructor注解 @Getter getter方法 @Setter setter方法 @ToString toString方法 @EqualsAndHashCode equals和hashCode方法 @NonNull 不为Null @AllArgsConstructor 所有有参构造方法 @NoArgsConstructor 无参构造方法 … … thymeleaf国际化thymeleaf国际化可以提供页面多语言功能。配置之后可以依据Header中的语言来返回相应的语言的页面。 创建一个多语言配置文件夹，这里使用classpath:&#x2F;i18n&#x2F;。 文件名使用语言简写作为后缀。如：简体中文zh_CN，米国英语en_US。 在文件夹下创建配置文件用于表示各种语言在页面上应该显示的内容； 在html文件中添加相应的属性，使用“th:text”和表达式”#{login.tip}”。（注：表达式使用”#”作为开头） 12&lt;label class=&quot;sr-only&quot; th:text=&quot;#&#123;login.username&#125;&quot;&gt;Username&lt;/label&gt;&lt;label class=&quot;sr-only&quot; th:text=&quot;#&#123;login.password&#125;&quot;&gt;Password&lt;/label&gt; 通过url参数修改语言&#x2F;配置自定义LocaleResolver 创建一个类，实现LocaleResolver接口。根据url参数返回相应的Locale对象。 12345678910111213141516171819202122public class MyLocaleResover implements LocaleResolver &#123; //解析请求 @Override public Locale resolveLocale(HttpServletRequest request) &#123; String lang = request.getParameter(&quot;l&quot;);//获取链接中的参数l Locale localeDefault = Locale.getDefault();//如果没有就使用默认的 //如果请求的链接携带了国际化的参数 if (!StringUtils.isEmpty(lang))&#123; //zh_CN String[] lang2 = lang.split(&quot;_&quot;);//将语言和国家分开 //语言 国家 Locale locale = new Locale(lang2[0], lang2[1]); return locale;//使用url中参数指定 &#125; return localeDefault; &#125; @Override public void setLocale(HttpServletRequest request, HttpServletResponse response, Locale locale) &#123; &#125;&#125; 在SpringMvc配置中添加自定义的LocaleResolver； 12345678@Configurationpublic class MyMvcConfig implements WebMvcConfigurer &#123; //自定义的localeResolver @Bean public LocaleResolver localeResolver()&#123; return new MyLocaleResover(); &#125;&#125; 在thymeleaf语法配置结束后，使用url参数即可控制页面的语言； Locale 原理首先判断是否有本地配置，有则使用本地配置，没有则使用默认配置。 123456789@ConditionalOnMissingBean(name = DispatcherServlet.LOCALE_RESOLVER_BEAN_NAME)public LocaleResolver localeResolver() &#123; if (this.webProperties.getLocaleResolver() == WebProperties.LocaleResolver.FIXED) &#123; return new FixedLocaleResolver(this.webProperties.getLocale()); &#125;//判断本地配置是否存在，若存在则使用，不存在则执行下面 AcceptHeaderLocaleResolver localeResolver = new AcceptHeaderLocaleResolver(); localeResolver.setDefaultLocale(this.webProperties.getLocale());//使用默认的LocalteResolvery return localeResolver;&#125; hole… SpringBoot的拦截器 定义一个自定义拦截器； 12345678910111213141516public class LoginHandlerInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; //登录成功之后，应该有用户的session Object loginUser = request.getSession().getAttribute(&quot;loginUser&quot;); if(loginUser==null)&#123; //没有登录 request.setAttribute(&quot;msg&quot;,&quot;没有权限，请先登录&quot;); request.getRequestDispatcher(&quot;/&quot;).forward(request,response); return false; &#125;else &#123; return true; &#125; &#125;&#125; 在MvcConfig类下实现addInterceptors方法并注册相应的拦截器； 1234567@Configurationpublic class MyMvcConfig implements WebMvcConfigurer &#123; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new LoginHandlerInterceptor()); &#125;&#125; SpringBoot的错误页面 404等错误代码指定页面对于错误404，在templates下创建error&#x2F;404.html即可。 其他同理。 Servlet的SessionJava Servlet提供为每个session存储Map&lt;String,Object&gt;的功能； 每次有浏览器访问网站，JavaServlet会为浏览器生成一个JSESSIONID。 底层会存储JSESSIONID与Map的对应关系。 对于开发者，使用对象HttpSession可以直接为当前交互的用户存储Map数据。 注：Map存储在服务器，JSESSIONID存储在浏览器。 方法： HttpSession 介绍 setAttribute(key,value) 为当前session的Map设置一个键值对。如：setAttribute(“username”,”qweasd”)，会为session对应的Map中设置key为username值为qweasd的键值对。 invalidate() 使当前session无效化，并为浏览器删除cookies JSESSIONID。 … …. 其他i18n n. 国际化 internationalization单词的缩写。 i和n中间有18个字母。 zh_CN格式：语言_国家 zh取自拼音zhongguo前两个字母。 CRUD增删改查","categories":[],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://zswh33.github.io/tags/SpringBoot/"}]},{"title":"Day18 SpringBoot 4 MVC配置原理 扩展MVC","slug":"Day18-SpringBoot-4","date":"2022-09-09T23:53:51.000Z","updated":"2022-09-10T02:05:39.150Z","comments":true,"path":"2022/09/10/Day18-SpringBoot-4/","link":"","permalink":"http://zswh33.github.io/2022/09/10/Day18-SpringBoot-4/","excerpt":"","text":"MVC配置原理SpringBoot下的MVC自动配置https://docs.spring.io/spring-boot/docs/2.7.3/reference/html/web.html#web.servlet.spring-mvc.auto-configuration SpringBoot会默认进行配置以下内容： Inclusion of ContentNegotiatingViewResolver and BeanNameViewResolver beans.&#x2F;&#x2F;视图解析器 Support for serving static resources, including support for WebJars (covered later in this document).&#x2F;&#x2F;静态资源 并支持webjars Automatic registration of Converter, GenericConverter, and Formatter beans.&#x2F;&#x2F;类型转换器，前端后端传值转换。Formatter可以进行格式转换，如日期转换。 Support for HttpMessageConverters (covered later in this document).&#x2F;&#x2F;转换Http的请求和相应，如Java对象转换为Json。 Automatic registration of MessageCodesResolver (covered later in this document).&#x2F;&#x2F;错误代码 Static index.html support. &#x2F;&#x2F;主页自定义 Automatic use of a ConfigurableWebBindingInitializer bean (covered later in this document).&#x2F;&#x2F;将请求等封装在JavaBean中 如果想要保持SpringBootMvc的配置并且要添加更多的配置， 可以自己新建一个WebMvc的配置类， 实现WebMvcConfiguration接口并使用@Configuration注解， 重写相应的方法即可。 注意这里不用添加@EnableWebMvc注解。 123@Configurationpublic class MyMvcConfig implements WebMvcConfigurer &#123;&#125; 示例：添加自定义视图解析器在自定义的MVC配置类下添加一个视图解析器类和方法。 方法使用@Bean注解，将方法引入Spring。 12345678910111213141516@Configurationpublic class MyMvcConfig implements WebMvcConfigurer &#123; @Bean public ViewResolver myViewResolver()&#123; return new MyViewResolver(); &#125; //自定义一个视图解析器 public static class MyViewResolver implements ViewResolver &#123; @Override public View resolveViewName(String viewName, Locale locale) throws Exception &#123; return null; &#125; &#125;&#125; 在ContentNegotiatingViewResolver类的getCandidateViews方法内部打断点可以获得目前加载的视图列表； 查看结果： 在候选视图解析器中出现自定义的视图解析器。 添加@EnableWebMvc，表示完全使用自定义的WebMvc自定义配置类添加@EnableWebMvc，表示完全使用自定义的WebMvc自定义配置类。 原理 在WebMvcAutoConfiguration类中，有一个注解 1@ConditionalOnMissingBean(WebMvcConfigurationSupport.class) 表示如果出现WebMvcConfigurationSupport这个类，就不加载自动配置类 @EnableWebMvc会加载WebMvcConfigurationSupport这个类，会导致WebMvcAutoConfiguration自动配置类失效，然后使用被注解的类作为WebMvc配置类。 @EnableWebMvc注解会导入类DelegatingWebMvcConfiguration； 123456@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)@Documented@Import(DelegatingWebMvcConfiguration.class)public @interface EnableWebMvc &#123;&#125; DelegatingWebMvcConfiguration继承了WebMvcConfigurationSupport类。 1public class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport &#123;...&#125; 扩展SpringMVC使用几个示例表示如何去扩展SpringMVC。 Formatter使用 可以通过spring.mvc.format.date修改日期格式。 默认格式：dd&#x2F;MM&#x2F;yyyy 通过spring.mvc.format.dateTime修改日期时间格式。 默认格式：yyyy-MM-dd HH:mm:ss 12345# 自定义配置日期格式化spring: mvc: format: date-time: dd-MM-yyyy 功能原理在WebMvcAutoConfiguration自动配置类下有一个方法： 12345678@Bean@Overridepublic FormattingConversionService mvcConversionService() &#123; Format format = this.mvcProperties.getFormat(); WebConversionService conversionService = new WebConversionService(new DateTimeFormatters().dateFormat(format.getDate()).timeFormat(format.getTime()).dateTimeFormat(format.getDateTime())); addFormatters(conversionService); return conversionService;&#125; 这个方法引用了this.mvcProperties.getFormat();，mvcProperties指向一个WebMVCProperties对象。WebMVCProperties是SpringBoot下WebMvc的配置类。 1private final WebMvcProperties mvcProperties; 进入WebMvcProperties 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//省略后的WebMvcProperties@ConfigurationProperties(prefix = &quot;spring.mvc&quot;)//表示可以使用spring.mvc前缀配置类中内容。public class WebMvcProperties &#123;... private final Format format = new Format();... public Format getFormat() &#123; return this.format; &#125;... public static class Format &#123; /** * Date format to use, for example &#x27;dd/MM/yyyy&#x27;. */ private String date;//字符串格式 /** * Time format to use, for example &#x27;HH:mm:ss&#x27;. */ private String time; /** * Date-time format to use, for example &#x27;yyyy-MM-dd HH:mm:ss&#x27;. */ private String dateTime; public String getDate() &#123; return this.date; &#125; public void setDate(String date) &#123; this.date = date; &#125; public String getTime() &#123; return this.time; &#125; public void setTime(String time) &#123; this.time = time; &#125; public String getDateTime() &#123; return this.dateTime; &#125; public void setDateTime(String dateTime) &#123; this.dateTime = dateTime; &#125; &#125;...&#125; 得知： 可以通过spring.mvc.format.date修改日期格式。 通过spring.mvc.format.dateTime修改日期时间格式。 在自定义配置类中添加自定义视图解析器12345678910//全面扩展 springmvc@Configurationpublic class MyMvcConfig implements WebMvcConfigurer &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; WebMvcConfigurer.super.addViewControllers(registry); registry.addViewController(&quot;/uwupu&quot;).setViewName(&quot;test&quot;); &#125;&#125; registry.addViewController(&quot;/yn&quot;).setViewName(&quot;test&quot;);将&#x2F;yn指向视图test。 结果： 其他实现了视图解析器接口的类，这个类就是视图解析器。","categories":[],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://zswh33.github.io/tags/SpringBoot/"}]},{"title":"Day16 SpringBoot 3 全局配置文件如何生效 静态资源 thymeleaf简述","slug":"Day16-SpringBoot-3","date":"2022-09-08T09:28:08.000Z","updated":"2022-09-27T07:45:44.582Z","comments":true,"path":"2022/09/08/Day16-SpringBoot-3/","link":"","permalink":"http://zswh33.github.io/2022/09/08/Day16-SpringBoot-3/","excerpt":"","text":"自动配置原理：全局配置文件如何生效@Conditional派生注解当@Conditional指定的条件达成时，被@Conditional注解的类才能生效。 注解在类上，在注解的参数中可以指定一些条件，当条件达成时，被注解的类的内容才能生效，否则不生效。 @Conditional扩展注解 作用 @ConditionalOnJava 系统Java版本是否符合要求 @ConditionalOnBean 容器中存在指定Bean @ConditionalOnMissingBean 容器中不存在指定Bean @ConditionalOnExpression 满足SpEL表达式指定 @ConditionalOnClass 系统中有指定的类 @ConditionalOnMissingClass 系统中没有指定的类 @ConditionalOnSingleCandidate 容器中只有一个指定的Bean，或者这个Bean是首选Bean @ConditionalOnProperty 系统中有指定的属性是否有指定的值 @ConditionalOnResource 类路径下是否存在指定资源文件 @ConditionalOnWebApplication 当前是web环境 @ConditionalOnNotWebApplication 当前不是Web环境 @ConditionalOnJndi JNDI存在指定项 自动装配以WebMvc为例 当SpringBoot启动时，会扫描需要自动配置的类，然后加载其配置类，使用全局配置文件覆盖需要替换的配置。 自动配置类：xxxAutoConfiguration 对应的配置类：xxxProperties SpringBoot为多个类提供了自动配置类，名为xxxAutoConfiguration，比如：WebMvcAutoConfiguration； 自动配置类中的注解。 1234567@AutoConfiguration(after = &#123; DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class, ValidationAutoConfiguration.class &#125;)//@AutoConfiguration表示这是一个自动配置类，这个注解的下面还有@Configuration注解表示这是一个Spring配置类。@ConditionalOnWebApplication(type = Type.SERVLET)//Conditional注解用于表示注解是否需要加载，这里表示如果项目为WebApplication。@ConditionalOnClass(&#123; Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class &#125;)//若存在以上几个类@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)//容器中不存在指定Bean@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)public class WebMvcAutoConfiguration &#123;...&#125; 自动配置类中Conditional注解判断自动配置类是否需要加载。 1@EnableConfigurationProperties(&#123; WebMvcProperties.class, WebProperties.class &#125;) 其中@EnableConfigurationProperties注解指向需要使用的配置类。这里是：WebMVCProperties和WebProperties。 xxxProperties类中配置了自动配置类的默认值，并调用@ConfigurationProperties允许在全局配置文件中修改默认值。 123456789101112131415161718192021222324252627//WebMvcProperties类@ConfigurationProperties(prefix = &quot;spring.mvc&quot;)//可以在配置文件中使用spring.mvc前缀修改其中的值public class WebMvcProperties &#123; /** * Formatting strategy for message codes. For instance, &#x27;PREFIX_ERROR_CODE&#x27;. */ private DefaultMessageCodesResolver.Format messageCodesResolverFormat; private final Format format = new Format();//下面测试这个对象的值...&#125;//Format类public static class Format &#123; /** * Date format to use, for example &#x27;dd/MM/yyyy&#x27;. */ private String date; /** * Time format to use, for example &#x27;HH:mm:ss&#x27;. */ private String time;...&#125; 比如像这样： 12345spring: mvc: format: date: time: SpringBoot的调试在配置文件中添加debug&#x3D;true打开调试模式。 12# 可以通过debug查看哪些自动配置类生效，哪些没有生效debug: true 调试输出内容示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859============================CONDITIONS EVALUATION REPORT============================Positive matches: //匹配并加载的类-----------------// 这里省略很多 WebMvcAutoConfiguration matched: - @ConditionalOnClass found required classes &#x27;javax.servlet.Servlet&#x27;, &#x27;org.springframework.web.servlet.DispatcherServlet&#x27;, &#x27;org.springframework.web.servlet.config.annotation.WebMvcConfigurer&#x27; (OnClassCondition) - found &#x27;session&#x27; scope (OnWebApplicationCondition) - @ConditionalOnMissingBean (types: org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport; SearchStrategy: all) did not find any beans (OnBeanCondition) WebMvcAutoConfiguration#formContentFilter matched: - @ConditionalOnProperty (spring.mvc.formcontent.filter.enabled) matched (OnPropertyCondition) - @ConditionalOnMissingBean (types: org.springframework.web.filter.FormContentFilter; SearchStrategy: all) did not find any beans (OnBeanCondition) WebMvcAutoConfiguration.EnableWebMvcConfiguration#flashMapManager matched: - @ConditionalOnMissingBean (names: flashMapManager; SearchStrategy: all) did not find any beans (OnBeanCondition)// 这里省略很多Negative matches: //不匹配不加载的类-----------------// 这里省略很多 WebSessionIdResolverAutoConfiguration: Did not match: - @ConditionalOnClass did not find required class &#x27;reactor.core.publisher.Mono&#x27; (OnClassCondition) WebSocketMessagingAutoConfiguration: Did not match: - @ConditionalOnClass did not find required class &#x27;org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurer&#x27; (OnClassCondition) WebSocketReactiveAutoConfiguration: Did not match: - @ConditionalOnWebApplication did not find reactive web application classes (OnWebApplicationCondition)// 这里省略很多Exclusions: //排除的类----------- NoneUnconditional classes: //不满足条件的类---------------------- org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration org.springframework.boot.autoconfigure.context.LifecycleAutoConfiguration org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration org.springframework.boot.autoconfigure.availability.ApplicationAvailabilityAutoConfiguration org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration SpringBoot Web开发 资源路径静态资源静态资源放在哪里静态资源可以放在以下几个目录： 自定义的优先级最高 classpath:&#x2F;META-INF&#x2F;resources&#x2F; classpath:&#x2F;resources&#x2F; classpath:&#x2F;static&#x2F; （默认） classpath:&#x2F;public&#x2F; 在templates下的页面只能通过controller来跳转。 这几个目录会直接引用到页面的根目录。优先级依据上面的顺序执行。 （很少使用webjars）&#x2F;webjars&#x2F;**指向由webjars依赖引入的静态文件，如：http://127.0.0.1:8080/webjars/jquery/3.4.1/jquery.js 自定义静态资源位置123456789spring: mvc: static-path-pattern: /res/** # 映射路径，静态资源url访问时使用的路径 web: resources: static-locations: [ classpath:/yn/] # 静态资源放哪里 静态资源访问url：使用spring.mvc.static-path-pattern来配置，如：&#x2F;res&#x2F;**，访问时使用http://127.0.0.1:8080/res/1.js 静态资源放在哪里：使用spring.web.resources.static-locations来配置，这里要写数组。如：[ classpath:&#x2F;yn&#x2F;]，资源要放在以下位置。 源码解释1234567891011121314public void addResourceHandlers(ResourceHandlerRegistry registry) &#123; if (!this.resourceProperties.isAddMappings()) &#123; logger.debug(&quot;Default resource handling disabled&quot;); return; &#125; addResourceHandler(registry, &quot;/webjars/**&quot;, &quot;classpath:/META-INF/resources/webjars/&quot;);//webjars 通过依赖添加jquery addResourceHandler(registry, this.mvcProperties.getStaticPathPattern(), (registration) -&gt; &#123; registration.addResourceLocations(this.resourceProperties.getStaticLocations()); if (this.servletContext != null) &#123; ServletContextResource resource = new ServletContextResource(this.servletContext, SERVLET_LOCATION); registration.addResourceLocations(resource); &#125; &#125;);&#125; webjars很少使用webjars 使用依赖可以加入一些js文件。 1addResourceHandler(registry, &quot;/webjars/**&quot;, &quot;classpath:/META-INF/resources/webjars/&quot;); 代码里指向的就是webjars依赖的位置。这里添加的是jquery.js。 首页配置默认位于资源目录下的index.html。 可以使用controller自定义。 源码解释1234567891011private Resource getIndexHtml(Resource location) &#123; try &#123; Resource resource = location.createRelative(&quot;index.html&quot;); if (resource.exists() &amp;&amp; (resource.getURL() != null)) &#123; return resource; &#125; &#125; catch (Exception ex) &#123; &#125; return null;&#125; 通过这个方法得知，项目的首页默认指向为static下的index.html。 图标配置放在静态资源目录下就可。默认：&#x2F;favicon.ico thymeleaf模板引擎thymeleaf是Java模板引擎之一。 依赖SpringBoot里使用依赖spring-boot-starter-thymeleaf。 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; thymeleaf官方的依赖使用 Module Group ID Artifact ID Core library org.thymeleaf thymeleaf Spring 3 integration org.thymeleaf thymeleaf-spring3 Spring 4 integration org.thymeleaf thymeleaf-spring4 Spring 5 integration org.thymeleaf thymeleaf-spring5 Testing library org.thymeleaf thymeleaf-testing Spring Security 3 integration org.thymeleaf.extras thymeleaf-extras-springsecurity3 Spring Security 4 integration org.thymeleaf.extras thymeleaf-extras-springsecurity4 Java 8 Time API compatibility org.thymeleaf.extras thymeleaf-extras-java8time Tiles 2 integration org.thymeleaf.extras thymeleaf-extras-tiles2 IE Conditional Comments support org.thymeleaf.extras thymeleaf-extras-conditionalcomments 使用第一个程序 在templates创建html文件； 在controller中返回字符串为html文件的文件名，不包含后缀。 123456789@Controllerpublic class IndexController &#123; @RequestMapping(&quot;/test&quot;) public String index()&#123; return &quot;test&quot;; &#125;&#125; 测试运行 html中使用 需要头&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt; 在页面中使用表达式。表达式格式为th:abc=&quot;xxx&quot;，abc表示内容类型，xxx表示内容。 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;一个Templates页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;一个Templates页面&lt;!--所有的html元素可以被thymeleaf替换接管： th:元素名--&gt;&lt;div th:text=&quot;$&#123;msg&#125;&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; text为内容，${msg}为引入的值。 在Controller中设置msg的值。 12345@RequestMapping(&quot;/test&quot;)public String index(Model model)&#123; model.addAttribute(&quot;msg&quot;,&quot;这是一个msg。&quot;); return &quot;test&quot;;&#125; 测试运行 作用 可以使用表达式在页面中显示内容。 源码12345678910@ConfigurationProperties(prefix = &quot;spring.thymeleaf&quot;)public class ThymeleafProperties &#123; private static final Charset DEFAULT_ENCODING = StandardCharsets.UTF_8; public static final String DEFAULT_PREFIX = &quot;classpath:/templates/&quot;; public static final String DEFAULT_SUFFIX = &quot;.html&quot;;...&#125; 得知： 在配置中使用spring.thymeleaf前缀； 默认模板前缀：classpath:&#x2F;templates&#x2F; 默认模板后缀：.html thymeleaf模板引擎语法官方文档：https://www.thymeleaf.org/doc/tutorials/3.0/ Springboot中的一些配置12# 关闭模板引擎的缓存spring.thymeleaf.cache=false 一些表达式 Simple expressions: Variable Expressions: $&#123;...&#125; &#x2F;&#x2F;普通变量 Selection Variable Expressions: *&#123;...&#125; Message Expressions: #&#123;...&#125; &#x2F;&#x2F;国际化消息表达式 Link URL Expressions: @&#123;...&#125; &#x2F;&#x2F;表示URL Fragment Expressions: ~&#123;...&#125; &#x2F;&#x2F;片段表达式，可以提取网页片段作为一个模块，然后在另一个网页插入。 Literals Text literals: &#39;one text&#39;, &#39;Another one!&#39;,… &#x2F;&#x2F;文本使用单引号，不能使用双引导 Number literals: 0, 34, 3.0, 12.3,… &#x2F;&#x2F;数字直接写 Boolean literals: true, false &#x2F;&#x2F;布尔值直接写 Null literal: null &#x2F;&#x2F;null直接写 Literal tokens: one, sometext, main,… &#x2F;&#x2F;字符串文本，如果内容没有一些影响语法的符号（空格，符号），就可以直接写。 比如&lt;div th:class=&quot;&#39;content&#39;&quot;&gt;...&lt;/div&gt;可以用&lt;div th:class=&quot;content&quot;&gt;...&lt;/div&gt;表达。 Text operations: String concatenation: + &#x2F;&#x2F;文本操作 Literal substitutions: |The name is $&#123;name&#125;| Arithmetic operations: Binary operators: +, -, *, /, % Minus sign (unary operator): - Boolean operations: Binary operators: and, or &#x2F;&#x2F;与 或 Boolean negation (unary operator): !, not &#x2F;&#x2F;非 Comparisons and equality: Comparators: &gt;, &lt;, &gt;=, &lt;= (gt, lt, ge, le) Equality operators: ==, != (eq, ne) Conditional operators: &#x2F;&#x2F;条件运算符 If-then: (if) ? (then) If-then-else: (if) ? (then) : (else) &#x2F;&#x2F;用这个代替前端的if-else Default: (value) ?: (defaultvalue) Special tokens: No-Operation: _ 一些属性这是一些thymeleaf的属性，优先级从上到下依次降低。 Order Feature Attributes 功能 1 Fragment inclusion th:insert th:replace 包含，类似include 2 Fragment iteration th:each 循环 3 Conditional evaluation th:if th:unless th:switch th:case 判断 4 Local variable definition th:object th:with 5 General attribute modification th:attr th:attrprepend th:attrappend 6 Specific attribute modification th:value th:href th:src ... 属性 7 Text (tag body modification) th:text th:utext th:text 不转义字符th:utext转义字符 8 Fragment specification th:fragment 提取公共页面 9 Fragment removal th:remove 运算符的使用1&lt;button th:href=&quot;@&#123;/emp/delete/&#125;+$&#123;emp.getId()&#125;&quot;&gt;删除&lt;/button&gt; 一些方法的使用dates.format可以格式化Date对象的格式。 使用 1&lt;td th:text=&quot;$&#123;#dates.format(emp.getBirth(),&#x27;yyyy-MM-dd HH:mm:ss&#x27;)&#125;&quot;&gt;1,001&lt;/td&gt; 用”#”修饰，然后参数输入Date对象和格式’yyyy-MM-dd HH:mm:ss’。 一些属性的使用th:text，th:utextth:text下的字符不会进行html转义，th:utext下的字符会进行html转义。 th:text有另一种写法（这个写法一般不用）： 1&lt;div&gt;[[ $&#123;msg&#125; ]]&lt;/div&gt;&lt;!-- 这个写法一般不用 --&gt; 代码 123&lt;div th:text=&quot;$&#123;msg&#125;&quot;&gt;&lt;/div&gt;&lt;div&gt;[[ $&#123;msg&#125; ]]&lt;/div&gt;&lt;!-- 这个写法一般不用 --&gt;&lt;div th:utext=&quot;$&#123;msg&#125;&quot;&gt;&lt;/div&gt; 12345@RequestMapping(&quot;/test&quot;)public String index(Model model)&#123; model.addAttribute(&quot;msg&quot;,&quot;&lt;h1&gt;这是一个msg。&lt;/h1&gt;&quot;); return &quot;test&quot;;&#125; 运行 th:each可以用来遍历一个数组，使用方法： 在属性中添加th:each=&quot;user:&#123;$users&#125;&quot;； 1&lt;h3 th:each=&quot;user:$&#123;users&#125;&quot;&gt;&lt;/h3&gt; 遍历users，类似for(User user : users){} 通过另一个属性值使用这个值th:text=&quot;$&#123;user&#125;&quot;。 1&lt;h3 th:each=&quot;user:$&#123;users&#125;&quot; th:text=&quot;$&#123;user&#125;&quot;&gt;&lt;/h3&gt; 会出现多个元素，分别对应遍历的一个效果，表现如下： 123&lt;h3&gt;张三&lt;/h3&gt;&lt;h3&gt;李四&lt;/h3&gt;&lt;h3&gt;王五&lt;/h3&gt; 代码 Controller中 12345678@Controllerpublic class thyleaf_for_each &#123; @RequestMapping(&quot;/test2&quot;) public String test2(Model model)&#123; model.addAttribute(&quot;users&quot;, Arrays.asList(&quot;zhangsan&quot;,&quot;lisi&quot;,&quot;wangwu&quot;)); return &quot;test2&quot;; &#125;&#125; html中 1&lt;h3 th:each=&quot;user:$&#123;users&#125;&quot; th:text=&quot;$&#123;user&#125;&quot;&gt;&lt;/h3&gt; 运行结果 th:href 和 @{&#x2F;js&#x2F;jquery.js} th:href修改html元素中的href属性值 可以根据server.servlet.context-path的配置自动在链接前添加内容。 @{&#x2F;js&#x2F;jquery.js}一般用在表示链接 如果链接是根目录(&#x2F;qwe.js)12&lt;link th:href=&quot;@&#123;/css/bootstrap.min.css&#125;&quot; rel=&quot;stylesheet&quot;&gt;&lt;link th:href=&quot;@&#123;/css/signin.css&#125;&quot; rel=&quot;stylesheet&quot;&gt; 在springBoot配置中添加servlet目录 1server.servlet.context-path=/yn 在HTML中的表现 12&lt;link href=&quot;/yn/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;link href=&quot;/yn/css/signin.css&quot; rel=&quot;stylesheet&quot;&gt; 如果链接是相对目录(qwe.js)12&lt;link th:href=&quot;@&#123;css/bootstrap.min.css&#125;&quot; rel=&quot;stylesheet&quot;&gt;&lt;link th:href=&quot;@&#123;css/signin.css&#125;&quot; rel=&quot;stylesheet&quot;&gt; 表现效果： 12&lt;link href=&quot;css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;link href=&quot;css/signin.css&quot; rel=&quot;stylesheet&quot;&gt; 若设置server.servlet.context-path后，这个表现效果不会改变。 th:fragment，th:insert，th:replace分别代表：声明当前区域 插入 替换 th:fragmentth:fragment放在html元素属性中，用于为当前元素声明一个名字。 12&lt;!-- common.html --&gt;&lt;nav th:fragment=&quot;header&quot;&gt;asd&lt;/nav&gt; 声明时不需要~{…}表达式括住。 th:insertth:insert也放在元素属性中，会将指定的fragment插入到元素中。 12&lt;!-- qwe.html --&gt;&lt;div th:insert=&quot;~&#123;common::header&#125;&quot;&gt;&lt;/div&gt; 引用时需要使用~{…}表达式括住。内容为“模板名::元素声明的名字” 表现效果 123&lt;div&gt; &lt;nav&gt;asd&lt;/nav&gt;&lt;/div&gt; th:replaceth:replace将使用指定的fragment替代原来的元素。 12&lt;!-- asd.html --&gt;&lt;div th:replace=&quot;~&#123;common::header&#125;&quot;&gt;&lt;/div&gt; 表现效果 1&lt;nav&gt;asd&lt;/nav&gt;&lt;!-- 原本的div被替代了 --&gt; 传递参数在insert和replace后面，可以直接加括号传参。 格式：(参数名&#x3D;’值’) 使用： 对于th:fragment 12345&lt;!-- commons.html 公共页面 --&gt;&lt;div th:fragment=&quot;sidebar&quot;&gt;&lt;!-- 侧边栏 --&gt; &lt;a th:class=&quot;$&#123;action==&#x27;index&#x27;?&#x27;active&#x27;:&#x27;inactive&#x27;&#125;&quot;&gt;主页&lt;/a&gt; &lt;a th:class=&quot;$&#123;action==&#x27;list&#x27;?&#x27;active&#x27;:&#x27;inactive&#x27;&#125;&quot;&gt;员工管理页面&lt;/a&gt;&lt;/div&gt; 对于th:replace 12345678&lt;!-- list.html 假定：员工管理页面 --&gt;&lt;div th:replace=&quot;~&#123;commons::sidebar(action=&#x27;list&#x27;)&#125;&quot;&gt;&lt;/div&gt;&lt;!-- 表现效果 --&gt;&lt;div&gt; &lt;a th:class=&quot;inactive&quot;&gt;主页&lt;/a&gt; &lt;a th:class=&quot;active&quot;&gt;员工管理页面&lt;/a&gt;&lt;/div&gt; 12345678&lt;!-- list.html 假定：主页 --&gt;&lt;div th:replace=&quot;~&#123;commons::sidebar(action=&#x27;index&#x27;)&#125;&quot;&gt;&lt;/div&gt;&lt;!-- 表现效果 --&gt;&lt;div&gt; &lt;a th:class=&quot;active&quot;&gt;主页&lt;/a&gt; &lt;a th:class=&quot;inactive&quot;&gt;员工管理页面&lt;/a&gt;&lt;/div&gt; 使用场景这个一般用于多个页面有公共部分时，可以将公共部分放在同一个页面中，然后在别的页面只需要引用就可以了。","categories":[],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://zswh33.github.io/tags/SpringBoot/"}]},{"title":"Day15 SpringBoot 2 配置文件 SPEL表达式 松散绑定 JSR303校验 yaml语法","slug":"Day15-SpringBoot-2","date":"2022-09-07T11:34:34.000Z","updated":"2022-09-08T10:03:26.730Z","comments":true,"path":"2022/09/07/Day15-SpringBoot-2/","link":"","permalink":"http://zswh33.github.io/2022/09/07/Day15-SpringBoot-2/","excerpt":"","text":"SpringBoot如何启动 入口 12345678//标注这个类是一个SpringBoot应用@SpringBootApplicationpublic class SpringBootForthProjectApplication &#123; public static void main(String[] args) &#123; //将SpringBoot应用启动 SpringApplication.run(SpringBootForthProjectApplication.class, args); &#125;&#125; SpringApplication.run(SpringBootForthProjectApplication.class, args); 推断应用的类型是普通的项目还是Web项目； 查找并加载所有可用初始化器，设置到initializers属性中； 找出所有的应用程序监听器，设置到listeners属性中； 推断并设置main方法的定义类，找到运行的主类； SpringBoot全局配置文件默认文件名两种方案： application.properties 语法结构：key&#x3D;value application.yml 语法结构：key:空格value 作用：修改SpringBoot自动配置的默认值。 文件位置可以在以下几个位置放置配置文件： file:.&#x2F;config&#x2F; 项目目录下config文件夹中 file:.&#x2F; 项目根目录下 classpath:&#x2F;config&#x2F; 资源目录的config目录下 classpath:&#x2F; 资源目录根目录下 优先级顺序也按照上面的顺序来。 不同环境下的配置文件有三种环境：默认、dev、test。（默认、开发、测试） 多文件方式 创建三个文件，其中没有后缀表示默认，dev表示开发，test表示测试； 在application.yaml添加spring.profiles&#x3D;指定使用的配置环境， 123spring: profiles: active: dev 示例中表示使用dev环境。 配置的环境名可以自定义 单文件方式 在application.yaml中添加以下内容 12345678910111213141516171819202122server: port: 8081spring: profiles: active: dev---server: port: 8082spring: config: activate: on-profile: dev---server: port: 8083spring: config: activate: on-profile: test 使用”—“分隔开三种配置。在示例中，第一部分为默认的配置，spring.profiles.active指定现在使用的配置。第二部分为dev配置，第三部分为test配置。 在默认配置中使用spring.profiles.active指定要使用的配置环境 spring.config.activate.on-profile声明当前位置的配置名 使用即可。 yaml语法12345678910111213141516171819# 普通的key-valuename: 张三# 对象student: name: zhangsan age: 3# 行内对象student2: &#123;name: zhangsan ,age: 3&#125;#数组pets: - cat - dog# 行内数组pets2: [cat,dog,pig] Spring的@Autowired和@Value实现对象自动初始化 创建一个Dog类，放入无参构造方法、getter和setter，对类使用@Component注解。对需要赋值的变量使用@Value注解，值为要赋的值。 12345678910//将类加入Spring底层@Componentpublic class Dog &#123; @Value(&quot;张三&quot;) //自动装载的默认值 private String name; @Value(&quot;12&quot;) //这里只能写字符串，整数也要用引号括住 private Integer age; //toString方法、getter方法、setter方法、无参构造方法、有参构造方法这里省略&#125; 在要使用的类中，创建一个引用，使用@Autowired注解，即可实现自动初始化； 1234567891011@SpringBootTestclass SpringBootForthProjectApplicationTests &#123; @Autowired private Dog dog; @Test void contextLoads() &#123; System.out.println(dog); &#125;&#125; 写一个测试类，测试结果。 1Dog&#123;name=&#x27;张三&#x27;, age=12&#125; 通过yaml实现对象自动初始化 在application.yaml中添加以下内容： 12345678910111213person: name: zhangsan age: 3 happy: false birth: 2022/9/9 maps: &#123;k1: v1,k2: v2&#125; lists: - code - girl - zhangsan dog: name: lisi age: 3 创建一个Person类，添加注解@ConfigurationProperties(prefix = &quot;person&quot;)，其中prefix前缀的值为application.yaml配置的对应的对象的名，也就是person。 123456789101112@Component@ConfigurationProperties(prefix = &quot;person&quot;)public class Person &#123; private String name; private Integer age; private Boolean happy; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog; //构造方法、setter、getter、toString方法&#125; 运行测试 123456789@SpringBootTestclass SpringBootForthProjectApplicationTests &#123; @Autowired private Person person; @Test void contextLoads() &#123; System.out.println(person); &#125;&#125; 1Person&#123;name=&#x27;zhangsan&#x27;, age=3, happy=false, birth=Fri Sep 09 00:00:00 CST 2022, maps=&#123;k1=v1, k2=v2&#125;, lists=[code, girl, zhangsan], dog=Dog&#123;name=&#x27;lisi&#x27;, age=3&#125;&#125; 注意： @configurationProperties使用后会标红，解决办法： 在pom.xml中添加： 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 重启idea。 这个依赖的作用是：添加依赖后，可以用@ConfigurationProperties注释的项轻松生成自己的配置元数据文件，在编写application.yml文件可以有相关提示。 部分SPEL表达式${random.uuid} 随机 random.uuid：获得一个随机的UUID random.int：获得一个整数 示例1：${person.hello:Lisi}张三 在对象person中寻找hello，若有hello则用hello的值，没有则用“Lisi”代替，然后拼接“张三”。 代码示例 12345678910111213person: name: zhangsan$&#123;random.uuid&#125; age: $&#123;random.int&#125; happy: false birth: 2022/9/9 maps: &#123;k1: v1,k2: v2&#125; lists: - code - girl - zhangsan dog: name: $&#123;person.hello:张三&#125;_LiSi age: 3 运行结果： 12Person&#123;name=&#x27;zhangsand4c877dd-b714-468f-b6f9-c4a4b899a8d0&#x27;, age=-161320060, happy=false, birth=Fri Sep 09 00:00:00 CST 2022, maps=&#123;k1=v1, k2=v2&#125;, lists=[code, girl, zhangsan], dog=Dog&#123;name=&#x27;张三_LiSi&#x27;, age=3&#125;&#125; 松散绑定在使用yaml实现对象自动赋值过程中，yaml中对象名和实际对象名中，驼峰命名和带“-”的命名可以对应起来。如：firstName和first-name。（properties不支持） 示例 dog类： 1234567@Component@ConfigurationProperties(prefix = &quot;dog&quot;)public class Dog &#123; private String firstName; private Integer age;// Constructor,getter,setter,toString&#125; yaml中的dog： 123dog: first-name: Qwert age: 6 运行结果： 1Dog&#123;firstName=&#x27;Qwert&#x27;, age=6&#125; JSR303校验@Validated JSR303校验指，Spring提供注解可以直接校验变量的值。 在变量前添加指定注解，可以实现注解对应的功能。 依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;&lt;/dependency&gt; 使用 在类前添加@Validated注解； 在需要检查的对象前添加相应的校验注解。 包位于jakarta.validation下的javax.validation.constraint里。 代码示例 在yml文件中 1234student: id: 3 name: Obsidian email: uwupu@qwe.com 一个student类 12345678910@Component@ConfigurationProperties(prefix = &quot;student&quot;)@Validatedpublic class Student &#123; private int id; private String name; @Email(message=&quot;邮件格式错误&quot;) private String email;//Constructor、getter、setter、toString&#125; 运行测试 123456789@SpringBootTestclass SpringBootForthProjectApplicationTests &#123; @Autowired private Student student; @Test void contextLoads() &#123; System.out.println(student); &#125;&#125; 1Student&#123;id=3, name=&#x27;Obsidian&#x27;, email=&#x27;uwupu@qwe.com&#x27;&#125; 可以使用的注解空检查 注解名 介绍 @Null 验证对象是否为空。 @NotNull 验证对象不为空。不检查长度为0的字符串。 @NotBlank 验证约束字符串不是null，且字符串trim后长度大于0。（trim：去掉字符串前后空格） @NotEmpty 验证约束元素是否为空或null。 Boolean检查 注解名 介绍 @AssertTrue 验证Boolean对象是否为true @AssertFalse 验证Boolean对象是否为false 长度检查 注解名 介绍 @Size(min&#x3D;,max&#x3D;) 验证对象（Array、Collection、Map、String）长度是否在给定范围内 @Length(min&#x3D;,max&#x3D;) 验证被注解的字符串的长度是否在给定范围内 日期检查 注解名 介绍 @Past 验证Date和Calendar对象是否在当前时间之前 @Future 验证Date和Calendar对象是否在当前时间之后 字符串检查 注解名 介绍 @Pattern 验证String对象是否符合正则表达式的规则 其他使用properties配置文件 类前用@PropertySource注解 12345678910111213141516@Component@PropertySource(&quot;classpath:application.properties&quot;)public class Person_properties &#123; @Value(&quot;$&#123;person2.name&#125;&quot;) private String name; @Value(&quot;$&#123;person2.age&#125;&quot;) private Integer age; @Value(&quot;$&#123;person2.happy&#125;&quot;) private Boolean happy; @Value(&quot;$&#123;person2.birth&#125;&quot;) private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog;//Contsructor、getter、setter、toString&#125; 在application.yaml文件中 1234person2.name=zhangsanperson2.birth=2020/2/2person2.age=123person2.happy=false 运行测试 1234567891011@SpringBootTestclass SpringBootForthProjectApplicationTests &#123; @Autowired private Person_properties person; @Test void contextLoads() &#123; System.out.println(person); &#125;&#125; 1Person2&#123;name=&#x27;zhangsan&#x27;, age=123, happy=false, birth=Sun Feb 02 00:00:00 CST 2020, maps=null, lists=null, dog=null&#125; 修改的内容单文件方式配置SpringBoot多环境 旧版本中 使用spring.profiles声明当前使用的配置名。 新版本中 使用spring.config.activate.on-profile声明当前使用的配置名。","categories":[],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://zswh33.github.io/tags/SpringBoot/"}]},{"title":"Day15 SpringBoot 1","slug":"Day15-SpringBoot-1","date":"2022-09-07T02:45:37.000Z","updated":"2022-09-11T03:07:58.027Z","comments":true,"path":"2022/09/07/Day15-SpringBoot-1/","link":"","permalink":"http://zswh33.github.io/2022/09/07/Day15-SpringBoot-1/","excerpt":"","text":"引入微服务架构 应用架构单体应用架构（All in one）单体应用架构（All in one），将一个应用中的所有应用服务都封装在一个应用中。 优点： 易于开发和测试； 方便部署； 缺点： 如果要修改一个地方，就去要停掉整个服务，重新打包； 微服务架构打破all in one的架构方式，将每个功能元素独立出来，把独立出来的功能元素动态组合。 优点： 节省了调用资源； 每个功能元素的服务都是一个可替换的，可独立升级的软件代码。 微服务全套 构建一个个功能独立的微服务应用单元，可以使用springboot，可以帮我们快速构建一个应用 大型分布式网络服务的调用，使用SpringCloud实现分布式； 在分布式中间，进行流式数据计算、批处理，使用SpringCloud DataFlow实现； 第一个SpringBoot程序过程 到https://start.spring.io/生成一个项目 完成 使用 controller目录下创建Controller可以直接运行； Controller文件 123456789@RestControllerpublic class Controller &#123; // http://127.0.0.1:8080/hello @RequestMapping(&quot;/hello&quot;) public String hello()&#123; //调用业务，接收前端参数 return &quot;hello,World.&quot;; &#125;&#125; 运行 文件介绍目录：src&#x2F;java&#x2F;com.xx.xxcontroller：controller目录 dao：dao目录 pojo：pojo目录 service：service目录 FirstProjectApplication（这里名字自定义，按照生成的来）：程序入口 程序入口在SpringBoot项目创建时，自动生成的类即为程序的入口。 123456789//标注这个类是一个SpringBoot应用@SpringBootApplicationpublic class SpringBootForthProjectApplication &#123; public static void main(String[] args) &#123; //将SpringBoot应用启动 SpringApplication.run(SpringBootForthProjectApplication.class, args); &#125;&#125; resourcesstatic：静态资源文件 templates：模板文件。hole… pom.xml这是一个Maven的配置文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!-- 有一个父项目 --&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.7.3&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.yn&lt;/groupId&gt; &lt;artifactId&gt;FirstProject&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;FirstProject&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;!--spring-boot-starter所有的springboot依赖的--&gt; &lt;dependencies&gt; &lt;!-- Web依赖： tomcat：dispatcherServlet，xml --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 单元测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;!-- 打包插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; parent项目有一个父项目：spring-boot-starter-parent。继承spring-boot-starter-parent的依赖管理，控制版本和打包等内容； groupId、artifactId和version定位项目用； dependencies依赖： web依赖：spring-boot-starter-web。用于实现HTTP结构（这个依赖包含了Spring MVC）。 单元测试：spring-boot-starter-test。用于编写单元测试的依赖包。 打包插件：spring-boot-maven-plugin。配合spring-boot-starter-parent就可以把Spring Boot应用打包成JAR文件来直接运行。 SpringBoot在pom.xml的一些介绍 SpringBoot的一些依赖在父工程spring-boot-starter-parent中； 引入springboot依赖的时候，不需要指定版本，因为spring-boot有指定一些依赖的版本； pom.xml中的starter依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt; 是SpringBoot的启动场景； 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; SpringBoot将所有的功能场景，都包装成一个个启动器。（上面是springboot的web启动器）； 若要使用某些功能，只需要找到响应的启动器就可。 starter列表：https://docs.spring.io/spring-boot/docs/2.7.3/reference/html/using.html#using.build-systems.starters 文件标识 若文件右下角有标识，标识文件已被识别 打包 Maven下有个package打包选项。 12345678910[INFO] --- spring-boot-maven-plugin:2.7.3:repackage (repackage) @ FirstProject ---[INFO] Replacing main artifact with repackaged archive[INFO] ------------------------------------------------------------------------[INFO] BUILD SUCCESS[INFO] ------------------------------------------------------------------------[INFO] Total time: 10.930 s[INFO] Finished at: 2022-09-07T16:26:12+08:00[INFO] ------------------------------------------------------------------------Process finished with exit code 0 生成项目可以使用Java运行。 SpringBoot自动装配SpringBoot内置大量的自动配置类，可以在需要时自动导入需要的自动配置类。 声明自动配置类的配置文件SpringBoot在启动时，会从一种配置文件中读取可以用来装配的类，这种配置文件主要在两种目录中： 项目目录下的resources&#x2F;META-INF&#x2F;spring.factories； 另一个是org.springframework.boot.autoconfigure的jar包目录下的spring&#x2F;org.springframework.boot.autoconfigure.AutoConfiguration.imports文件里； 文件示例 12345//org.springframework.boot.autoconfigure.AutoConfiguration.imports文件org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfigurationorg.springframework.boot.autoconfigure.aop.AopAutoConfigurationorg.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration... 123//resources/META-INF/spring.factoriesorg.springframework.boot.autoconfigure.EnableAutoConfiguration=/com.yn.springbootproject.controller.HelloController 自动装配原理@SpringBootApplication注解表示这是一个SpringBoot应用。 被注解的类在启动时，SpringBoot会扫描所有需要的类，使用内置的自动配置类实现一些类的自动装配。 依据以下顺序在代码中顺藤摸瓜： @SpringBootApplication @EnableAutoConfiguration &#x2F;&#x2F;开启自动配置 @Import(AutoConfigurationImportSelector.class) &#x2F;&#x2F;导入了一个自动配置导入选择器 selectImports()&#x2F;&#x2F;选择导入 AutoConfigurationEntry getAutoConfigurationEntry()&#x2F;&#x2F;获得自动配置 getCandidateConfigurations()&#x2F;&#x2F;获取候选配置 loadFactoryNames()&#x2F;&#x2F;加载工厂名字 loadSpringFactories()&#x2F;&#x2F;加载spring工厂 &#96;&#96;&#96;javaresult &#x3D; new HashMap&lt;&gt;();try {Enumeration urls &#x3D; classLoader.getResources(FACTORIES_RESOURCE_LOCATION);&#x2F;&#x2F;获得FACTORIES_RESOURCE_LOCATION目录下的资源文件。while (urls.hasMoreElements()) {&#x2F;&#x2F;遍历资源文件 URL url &#x3D; urls.nextElement(); UrlResource resource &#x3D; new UrlResource(url); Properties properties &#x3D; PropertiesLoaderUtils.loadProperties(resource); for (Map.Entry entry : properties.entrySet()) {&#x2F;&#x2F;遍历其中的项 String factoryTypeName &#x3D; ((String) entry.getKey()).trim(); String[] factoryImplementationNames &#x3D; StringUtils.commaDelimitedListToStringArray((String) entry.getValue()); for (String factoryImplementationName : factoryImplementationNames) { result.computeIfAbsent(factoryTypeName, key -&gt; new ArrayList&lt;&gt;()) .add(factoryImplementationName.trim()); } }} 12345678910111213141516171819- hole...# application.properties一些简易的配置```properties#更改项目端口号server.port=8081# 自定义bannerspring.banner.location=classpath:banner.txt#修改访问时的路径server.servlet.context-path=/yn# 添加前：http://127.0.0.1:8080/# 添加后：http://127.0.0.1:8080/yn/# 修改 mvc页面请求-&gt;Date映射 时，页面请求传入的时候日期解析的方式spring.mvc.format.date=yyyy-MM-dd# 如 url: /?d=2022/2/22 是默认方式# 但大部分前端使用2022-2-22格式 通过这个配置可以修改日期解析的格式 在resources文件夹下添加banner.txt文件可以直接修改banner。 使用Idea创建SpringBoot项目 其他路","categories":[],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://zswh33.github.io/tags/SpringBoot/"}]},{"title":"Day15 红黑树","slug":"Day15-Red-Black-Tree","date":"2022-09-06T23:19:32.000Z","updated":"2022-11-10T01:40:38.977Z","comments":true,"path":"2022/09/07/Day15-Red-Black-Tree/","link":"","permalink":"http://zswh33.github.io/2022/09/07/Day15-Red-Black-Tree/","excerpt":"","text":"红黑树https://www.jianshu.com/p/4cd37000f4e3 https://www.bilibili.com/video/BV1Ce4y1Q76H 引入 有了二叉搜索树，为什么需要平衡二叉树？ 二叉搜索树容易变成链表，查找的时间复杂度就会从O(log2N)变为O(N)。 引入平衡二叉树，防止树退化。 有了平衡二叉树，为什么还需要红黑树 平衡二叉树插入删除操作影响效率 红黑树减少插入&#x2F;删除操作，整体性能优于AVL，也能保证时间复杂度为O(log2N)。 红黑树插入时的不平衡，不超过两次旋转可以解决 删除时的不平衡，不超过三次旋转可以解决。 介绍红黑树是一种接近平衡的二叉树。 特性&#x2F;要求 节点是红色或者黑色； 根是黑色； 叶子结点（外部节点，空节点）都是黑色，并且为空节点（概念上有空节点，实际无）； 红色节点的子节点和父节点都是黑色（即，不存在两个连续的红色节点）； 从任意节点到叶子结点的所有路径都包含相同数目的黑色节点 红黑树与二三四树红黑树与二三四树等价； 红黑树的黑色节点数 &#x3D; 234树的节点数 在234树中的红黑树，黑色节点必为父节点，红色节点必为子节点； （黑色中间，红色两边） 每一棵红黑树都有对应的唯一一棵二三四树； 但一个二三四树可能有多个红黑树与之对应。 高度路径长度不会超过2log(n+1)，即$$红黑树高度 \\leq 2log(n+1)$$ 效率红黑树的查找、插入和删除操作，时间复杂度都是O(logN)。 红黑树与AVL树比较 AVL树时间复杂度优于红黑树； 红黑树整体性能略优于AVL树。 hole… 插入操作情况插入结点的颜色 若插入的是根节点，则为黑色； 其他节点都为红色。 如果插入红色节点，出现两个连续的红色节点，只需要旋转和变色进行调整。 为什么？ 如果插入的颜色为黑色，则接下来的调整会非常麻烦； 如果插入的颜色为红色，则只有一种冲突的情况，只需要旋转和变色进行调整就可。 黑父无需做任何操作； 红父又分为两种情况：红叔、黑叔 红叔 若新节点的父节点和叔节点都是红色节点，将父节点和叔节点改为黑色，把祖节点改为红色，然后递归检查祖节点即可。 黑叔黑叔分为4种情况处理； 父节点是是祖节点的左儿子，新节点是父节点的左儿子 父节点是是祖节点的左儿子，新节点是父节点的右儿子 父节点是是祖节点的右儿子，新节点是父节点的左儿子 父节点是是祖节点的右儿子，新节点是父节点的右儿子 父左新左 右旋，然后变色，叶子节点为黑色，其他向上交错；然后向上递归变色； 父右新右 左旋，然后变色，叶子节点为黑色，其他向上交错；然后向上递归变色； 父左新右 在父节点左旋，然后在祖节点右旋，最后变色，以叶子节点为黑色为基准，向上递归变色； 父右新左 在父节点右旋，然后在祖节点左旋，最后变色，以叶节点为黑色为基准，向上递归变色； 删除操作分为两种情况：红色节点删除，黑色节点删除； 思想B树中的删除操作，对于非叶子节点的删除，都要转换为其前驱&#x2F;后继节点的删除。 这里要删除节点8，现将前驱节点与要删除的节点值进行交换（这里是和6交换）； 然后删除前驱节点即可。 红色节点删除可以直接删除，不做任何调整； 黑色节点删除麻烦。必须进行调整才能满足红黑树的性质；即：从任意节点到叶子节点的所有路径都包含相同的黑色节点。 黑色节点的三种形式 有2个红色子节点的黑色节点；（即：234树的4节点） 不做考虑，对这个节点的删除会转换为对其子节点的删除。 有1个红色子节点的黑色节点；（即：234树的3节点） 黑色叶子节点。（即：234树的2节点） 有1个红色子节点的黑色节点用唯一的红色子节点来替代被删除的节点，然后将替代的节点染为黑色。 &#x3D;&#x3D;步骤：替代，删除，将替代节点染黑&#x3D;&#x3D; 删除没有子节点的黑色叶子节点删除黑色叶子节点，会造成下溢的情况； 这里再分为三种情况： 删除节点为根节点； 此时整个红黑树只有这一个节点，可以直接删除。 删除节点的兄弟节点为黑色； 删除节点的兄弟节点为红色，这里要转变兄弟节点为黑色进行处理 删除节点的兄弟节点为黑色几种情况分为以下几种情况： 兄弟节点带有红色子节点（借用兄弟子节点修复） 兄弟节点带有左红色子节点 兄弟节点带有右红色子节点 兄弟节点带有两个红色子节点 兄弟节点没有红色子节点（父节点向下合并） 兄弟节点带有左红色子节点 兄弟节点带有右红色子节点 兄弟节点有两个红色子节点 兄弟节点没有红色子节点这里分两种情况： 父节点为红色节点 父节点为黑色节点 父节点为红色节点 作为B树，没有任何变化； 作为红黑树，需要进行一次变色； 父节点为黑色节点 兄弟节点染为红色，父节点染为黑色； 如果父节点本就是黑色，就把父节点当做已被删除的节点处理，向上递归处理； 例子，&#x3D;&#x3D;这里没能成功理解，后续回来&#x3D;&#x3D; 兄弟节点为红色这里要转变为黑色处理。 处理：父节点右旋，兄弟节点染为黑色，父节点染为红色，然后以兄弟节点为黑色进行修复；","categories":[],"tags":[{"name":"DataStructure","slug":"DataStructure","permalink":"http://zswh33.github.io/tags/DataStructure/"}]},{"title":"Day14 JVM 2 GC 垃圾回收机制","slug":"Day14-JVM-2","date":"2022-09-06T06:24:04.000Z","updated":"2022-09-06T08:40:36.140Z","comments":true,"path":"2022/09/06/Day14-JVM-2/","link":"","permalink":"http://zswh33.github.io/2022/09/06/Day14-JVM-2/","excerpt":"","text":"GC：垃圾回收机制GC作用区：Heap 和 方法区； JVM在进行GC时，大部分时候，回收的都是新生代。 类型 轻GC（GC），大部分时候清理新生代，偶尔幸存区 重GC（全局GC）， 如何判断哪些对象需要被回收Java 垃圾回收判断哪些对象需要被回收有两种方法：引用计数法和可达性分析算法。 可达性分析算法通过一系列称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。 GC RootsGC Roots，tracking GC的根集合，是一组必须活跃的引用。 可以作为GC Roots的对象包括下面几种： 在虚拟机栈中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等； 在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量； 在方法区中常量引用的对象，譬如字符串常量池里的引用； 本地方法栈中JNI（Native方法）引用的对象； Java虚拟机内部的引用，如基本数据类型对应的CLass对象，一些常驻的异常对象（比如NullPointException，OutOfMemoryError）等，还有系统类加载器； 所有被同步锁（synchronized关键字）持有的对象； 反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等； 根据用户所选用的垃圾收集器以及当前回收的内存区域不同，“临时性”地加入的其他对象。 Tracing GC 根本思路 给定一个集合的引用作为根出发，通过引用关系遍历对象图，能被遍历到的（可达到的）对象就判定为存活，其余对象（没有被遍历到的）就自然判定为死亡。 注意：tracing GC的本质是通过找出所有活对象来吧其余空间认定为“无用”，而不是找出所有死掉的对象并回收他们占用的空间。 GC Roots引用例子 在上图中，reference1、reference2、reference3都是GC Roots； 其中： reference1 -&gt; 对象实例1 reference2 -&gt; 对象实例2 reference3 -&gt; 对象实例4 -&gt; 对象实例6 可以得出对象实例1、2、4、6都具有GC Roots可达性、也就是存活对象，不会被GC回收的对象； 而对于3、5是GC Roots不可达对象，是需要被GC回收的对象。 不可达的对象处理 不可达的对象将暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程： 当对象变成GC Roots不可达时，GC会判断该对象是否有重写finalize方法，若没有，则直接回收，若有，进入第二步 若对象执行过finalize方法，则进行回收；若对象未执行过finalize方法，将其放入F-Queue队列，虚拟机会稍后建立一个低优先级线程Finalizer去执行该队列中对象的finalize方法，执行finalize方法结束后，GC会再次判断该对象是否科大，若不可达，则进行回收，若可达，则对象列为存活对象。 ![未被GC Roots引用的对象](Day14-JVM-2&#x2F;未被GC Roots引用的对象.svg) 这里的执行表示虚拟机会执行该方法，但不承诺等待它运行结束。 算法分类标记清除法，标记整理，复制算法，引用计数器。 引用计数法 复制算法复制 + 清除垃圾 复制算法主要体现在新生区的幸存区。 过程 为表明算法过程，先将幸存区分成两个区：A区和B区 新生对象会被分配到A区的未使用内存中，当A区内存满了，就把A区存活对象复制到B区； 然后清理A区所有对象； 新生对象会被分配到B区未使用的内存中，当B区满了，就把B区存活对象复制到A区； 清理B区所有对象； 按照上面的过程循环 在Java里，一般将空的内存称为to区，当前正在使用的内存称为from区。（第二步结束时候，A为to区，B为from区；在第4步结束时候，B成为to区，A为from区） 特点 好处：没有内存碎片 坏处：浪费了内存空间（to永远为空） 复制算法最佳使用场景：对象存活度较低的时候。 标记清除算法每经历一次GC，会进行可达性分析，标记GC Roots可达的对象，清理没有被标记的对象。 特点 优点：不需要额外的空间。 缺点：两次扫描，严重浪费时间，会产生内存碎片。 标记压缩算法标记清除算法的优化版本，每经历几次GC，会进行一次扫描，然后将对象移动到内存的一端，防止内存碎片产生。 GC总结内存效率最高（时间复杂度）：复制算法 &gt; 标记清除算法 &gt; 标记压缩算法 内存整齐度：复制算法 &gt; 标记压缩算法 &#x3D; 标记清除算法 内存利用率：标记压缩算法 &#x3D; 标记清除算法 &gt; 复制算法 没有最好的算法，只有最合适的算法。 GC：分代收集算法 结论 年轻代：存活率低 —&gt;复制算法 老年代：区域大，存活率高 —&gt; 标记清除（内存碎片不是太多） + 标记压缩 混合实现 书籍 《深入理解JVM》 其他从文章中删除的内容 对象的标记 对象由两种状态，涉及到两类状态空间： 一个是终结动态空间F &#x3D; {unfinalized，finalizable，finalized} 一个是可达状态空间R &#x3D; {reachable，finalizer-reachable，unreachable}。 各状态含义如下： unfinalized：GC未准备执行其finalize方法，新建对象会先进入此状态； finalizable：表示可以执行finalizable方法，GC已检测到对象不可达； finalized：表示GC已对对象执行过finalize方法； reachable：表示GC Roots引用可达； finalizer-reachable（f-reachable）：表示不是reachable，但通过某个finalizable对象可达； unreachable：对象不可通过上面两种途经可达； 执行过程： 新建对象首先处于{reachable，unfinalized}状态； 若引用关系消失，从reachable变为f-reachable或unreachable状态； 若JVM….Delete","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://zswh33.github.io/tags/Java/"}]},{"title":"Day12 JVM 1 JVM体系结构 类加载器 沙箱安全机制 Native 栈 堆 JProfiler","slug":"Day12-JVM-1","date":"2022-09-04T06:59:59.000Z","updated":"2022-09-06T08:40:22.475Z","comments":true,"path":"2022/09/04/Day12-JVM-1/","link":"","permalink":"http://zswh33.github.io/2022/09/04/Day12-JVM-1/","excerpt":"","text":"JVM体系结构 JVM完整架构图 JVM简图 Java程序执行过程：java文件编编译 —&gt; class字节码文件 —&gt; 类加载器 —&gt; 运行时数据区； 其中： Java栈、本地方法栈和程序计数器不能进行垃圾回收； JVM调优一般指的是调优方法区和堆 类加载器 分类 虚拟机自带的加载器 启动类（根）加载器 扩展类加载器 应用程序加载器 用户自定义类加载器 类加载器加载的文件 Bootstrap ClassLoader (启动类加载器) ：主要负责加载Java核心类库，目录：&#x2F;lib下的rt.jar、resources.jar、charsets.jar和class等； Extention ClassLoader(扩展类加载器)：主要负责加载目录&#x2F;jre&#x2F;lib&#x2F;ext目录下的jar包文件和class文件； Appliation ClassLoader（应用程序类加载器）：主要负责加载当前应用的classpath下的所有类； User ClassLoader（用户自定义类加载器）：科技在指定路径的class文件。 自定义一个类，查看其加载器123456789101112public class Student &#123; @Override public String toString() &#123; return &quot;Student&#123;&#125;&quot;; &#125; public static void main(String[] args) &#123; Student student = new Student(); System.out.println(student.getClass().getClassLoader()); System.out.println(student); &#125;&#125; 1234sun.misc.Launcher$AppClassLoader@18b4aac2Student&#123;&#125;Process finished with exit code 0 自定义类的类加载器为AppClassLoader应用程序类加载器。 通过getParent()，探索类加载器1234567891011121314151617181920212223242526272829303132public class ClassLoader学习 &#123; public static void main(String[] args) &#123; Dog dog1 = new Dog(); Dog dog2 = new Dog(); System.out.println(dog1.hashCode()); System.out.println(dog2.hashCode()); /** * 460141958 * 1163157884 * 表明 dog1和dog2不是同一个对象 */ Class&lt;? extends Dog&gt; aClass = dog1.getClass(); Class&lt;? extends Dog&gt; aClass2 = dog2.getClass(); System.out.println(aClass.hashCode()); System.out.println(aClass2.hashCode()); /** * 1956725890 * 1956725890 * 表明aClass和aClass2是同一个对象 */ ClassLoader classLoader = dog1.getClass().getClassLoader(); System.out.println(classLoader);//AppClassLoader 应用程序类加载器 java.lang.ClassLoader System.out.println(classLoader.getParent());//ExtClassLoader 扩展类加载器 \\jre\\lib\\ext System.out.println(classLoader.getParent().getParent());//null rt.jar //null 1. 不存在 2. java程序获取不到 &#125;&#125; 双亲委派机制 介绍 当一个类加载器收到了类加载的请求，它不会直接去加载指定的类， 而是把这个请求委托给自己的父加载器去加载。只有父加载器无法加载这个类的时候，才会由当前这个加载器来负责类的加载。如果都不能加载，就会触发findclass，抛出异常classNotFoundException。 类加载器收到类加载请求； 将请求委托给父类加载器去完成； 启动加载器检查是否能够加载当前这个类，能加载则加载，使用当前的加载器；若不能，则通知子加载器去加载这个类； 若都不能加载，则抛出异常classNotFoundException。 存在的意义 通过委派的方式，可以避免类的重复加载，当父加载器已经加载过某个类时，子加载器就不会再重新加载这个类； 通过双亲委派的方式，保证了安全性。Bootstrap ClassLoader在加载的时候，只会加载JAVA_HOME中jar包里面的类,如java.lang.Integer，那么这个类是不会被随意替换的，除非有人故意破坏JDK。就可以避免有自人定义一个有破坏功能的java.lang.Integer类被加载。这样可以有效方式核心Java API被篡改。 尝试定义一个String类，并运行使用。 123456789101112131415161718192021222324public class String &#123; /** * 错误: 在类 java.lang.String 中找不到 main 方法, 请将 main 方法定义为: * public static void main(String[] args) * 否则 JavaFX 应用程序类必须扩展javafx.application.Application */ /** * 当一个类加载器收到了类加载的请求，它不会直接去加载指定的类， 而是把这个请求委托给自己的父加载器去加载。 * 只有父加载器无法加载这个类的时候，才会由当前这个加载器来负责类的加载。 */ //双亲委派机制 安全 //1. Application -&gt; Extention -&gt; Bootstrap //执行过程中，依据上面的顺序依次寻找String的类，优先执行BOOT，然后Exc，最后App。 //由于String在BOOT中找到String的类，所以运行BOOT中的String类； //而BOOT中的String类没有main方法，所以出现错误。 public String get()&#123; return &quot;Hello World&quot;; &#125; public static void main(String[] args) &#123; String s = new String(); s.get(); &#125;&#125; 123456错误: 在类 java.lang.String 中找不到 main 方法, 请将 main 方法定义为: public static void main(String[] args)否则 JavaFX 应用程序类必须扩展javafx.application.ApplicationProcess finished with exit code 1 Application -&gt; Extention -&gt; Bootstrap 执行过程中，依据上面的顺序依次寻找String的类，优先执行Bootstrap，然后Extention，最后Application。由于String在BOOT中找到String的类，所以运行BOOT中的String类；而BOOT中的String类没有main方法，所以出现错误。 沙箱安全机制Java安全模型的核心是Java沙箱（sandbox）。 介绍 沙箱是一个限制程序运行的环境，沙箱机制就是将Java代码限定在虚拟机（JVM）特定的运行范围中，并且严格限制代码对本地系统资源的访问，通过这样的错误来保证代码的有效隔离，防止对本地系统造成破坏。 Java沙箱主要限制系统资源访问。 历史 在Java中，执行程序分为本地代码和远程代码两种。 本地代码默认视为可信任的，而远程代码被看做是不受信任的。 对于受信任的本地代码，可以访问一切本地资源； 对于非授信的远程代码在早期的Java实现中，安全依赖于沙箱（SandBox机制）。 Java1.0 安全模型 Java 1.1 安全模型 Java1.6安全模型 （目前最新的安全模型） 在当前最新的安全机制实现，引入了域（Domain）的概念，虚拟机会把所有代码加载到不同的系统域和应用域； 系统域部分专门负责与关键资源进行交互，各个应用域部分则通过系统域的部分代理来对各种需要的资源进行访问。 虚拟机中不同的受保护域（Protected Domain），对应不一样的权限（Permission）。存在于不同域中的类文件就具有了当前域的全部权限。 组成沙箱的基本组件 字节码校验器（bytecode verifier）：确保java类文件遵循java语言规范。但并不是所有的类文件都会经过字节码校验，比如核心类。 类装载器（class loader）： 防止恶意代码去干涉正常的代码 &#x2F;&#x2F;双亲委派机制 守护了被信任的类库边界；&#x2F;&#x2F;双亲委派机制 代码归入保护域，确定了代码可以进行哪些操作。 &#x2F;&#x2F;沙箱安全机制 类加载器采用双亲委派模式 通过包区分了访问域，外层恶意的类通过内置代码无法获得权限访问到内置类，破坏代码因此无法生效。 存取控制器（access controller）：存取控制器可以控制核心API对操作系统的存取权限，而这个控制的策略设定，可以由用户指定。 **安全管理器(security manager)**：是核心API和操作系统之间的主要接口，实现权限控制，比存取控制器优先级高。 安全软件包（security package）：java.scurity下的类和扩展包下的类，允许用户为自己的应用增加新的安全特性，包括： 安全提供者 消息摘要 数字签名 加密 鉴别 Native、方法区 Thread.start()简述 123456789101112131415161718192021222324252627282930313233public synchronized void start() &#123; /** * This method is not invoked for the main method thread or &quot;system&quot; * group threads created/set up by the VM. Any new functionality added * to this method in the future may have to also be added to the VM. * * A zero status value corresponds to state &quot;NEW&quot;. */ if (threadStatus != 0)//线程的状态不是启动状态 throw new IllegalThreadStateException(); /* Notify the group that this thread is about to be started * so that it can be added to the group&#x27;s list of threads * and the group&#x27;s unstarted count can be decremented. */ group.add(this);//将线程加入线程组 boolean started = false;//默认线程未启动 try &#123; start0();//启动线程 started = true;//若启动成功，表示没有抛出异常，标志位设true。 &#125; finally &#123; try &#123; if (!started) &#123; group.threadStartFailed(this);//向group表示线程执行失败 &#125; &#125; catch (Throwable ignore) &#123; /* do nothing. If start0 threw a Throwable then it will be passed up the call stack */ &#125; &#125;&#125;private native void start0();//启动线程，是一个本地方法 NativeJava里用native修饰的方法，不在java作用范围内，调用的是底层c语言的库。 使用native修饰的方法，会进入本地方法栈，调用JNI（本地方法接口），JNI调用本地方法库。 JNI本地方法接口：，扩展Java的使用，融合不同的编程语言为Java所用。（最初是C、C++） Native Method Stack本地方法栈：登记Native方法。 PC寄存器程序计数器：Program Counter Register 每个线程都有一个程序计数器，是线程私有的，就是一个指针，指向方法区中的方法字节码（用来存储指向一条指令的地址，也是将要执行的指令代码）。 当执行引擎读取下一条指令，PC计数器会+1。 PC寄存器是一个非常小的内存空间。（小到可以忽略不计） 方法区Method Area 方法区被所有线程共享。 所有定义的方法的信息都保存在该区域。 属于共享区间。 内容 静态变量，常量，类信息（构造方法、接口定义），运行时常量池都在方法区中； static , final , Class ，常量池。 实例变量存在于堆内存中，与方法区无关。 JVM中内存分析 12345678910111213141516public class JVM内存分配部分 &#123; public static void main(String[] args) &#123; Person person = new Person(12,&quot;张三&quot;); &#125;&#125;class Person&#123; int age; String name = &quot;anonymous&quot;; public Person(int age, String name) &#123; this.age = age; this.name = name; &#125;&#125; 栈持续学习：程序 &#x3D; 数据结构 + 算法 饭碗：程序 &#x3D; 框架 + 业务逻辑 栈：先进后出，后进先出。 队列：先进先出。(FIFO：First Input First Output) 通过main方法理解栈12345678910public class UnderstandStackByMainMethod &#123; public static void main(String[] args) &#123; System.out.println(&quot;main start&quot;); hello(); System.out.println(&quot;main stop&quot;); &#125; public static void hello()&#123; System.out.println(&quot;hello&quot;); &#125;&#125; 12345main starthellomain stopProcess finished with exit code 0 程序运行：main方法开始，然后其他方法，最后main方法结束。 在栈中，main先进入栈，然后是hello()入栈，然后hello()出栈，最后main出栈。 JVM栈栈：主管程序的运行，生命周期和线程同步（线程结束 —&gt; 栈内存释放）。因此，对于栈来说，不存在垃圾回收问题。 介绍 JVM栈描述的是每个线程Java方法执行的内存模型：每个方法被执行的时候，JVM会同步创建一个栈帧用于存储局部变量表，操作数栈，动态链接，方法出口等信息。 栈是运行时单位，堆是存储的单位，即： 栈解决的是运行问题，即程序如何执行，或者如何处理数据。 堆解决的事数据存储问题，即数据怎么放，放哪儿。 特点 访问速度快，仅次于程序计数器 线程私有 存在OOM，不存在GC 存放类型 8种数据类型、对象的引用，实例的方法。 其他 Java虚拟机栈是线程私有的，生命周期与线程相同。（随线程而生，随线程而灭。） 如果线程请求的栈深度大于虚拟机所允许的深度，就会抛出StackOverflowError异常； 若虚拟机栈可以动态扩展，如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。 （当前大部分JVM都可以动态扩展，只不过JVM规范也允许固定长度的虚拟机栈） Java虚拟机栈描述的是Java方法执行的内存模型。 堆Heap，一个JVM只有一个堆内存，堆内存的大小可以调节。 堆里面放什么类，方法，常量，变量，保存引用类型的指向类型（真实对象）。 分三个区域Java 7及之前堆内存逻辑上分为3个部分：新生区 + 养老区 + 永久区 Java 8及之后堆内存逻辑上分为3个部分：新生区 + 养老区 + 元空间 新生区 Young Generation Space Young&#x2F;New Eden区 伊甸区 Survivor区 幸存区 Tenure generation Space 养老区 Old&#x2F;Tenure Permanent Space 永久区 Perm Meta Space 元空间 Meta GC垃圾回收主要在伊甸园区和老年区。 在JDK8之后，永久存储区改为元空间。 若内存满了，会触发OOM：java.lang.OutOfMemoryError: java heap space。 新生区的内存比例： Eden : from : to &#x3D; 8 : 1 : 1 新生区Eden新创建的对象会放在Eden区，每经历一次GC，位于Eden区存活的对象会被移到幸存区的from区。 幸存区 幸存区分为from和to两部分，两部分会互相交换； 分辨from分区和to分区：一般情况下，空的为to分区。 每次GC，都会把Eden中没有被清理的对象移到幸存区中。 一旦Eden区被GC后，一部分被清理，没有被清理的移到幸存区。 计算过程 每个对象都被定义有寿命； 当寿命达到指定值，就会被移入老年代； 永久区这个区域常驻内存，用来存放JDK自身携带的Class对象。Interface元数据，存储的是Java运行时的一些环境。 这个区域不存在垃圾回收关闭VM虚拟机会释放这个区域的内存。 永久区满的情况 一个启动类，加载了大量的第三方jar包； Tomcat部署了太多的应用，或者大量动态生成的反射类。 不断地加载，若内存满，就会出现OOM。 版本历史 Jdk1.6之前：永久代，常量池在方法区； Jdk1.7：永久代，但是慢慢退化了，去永久代，常量池在堆中； jdk1.8之后：无永久代，常量池在元空间。 用代码表现内存溢出VM参数：-Xms8M -Xmx8M -XX:+PrintGCDetails 1234567891011121314public class GetJVMMaxMemoery &#123; public static void main(String[] args) &#123; long l = Runtime.getRuntime().maxMemory(); long total = Runtime.getRuntime().totalMemory(); System.out.println(&quot;max = &quot;+l/(double)1024/1024+&quot; MB&quot;); System.out.println(&quot;total = &quot;+total/(double)1024/1024+&quot; MB&quot;); //溢出用代码 StringBuilder str = new StringBuilder(&quot;asdqwe&quot;); while (true)&#123; str.append(&quot;qweasdwa&quot;); &#125; &#125;&#125; 1234567891011121314151617181920212223[GC (Allocation Failure) [PSYoungGen: 1536K-&gt;488K(2048K)] 1536K-&gt;716K(7680K), 0.0007954 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] max = 7.5 MBtotal = 7.5 MB[Full GC (Ergonomics) [PSYoungGen: 1477K-&gt;0K(2048K)] [ParOldGen: 5604K-&gt;3731K(5632K)] 7082K-&gt;3731K(7680K), [Metaspace: 3242K-&gt;3242K(1056768K)], 0.0061693 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] [GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(2048K)] 3731K-&gt;3731K(7680K), 0.0004458 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [Full GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(2048K)] [ParOldGen: 3731K-&gt;3713K(5632K)] 3731K-&gt;3713K(7680K), [Metaspace: 3242K-&gt;3242K(1056768K)], 0.0055763 secs] [Times: user=0.06 sys=0.00, real=0.01 secs] Heap PSYoungGen total 2048K, used 75K [0x00000000ffd80000, 0x0000000100000000, 0x0000000100000000) eden space 1536K, 4% used [0x00000000ffd80000,0x00000000ffd92f30,0x00000000fff00000) from space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000) to space 512K, 0% used [0x00000000fff00000,0x00000000fff00000,0x00000000fff80000) ParOldGen total 5632K, used 3713K [0x00000000ff800000, 0x00000000ffd80000, 0x00000000ffd80000) object space 5632K, 65% used [0x00000000ff800000,0x00000000ffba0518,0x00000000ffd80000) Metaspace used 3272K, capacity 4500K, committed 4864K, reserved 1056768K class space used 354K, capacity 388K, committed 512K, reserved 1048576KException in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space at java.util.Arrays.copyOf(Arrays.java:3332) at java.lang.AbstractStringBuilder.ensureCapacityInternal(AbstractStringBuilder.java:124) at java.lang.AbstractStringBuilder.append(AbstractStringBuilder.java:448) at java.lang.StringBuilder.append(StringBuilder.java:136) at com.yn.GetJVMMaxMemoery.main(GetJVMMaxMemoery.java:13)Process finished with exit code 1 JProfiler工具 分许Dump内存文件，快速定位内存泄露。 … 其他Java程序运行的部分参数 -Xms 初始化分配内存大小 -Xms1G、-Xms512M -Xmx 设置最大分配内存 -Xmx1024M、-Xmx2G -XX:PrintGCDetails 输出内存分配 -XX:HeapDumpOnOutOfMemoryError 输出栈溢出信息 -XX:MaxTenuringThreshold &#x3D; 15 通过这个参数可以设定对象经过GC多少次仍然存活后晋升到老年代的最大阈值。默认：15。 Java代码校验过程java代码首先会经过编译器校验，然后在解释器解释前会被字节码校验器校验。 对于字节码校验器，运行的代码可能来自本地计算机，也有可能来自远程计算机，本地计算机的代码经过编译器校验，但远程计算机的代码不一定被编译器校验，所以解释前必须经过字节码校验器再次校验。 来源 https://www.oracle.com/java/technologies/security-in-java.html What about the concept of a “hostile compiler”? Although the Java compiler ensures that Java source code doesn’t violate the safety rules, when an application such as the HotJava Browser imports a code fragment from anywhere, it doesn’t actually know if code fragments follow Java language rules for safety: the code may not have been produced by a known-to-be trustworthy Java compiler. In such a case, how is the Java run-time system on your machine to trust the incoming bytecode stream? The answer is simple: the Java run-time system doesn’t trust the incoming code, but subjects it to bytecode verification. The tests range from simple verification that the format of a code fragment is correct, to passing each code fragment through a simple theorem prover to establish that it plays by the rules: it doesn’t forge pointers, it doesn’t violate access restrictions, it accesses objects as what they are (for example, InputStream objects are always used as InputStreams and never as anything else). A language that is safe, plus run-time verification of generated code, establishes a base set of guarantees that interfaces cannot be violated. 不准确的翻译 “恶意编译器”是什么？即使Java编译器确保Java源代码不会避开安全规则，但当代码片段导入来自像HotJava这样的浏览器，不能保证代码片段在安全上是否遵循Java语言规则：代码可能被不被信任的Java编译器编译。因此，电脑上的Java运行时系统如何相信输入的字节流？答案很简单：Java运行时系统不信任输入的代码，而是把它交给字节码校验器。 首先进行简单的代码格式正确性验证，然后每段代码都要通过一个简易的规则检测器，确保符合以下规则： 不会伪造指针 不违反访问显示 按原样访问对象（例如InputStream对象仅仅被访问作InputStream而不是其他的东西） 个人理解 交给Java解释器的代码，可以来自可信的Java编译器，也有可能来自恶意的Java编译器。为保证安全，在Java解释器之前，字节码校验器会对代码再次（在此之前是Java编译器）进行校验，确保不会有不合适的代码被运行。 没有伪造指针 不会违反访问限制 访问对象正确（例如InputStream对象仅仅被访问作InputStream而不是其他的东西） Java的Robot类：java.awt.RobotJava中Robot类位于java.awt.Robot，该类用于为测试自动化，自运行演示程序和其他需要控制鼠标和键盘的应用程序生成本机系统输入事件，Robot类的主要目的是便于Java平台实现自动测试。 JNI 本地方法接口Java Native Interface 三种JVM Sun公司 HotSpot Java HotSpot(TM) 64-Bit Server VM (build 25.202-b08, mixed mode) BEA JRockit IBM J9VM 学习用主要是HotSpot 一些问题请谈谈你对 core 请你谈谈你对JVM的理解？Java8虚拟机和之前的变化更新？ 什么是OOM，什么是栈溢出StackOverFlowError？怎么分析？ JVM的常用调优参数有哪些？ 内存快照如何抓取，怎么分析Dump文件？ 谈谈JVM中，类加载器的你的认识？ JVM JVM的内存模型和分区 ，每个区放什么？ 堆里面的分区有哪些？Eden、from、to，老年区，说说他们的特点。 GC的算法有哪些？标记清除法，标记整理，复制算法，引用计数器，如何使用？ 轻GC 和 重GC 分别在什么时候发生？ 知识点JVM位置 JVM体系结构 类加载器 双亲委派机制 沙箱安全机制 Native PC寄存器 方法区 三种JVM 堆 新生区老年区 堆内存调优 GC ​ 常用算法 JMM 总结","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://zswh33.github.io/tags/Java/"}]},{"title":"Day11 多线程进阶 10 各种锁 排查死锁","slug":"Day11-Multithreading2-10","date":"2022-09-03T10:15:43.000Z","updated":"2022-09-04T03:08:42.799Z","comments":true,"path":"2022/09/03/Day11-Multithreading2-10/","link":"","permalink":"http://zswh33.github.io/2022/09/03/Day11-Multithreading2-10/","excerpt":"","text":"Java的各种锁公平锁 不公平锁公平锁：非常公平，不能插队，必须先来后到。 不公平锁：非常不公平，可以插队。（默认都是非公平锁） ReentrantLock下的锁 123public ReentrantLock() &#123; sync = new NonfairSync();//非公平锁&#125; 类ReentrantLock创建的锁默认是非公平锁。 123public ReentrantLock(boolean fair) &#123; sync = fair ? new FairSync() : new NonfairSync();&#125; 可以通过改变参数改为公平锁。 可重入锁所有的锁都是可重入锁 可重入锁又称递归锁。是指同一个线程在外层方法获取锁的时候，再进入线程的内层方法会自动获取锁（前提：锁的对象是同一个对象），不会因为之前已经获取过锁还没有释放而阻塞。 可重入锁指的是某个线程已经获得某个锁，可以再次获取而不会出现死锁。 synchronized的可重入锁12345678910111213141516171819202122232425public class Demo36_ReentrantLock &#123; public static void main(String[] args) &#123; Phone5 phone5 = new Phone5(); new Thread(()-&gt;&#123; phone5.sendSms(); &#125;,&quot;A&quot;).start(); new Thread(()-&gt;&#123; phone5.sendSms(); &#125;,&quot;B&quot;).start();// Thread.yield(); &#125;&#125;class Phone5&#123; public synchronized void sendSms()&#123; System.out.println(Thread.currentThread().getName()+&quot; Sms&quot;); call(); &#125; public synchronized void call()&#123; System.out.println(Thread.currentThread().getName()+&quot; Call&quot;); &#125;&#125; 在代码中，线程A使用了phone的同步方法sendSms()，锁住了对象phone，然后sendSms()方法调用了同步方法call()，此时本应等待对象phone解锁后才能执行，因为可重入锁的原因，该操作继续执行。 ReentrantLock可重入锁可以记录同一线程的锁的个数。 一个线程（A）可以多次使用lock()获得锁，ReentrantLock对象会记录这个线程（A）锁的数量，在全部锁被解锁之前，另一个线程（B）进行lock()会被阻塞，直到这个线程（A）将锁全部解锁。 使用lock()方法为当前线程获得一把锁并锁住这把锁，用unlock()解锁。lock()可以重复使用，使用几次，则获得几把锁，解锁时也需要解锁相应的次数（也就是相同数量的unlock()）。 业务代码结束后，一定要解锁，以防下个线程不能执行业务代码。 API API 说明 lock() 为当前线程获得一把锁并锁住这把锁。若ReentrantLock已被另一个线程锁定，则进入阻塞状态，直到锁被完全解锁。同一线程可以多次使用，多次使用会获得多个锁。必须在同一线程中有相同数量的unlock()被执行才能完全解锁。 unlock() 解锁一把锁。在同一线程中，与lock()配对使用，使用lock()后可以使用unlock()。若锁并没有进行lock()，使用unlock()会抛出异常：java.lang.IllegalMonitorStateException。 … … 使用 正常使用的ReentrantLock可重入锁 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Demo37_ReentrantLock可重入锁 &#123; public static void main(String[] args) &#123; Phone6 phone = new Phone6(); new Thread(()-&gt;&#123; System.out.println(&quot;线程A开始-----------------&quot;); phone.sendSms(); System.out.println(&quot;线程A结束-----------------&quot;); &#125;,&quot;A&quot;).start(); new Thread(()-&gt;&#123; System.out.println(&quot;线程B开始-----------------&quot;); phone.sendSms(); System.out.println(&quot;线程B结束-----------------&quot;); &#125;,&quot;B&quot;).start(); &#125;&#125;class Phone6&#123; Lock lock = new ReentrantLock(); public void sendSms()&#123; lock.lock(); //lock锁住了一把锁 1 try &#123; //业务代码 System.out.println(Thread.currentThread().getName()+&quot; Sms&quot;); call(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock();//解锁一把锁 1 &#125; &#125; public void call()&#123; lock.lock();//获得并锁住一把锁 2 try &#123; //业务代码 System.out.println(Thread.currentThread().getName()+&quot; Call&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock();//解锁一把锁 2 &#125; &#125;&#125; 执行结果： 1234567891011线程A开始-----------------A SmsA Call线程A结束-----------------线程B开始-----------------B SmsB Call线程B结束-----------------Process finished with exit code 0//“线程结束”的提示输出可能会错乱，因为多线程导致顺序不同，因仅测试学习提示用，所以不是重点。 分析一个线程，这里分析线程A： sendSms()方法使用了lock.lock()获得并锁住了一把锁， 到call()方法里，方法lock.lock()为线程A再次获得了一把锁，然后进行业务代码， 之后lock.unlock()解锁， call()方法结束回到sendSms()方法，lock.unlock()再次解锁， lock中线程A的锁被完全解锁。 缺少一个unlock()的例子 123456789101112131415161718192021222324252627282930313233343536373839404142public class Demo37_ReentrantLock可重入锁 &#123; public static void main(String[] args) &#123; Phone6 phone = new Phone6(); new Thread(()-&gt;&#123; System.out.println(&quot;线程A开始-----------------&quot;); phone.sendSms(); System.out.println(&quot;线程A结束-----------------&quot;); &#125;,&quot;A&quot;).start(); new Thread(()-&gt;&#123; System.out.println(&quot;线程B开始-----------------&quot;); phone.sendSms(); System.out.println(&quot;线程B结束-----------------&quot;); &#125;,&quot;B&quot;).start(); &#125;&#125;class Phone6&#123; Lock lock = new ReentrantLock(); public void sendSms()&#123; lock.lock(); //lock锁住了一把锁 1 try &#123; System.out.println(Thread.currentThread().getName()+&quot; Sms&quot;); call(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123;// lock.unlock();//解锁一把锁 1 &#125; &#125; public void call()&#123; lock.lock();//获得并锁住一把锁 2 try &#123; System.out.println(Thread.currentThread().getName()+&quot; Call&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock();//解锁一把锁 2 &#125; &#125;&#125; 输出结果： 1234567线程A开始-----------------A SmsA Call线程A结束-----------------线程B开始-----------------//程序没有结束 在这个代码中去掉了sendSms()方法中的lock.unlock()，在线程A执行结束后lock并没有被完全解锁， 到线程B时，由于lock锁被锁定，线程被阻塞，暂时不能正常执行。 lock()和unlock()必须配对使用。 自旋锁 SpinLock自旋锁与其他锁类似，不同的是让线程暂停运行的实现方式不同。 其他锁让线程暂停运行的方式是挂起，挂起后线程的资源会被切换，线程不会消耗CPU资源。 自旋锁让线程暂停运行的方式是无限循环，线程会消耗CPU时间。 特点 线程没有挂起，一旦线程获得锁，并且获得CPU时间，会立即执行，效率相对其他锁高； 线程自旋锁期间会消耗CPU时间，影响性能。 使用场景 锁被占用的时间很短，其他线程能较早地获得锁。 要求 自旋等待的时间必须有一定的限度，如果自旋超过了限定次数没有成功获得锁，就应当挂起线程 实现原理 例1：getAndAddInt()是一个自旋锁 12345678public final int getAndAddInt(Object var1, long var2, int var4) &#123; int var5; do &#123; var5 = this.getIntVolatile(var1, var2); &#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4)); return var5;&#125; 例2：手动实现自旋锁 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Demo38_SpinLock自旋锁 &#123; public static void main(String[] args) &#123; MySpinLock mySpinLock = new MySpinLock(); new Thread(()-&gt;&#123; mySpinLock.lock(); try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; mySpinLock.unlock(); &#125;,&quot;A&quot;).start(); new Thread(()-&gt;&#123; mySpinLock.lock(); try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; mySpinLock.unlock(); &#125;,&quot;B&quot;).start(); &#125;&#125;class MySpinLock &#123; AtomicReference&lt;Thread&gt; atomicReference = new AtomicReference&lt;&gt;(); public void lock()&#123; Thread thread = Thread.currentThread(); //自旋锁 //若不为null，则表示锁已被锁定 //若赋值成功则锁定成功 while (!atomicReference.compareAndSet(null,thread))&#123; &#125; System.out.println(Thread.currentThread().getName()+&quot; ==&gt; lock&quot;); &#125; public void unlock()&#123; Thread thread = Thread.currentThread(); //尝试解锁 atomicReference.compareAndSet(thread,null); System.out.println(Thread.currentThread().getName()+&quot; ==&gt; unlock&quot;); &#125; 123456A ==&gt; lockA ==&gt; unlockB ==&gt; lockB ==&gt; unlockProcess finished with exit code 0 死锁（如何排查死锁）两个线程之间互相拥有对方需要的资源，且在得到需要的资源你之前不会释放已拥有的资源。 简介 如何排查死锁 先放一个死锁 1234567891011121314151617181920212223242526272829303132333435public class Demo39_死锁1 &#123; public static void main(String[] args) &#123; String lockA = &quot;lockA&quot;; String lockB = &quot;lockB&quot;; new Thread(new MyThread2(lockA,lockB),&quot;T1&quot;).start(); new Thread(new MyThread2(lockB,lockA),&quot;T2 &quot;).start(); &#125;&#125;class MyThread2 implements Runnable&#123; private String lockA; private String lockB; public MyThread2(String lockA, String lockB) &#123; this.lockA = lockA; this.lockB = lockB; &#125; @Override public void run() &#123; synchronized (lockA)&#123; System.out.println(Thread.currentThread().getName()+&quot; lock&quot;+lockA+&quot; =&gt;get &quot;+lockB); try &#123; TimeUnit.SECONDS.sleep(2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (lockB)&#123; System.out.println(Thread.currentThread().getName()+&quot; lock&quot;+lockB+&quot; =&gt;get &quot;+lockA); &#125; &#125; &#125;&#125; 排查死锁1 查看日志 123T2 locklockB =&gt;get lockAT1 locklockA =&gt;get lockB//程序没有结束 排查死锁2 查看堆栈信息 使用jps -l定位进程号 使用jstack 进程号 查看进程信息 ( 这里是jstack 11452 ) 123456789101112131415略...Java stack information for the threads listed above:===================================================&quot;T2 &quot;: at com.yn.MyThread2.run(Demo39_死锁1.java:35) - waiting to lock &lt;0x000000076c0149d0&gt; (a java.lang.String) - locked &lt;0x000000076c014a08&gt; (a java.lang.String) at java.lang.Thread.run(Thread.java:748)&quot;T1&quot;: at com.yn.MyThread2.run(Demo39_死锁1.java:35) - waiting to lock &lt;0x000000076c014a08&gt; (a java.lang.String) - locked &lt;0x000000076c0149d0&gt; (a java.lang.String) at java.lang.Thread.run(Thread.java:748)Found 1 deadlock. 找到一个死锁， T2等待0x000000076c0149d0，锁定了0x000000076c014a08； T1等待0x000000076c014a08，锁定了0x000000076c0149d0。 其他Java查看堆栈信息 jps -l 查看进程列表 jstack 进程号 查看进程堆栈信息 12345678910111213141516171819202122232425262728292022-09-04 10:35:00Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.202-b08 mixed mode)://略...Found one Java-level deadlock:=============================&quot;T2 &quot;: waiting to lock monitor 0x000000001cac0c28 (object 0x000000076c0149d0, a java.lang.String), which is held by &quot;T1&quot;&quot;T1&quot;: waiting to lock monitor 0x000000001cac3408 (object 0x000000076c014a08, a java.lang.String), which is held by &quot;T2 &quot;Java stack information for the threads listed above:===================================================&quot;T2 &quot;: at com.yn.MyThread2.run(Demo39_死锁1.java:35) - waiting to lock &lt;0x000000076c0149d0&gt; (a java.lang.String) - locked &lt;0x000000076c014a08&gt; (a java.lang.String) at java.lang.Thread.run(Thread.java:748)&quot;T1&quot;: at com.yn.MyThread2.run(Demo39_死锁1.java:35) - waiting to lock &lt;0x000000076c014a08&gt; (a java.lang.String) - locked &lt;0x000000076c0149d0&gt; (a java.lang.String) at java.lang.Thread.run(Thread.java:748)Found 1 deadlock.","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://zswh33.github.io/tags/Java/"}]},{"title":"Day11 多线程进阶 9 CAS 原子引用","slug":"Day11-Multithreading2-9","date":"2022-09-03T08:16:39.000Z","updated":"2022-09-03T10:15:12.378Z","comments":true,"path":"2022/09/03/Day11-Multithreading2-9/","link":"","permalink":"http://zswh33.github.io/2022/09/03/Day11-Multithreading2-9/","excerpt":"","text":"CAS 介绍 比较当前工作内存中的值和主内存的值，若这个值为期望值，则执行操作。若不是就一直循环，即阻塞。 public final boolean compareAndSet(int expect, int update) public final boolean compareAndSet(int expect, int update)是一个AtomicInteger的实例方法。 若实例的值为expect，则赋值为update。 12345678910111213public class Demo &#123; public static void main(String[] args) &#123; AtomicInteger atomicInteger = new AtomicInteger(123); //public final boolean compareAndSet(int expect, int update) //expect 期望 update 更新 //若达到期望值，则更新，否则不更新 System.out.println(&quot;1. &quot;+atomicInteger); System.out.println(atomicInteger.compareAndSet(123, 345)); System.out.println(&quot;2. &quot;+atomicInteger); System.out.println(atomicInteger.compareAndSet(234,123)); System.out.println(&quot;3. &quot;+atomicInteger); &#125;&#125; 12345671. 123true2. 345false3. 345Process finished with exit code 0 atomicInteger的初始值为123，经过第一次操作，123变为345，方法返回值为true，表示成功。 后来atomicInteger的值为345，第二次操作，若值为234则变为123，显然不是345，返回false，修改失败。 值仍为345。 剖析底层的CAS getAndIncrement()解析 123public final int getAndIncrement() &#123; return unsafe.getAndAddInt(this, valueOffset, 1);&#125; 方法getAndIncrement()可以为AtomicInteger对象通过内存方式实现“++”，其中，getAndIncrement()方法调用了getAndAddInt()方法，其中，为this即为当前对象，valueOffset为”对象为内存中的偏移值”（详见“其他”章节Unsafe类），“1”为增加的大小。 getAndAddInt()解析 CAS总结 CAS：比较当前工作内存中的值和主内存的值，若这个值为期望值，则执行操作。若不是就一直循环，即阻塞。 缺点： 循环耗时； 一次性只能保证一个共享变量的原子性； ABA问题。 CAS： ABA问题（狸猫换太子） 123456789101112131415161718public class Demo33_ABA问题 &#123; public static void main(String[] args) &#123; AtomicInteger atomicInteger = new AtomicInteger(123); // ===================== 捣乱的线程 ===================== System.out.println(atomicInteger.compareAndSet(123,321)); System.out.println(atomicInteger); System.out.println(atomicInteger.compareAndSet(321,123)); System.out.println(atomicInteger); // ===================== 期望的线程 ===================== System.out.println(atomicInteger.compareAndSet(123,321)); System.out.println(atomicInteger); /** * 期望的线程不知道捣乱的线程改过数据。 */ &#125;&#125; 原子引用AtomicStampedReference 可以原子更新的对象引用。 思想：乐观锁 AtomicStampedReference介绍 AtomicStampedReference创建的对象，有功能： 指向一个泛型对象； 记录一个stamp值（类似版本号）。 通过compareAndSet()方法可以修改AtomicStampedReference对象的指向。在使用该方法更新指向时，可以指定原对象、修改后对象、期望stamp值、目标stamp值。 该方法会判断指定的“原对象”和“期望stamp值”是否与存储的一致， 若一致，则修改指向和stamp值，返回true； 若不一致，则不修改，返回false。 在线程执行前，记录对象的stamp值，然后进行业务代码。在这期间，若对象被修改，会留下stamp更新。再次修改对象前，核对stamp值，可以得知对象是否在这期间修改过。 例子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Demo34_AtomicReference &#123; public static void main(String[] args) &#123; //注意，如果泛型是一个包装类，注意对象的引用问题。 //正常业务里，这里应为一个对象 AtomicStampedReference&lt;Integer&gt; atomicReference = new AtomicStampedReference&lt;&gt;(12,1); //捣乱的线程 //负责在执行期间，修改atomicReference的值，并更新stamp的值。 new Thread(()-&gt;&#123; System.out.println(Thread.currentThread().getName()+&quot;1-&gt; &quot;+atomicReference.getStamp()); try &#123; TimeUnit.SECONDS.sleep(2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;A &quot;+atomicReference.compareAndSet( 12, 123, atomicReference.getStamp(), atomicReference.getStamp() + 1 )); System.out.println(Thread.currentThread().getName()+&quot;2-&gt; &quot;+atomicReference.getStamp()); System.out.println(&quot;A &quot;+atomicReference.compareAndSet( 123, 12, atomicReference.getStamp(), atomicReference.getStamp() + 1 )); System.out.println(Thread.currentThread().getName()+&quot;3-&gt; &quot;+atomicReference.getStamp()); &#125;,&quot;A&quot;).start(); //正常的业务线程 //业务代码执行前，记录stamp的值，业务代码后，核对stamp值是否正确，若正确则修改对象的值，错误则不修改。 new Thread(()-&gt;&#123; int stamp = atomicReference.getStamp(); System.out.println(Thread.currentThread().getName()+&quot;1-&gt; &quot;+stamp); try &#123; TimeUnit.SECONDS.sleep(2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;B &quot;+atomicReference.compareAndSet( 12, 23, stamp, stamp + 1 )); System.out.println(Thread.currentThread().getName()+&quot;2-&gt; &quot;+atomicReference.getStamp()); &#125;,&quot;B&quot;).start(); &#125;&#125; 其他 Unsafe类 Unsafe用于让Java操作内存。 原理：Java不能操作内存，但C++可以操作内存。Java有个Unsafe类有native本地方法，可以调用C++操作内存。 int的包装类Interger Integer使用了对象缓存机制，默认范围 -128 ~ 127。 推荐使用静态工厂方法 valueOf 获取对象实例，而不是new，因为valueOf使用缓存，而new一定会创建新的对象分配新的内存空间。 对于Integer var &#x3D; ?在**-128 ~ 127之间的赋值，Integer对象是在IntegerCache.cache产生，会复用已有对象，这个区间内的Integer值可以直接使用“&#x3D;&#x3D;”进行判断，但是这个区间之外的所有数据，都会在堆上产生，并不会复用已有对象。推荐使用equals**方法进行判断。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://zswh33.github.io/tags/Java/"}]},{"title":"Day11 DCL懒汉式单例反破解攻坚战 (๑•̀ㅂ•́)و✧","slug":"Day11-Crack-DCL-LayMan","date":"2022-09-03T04:03:34.000Z","updated":"2022-09-03T08:08:05.724Z","comments":true,"path":"2022/09/03/Day11-Crack-DCL-LayMan/","link":"","permalink":"http://zswh33.github.io/2022/09/03/Day11-Crack-DCL-LayMan/","excerpt":"","text":"DCL懒汉式单例反破解攻坚战 (๑•̀ㅂ•́)و✧DCL懒汉式单例1234567891011121314151617181920//懒汉式单例public class LazyMan &#123; private volatile static LazyMan lazyMan;//添加volatile，防止代码重新编排。具体影响位置：getInstance()下的lazyMan = new LazyMan(); //双重监测锁模式的 懒汉式单例 DCL懒汉式 public static LazyMan getInstance()&#123; if(lazyMan==null)&#123; synchronized (LazyMan.class)&#123; //双重检测锁模式 避免对象反复创建 if(lazyMan==null)&#123; lazyMan = new LazyMan(); &#125; &#125; &#125; return lazyMan; &#125; private LazyMan()&#123; &#125;&#125; 通过反射破解DCL懒汉式单例12345678910111213public class Crack1 &#123; //通过反射获取多个LazyManV2 public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123; LazyManV2 lazyManV2_1 = LazyManV2.getInstance();//第一个 Class c1 = LazyManV2.class;//获取LazyManV2的Class类 Constructor constructor = c1.getDeclaredConstructor();//通过反射获取构造方法 constructor.setAccessible(true);//设置权限 LazyManV2 lazyManV2_2 = (LazyManV2) constructor.newInstance();//创建对象 System.out.println(lazyManV2_1); System.out.println(lazyManV2_2); &#125;&#125; 123456main线程创建了一个DCL LazyManmain线程创建了一个DCL LazyMancom.yn.Demo31_懒汉式单例破解攻坚战.LazyManV2@1b6d3586com.yn.Demo31_懒汉式单例破解攻坚战.LazyManV2@4554617cProcess finished with exit code 0 成功创建两个不同的单例。 DCL懒汉式单例2.01234567891011121314151617181920212223242526//懒汉式单例public class LazyManV3 &#123; private static LazyManV3 lazyMan; //双重监测锁模式的 懒汉式单例 DCL懒汉式 public static LazyManV3 getInstance()&#123; if(lazyMan==null)&#123; synchronized (LazyManV3.class)&#123; if(lazyMan==null)&#123; lazyMan = new LazyManV3(); &#125; &#125; &#125; return lazyMan; &#125; private LazyManV3()&#123; //防止对象反复创建 防止通过反射破坏单例 synchronized (LazyManV3.class)&#123; if(lazyMan!=null)&#123; throw new RuntimeException(&quot;不要试图使用反射破坏异常&quot;); &#125; &#125; System.out.println(Thread.currentThread().getName()+ &quot;线程创建了一个DCL LazyMan&quot;); &#125;&#125; 这里在构造方法中添加了语句，在getInstance()方法创建对象后，禁止通过反射方式再次创建对象。 使用getInstance()创建对象后，再次使用反射方式创建对象会抛出异常。 12345678910111213main线程创建了一个DCL LazyManException in thread &quot;main&quot; java.lang.reflect.InvocationTargetException at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method) at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62) at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45) at java.lang.reflect.Constructor.newInstance(Constructor.java:423) at com.yn.Demo31_懒汉式单例破解攻坚战.Crack2.main(Crack2.java:13)Caused by: java.lang.RuntimeException: 不要试图使用反射破坏异常 at com.yn.Demo31_懒汉式单例破解攻坚战.LazyManV3.&lt;init&gt;(LazyManV3.java:24) ... 5 moreProcess finished with exit code 1 通过反射破解DCL懒汉式单例2.0道高一尺，魔高一丈。 1234567891011121314public class Crack2 &#123; //通过反射获取多个LazyManV2 public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123;// LazyManV3 lazyMan_1 = LazyManV3.getInstance();//第一个 Class c1 = LazyManV3.class; Constructor constructor = c1.getDeclaredConstructor(); constructor.setAccessible(true); LazyManV3 lazyMan_2 = (LazyManV3) constructor.newInstance(); LazyManV3 lazyMan_1 = (LazyManV3) constructor.newInstance(); System.out.println(lazyMan_1); System.out.println(lazyMan_2); &#125;&#125; 两个对象都通过反射方式创建，这样LazyMan的类变量不会得到赋值，可以成功创建两个不同的对象。 DCL懒汉式单例3.01234567891011121314151617181920212223242526272829//懒汉式单例public class LazyManV4 &#123; private static LazyManV4 lazyMan; private static boolean awsl = false;//红绿灯 awsl换成加密的字符串，这里学习用 //双重监测锁模式的 懒汉式单例 DCL懒汉式 public static LazyManV4 getInstance()&#123; if(lazyMan==null)&#123; synchronized (LazyManV4.class)&#123; if(lazyMan==null)&#123; lazyMan = new LazyManV4(); &#125; &#125; &#125; return lazyMan; &#125; private LazyManV4()&#123; //防止对象反复创建 防止通过反射破坏单例 synchronized (LazyManV4.class)&#123; if(!awsl)&#123;//创建红绿灯，用于判断对象是否被反复创建 awsl=true; &#125;else&#123; throw new RuntimeException(&quot;不要试图使用反射破坏异常&quot;); &#125; &#125; System.out.println(Thread.currentThread().getName()+ &quot;线程创建了一个DCL LazyMan&quot;); &#125;&#125; 添加红绿灯，用于判断对象是否被反复创建。 构造方法被重复调用，除第一次外，后面都会抛出异常。 12345678910111213main线程创建了一个DCL LazyManException in thread &quot;main&quot; java.lang.reflect.InvocationTargetException at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method) at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62) at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45) at java.lang.reflect.Constructor.newInstance(Constructor.java:423) at com.yn.Demo31_懒汉式单例破解攻坚战.Crack3.main(Crack3.java:14)Caused by: java.lang.RuntimeException: 不要试图使用反射破坏异常 at com.yn.Demo31_懒汉式单例破解攻坚战.LazyManV4.&lt;init&gt;(LazyManV4.java:27) ... 5 moreProcess finished with exit code 1 通过反射破解DCL懒汉式单例3.0解密并想办法获得红绿灯的变量，然后修改红绿灯的值。 12345678910111213141516171819202122public class Crack3 &#123; //通过反射获取多个LazyManV2 public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException, NoSuchFieldException &#123;// LazyManV3 lazyMan_1 = LazyManV3.getInstance();//第一个 Class c1 = LazyManV4.class; Constructor constructor = c1.getDeclaredConstructor(); constructor.setAccessible(true); LazyManV4 lazyMan_2 = (LazyManV4) constructor.newInstance(); //先想办法解密获得awsl变量，然后通过反射修改awsl的值，然后破坏单例// String awsl = c1.getDeclaredFields()[1].getName(); Field awsl = c1.getDeclaredField(&quot;awsl&quot;); awsl.setAccessible(true);//破坏权限 awsl.set(LazyManV4.class,false);//设置值 LazyManV4 lazyMan_1 = (LazyManV4) constructor.newInstance(); System.out.println(lazyMan_1); System.out.println(lazyMan_2); &#125;&#125; 枚举是一个单例对象 newInstance()的源代码：不能通过反射破坏枚举类型。 1234567891011121314151617181920public T newInstance(Object ... initargs) throws InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException&#123; if (!override) &#123; if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123; Class&lt;?&gt; caller = Reflection.getCallerClass(); checkAccess(caller, clazz, null, modifiers); &#125; &#125; if ((clazz.getModifiers() &amp; Modifier.ENUM) != 0) throw new IllegalArgumentException(&quot;Cannot reflectively create enum objects&quot;); ConstructorAccessor ca = constructorAccessor; // read volatile if (ca == null) &#123; ca = acquireConstructorAccessor(); &#125; @SuppressWarnings(&quot;unchecked&quot;) T inst = (T) ca.newInstance(initargs); return inst;&#125; 通过newInstance()的源代码发现，newInstance()不能通过反射破坏枚举类型。 枚举自带单例模式。 枚举 123456public enum Enum1 &#123; INSTANCE; public static Enum1 getInstance()&#123; return INSTANCE; &#125;&#125; 通过反射破解枚举的单例对象 Idea反编译Enmu1的class，发现代码里面有一个无参构造方法。 12345678910111213141516public enum Enum1 &#123; INSTANCE; private int asd; private Enum1() &#123; &#125; public static Enum1 getInstance() &#123; return INSTANCE; &#125; public String toString() &#123; return &quot;Enum1&#123;asd=&quot; + this.asd + &#x27;&#125;&#x27;; &#125;&#125; 用反射的方式，通过无参构造方法创建对象。 123456789101112public class Crack4 &#123; public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException, NoSuchFieldException &#123; Enum1 enum1 = Enum1.getInstance(); Constructor&lt;Enum1&gt; constructor = Enum1.class.getDeclaredConstructor();//获取无参构造方法 constructor.setAccessible(true);//设置权限 Enum1 enum2 = constructor.newInstance();//创建对象 System.out.println(enum1); System.out.println(enum2); &#125;&#125; 123456Exception in thread &quot;main&quot; java.lang.NoSuchMethodException: com.yn.Demo31_懒汉式单例破解攻坚战.Enum1.&lt;init&gt;() at java.lang.Class.getConstructor0(Class.java:3082) at java.lang.Class.getDeclaredConstructor(Class.java:2178) at com.yn.Demo31_懒汉式单例破解攻坚战.Crack4.main(Crack4.java:11)Process finished with exit code 1 出现错误：没有这个方法。 结论：没有相关的无参构造方法。 通过javap -p 反编译class字节码文件，查看源代码。 也许Idea骗了我们？ 123456789101112Compiled from &quot;Enum1.java&quot;public final class com.yn.Demo31_懒汉式单例破解攻坚战.Enum1 extends java.lang.Enum&lt;com.yn.Demo31_懒汉式单例破解攻坚战.Enum1&gt; &#123; public static final com.yn.Demo31_懒汉式单例破解攻坚战.Enum1 INSTANCE; private int asd; private static final com.yn.Demo31_懒汉式单例破解攻坚战.Enum1[] $VALUES; public static com.yn.Demo31_懒汉式单例破解攻坚战.Enum1[] values(); public static com.yn.Demo31_懒汉式单例破解攻坚战.Enum1 valueOf(java.lang.String); private com.yn.Demo31_懒汉式单例破解攻坚战.Enum1(); public static com.yn.Demo31_懒汉式单例破解攻坚战.Enum1 getInstance(); public java.lang.String toString(); static &#123;&#125;;&#125; 通过反编译得知 public final class com.yn.Demo31_懒汉式单例破解攻坚战.Enum1 extends java.lang.Enum&lt;com.yn.Demo31_懒汉式单例破解攻坚战.Enum1&gt;。枚举确实是一个用class修饰的类，不过是继承了java.lang.Enum成为枚举。 private com.yn.Demo31_懒汉式单例破解攻坚战.Enum1();。Enmu1类确实有一个无参构造方法。？！ 尝试使用jad反编译class字节码文件 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.yn.Demo31_61D26C495F0F53554F8B783489E3653B575A6218;public final class Enum1 extends Enum&#123; public static Enum1[] values() &#123; return (Enum1[])$VALUES.clone(); &#125; public static Enum1 valueOf(String name) &#123; return (Enum1)Enum.valueOf(com/yn/Demo31_61D26C495F0F53554F8B783489E3653B575A6218/Enum1, name); &#125; private Enum1(String s, int i) &#123; super(s, i); &#125; public static Enum1 getInstance() &#123; return INSTANCE; &#125; public String toString() &#123; return (new StringBuilder()).append(&quot;Enum1&#123;asd=&quot;).append(asd).append(&#x27;&#125;&#x27;).toString(); &#125; public static final Enum1 INSTANCE; private int asd; private static final Enum1 $VALUES[]; static &#123; INSTANCE = new Enum1(&quot;INSTANCE&quot;, 0); $VALUES = (new Enum1[] &#123; INSTANCE &#125;); &#125;&#125; 由反编译结果可知，private Enum1(String s, int i)是一个有参构造方法。 通过有参构造方法创建对象 123456789101112public class Crack4 &#123; public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException, NoSuchFieldException &#123; Enum1 enum1 = Enum1.getInstance(); Constructor&lt;Enum1&gt; constructor = Enum1.class.getDeclaredConstructor(String.class,int.class);//获取有参构造方法 constructor.setAccessible(true);//设置权限 Enum1 enum2 = constructor.newInstance();//创建对象 System.out.println(enum1); System.out.println(enum2); &#125;&#125; 12345Exception in thread &quot;main&quot; java.lang.IllegalArgumentException: Cannot reflectively create enum objects at java.lang.reflect.Constructor.newInstance(Constructor.java:417) at com.yn.Demo31_懒汉式单例破解攻坚战.Crack4.main(Crack4.java:13)Process finished with exit code 1 通过输出得知，不能通过反射创建枚举对象。 其他 enum枚举 枚举本身是一个class类 使用jad将class文件转换为java文件 jad -sjava 字节码文件.class","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://zswh33.github.io/tags/Java/"}]},{"title":"Day11 多线程进阶 8 单例模式","slug":"Day11-Multithreading2-8","date":"2022-09-03T03:07:16.000Z","updated":"2022-09-03T08:16:03.774Z","comments":true,"path":"2022/09/03/Day11-Multithreading2-8/","link":"","permalink":"http://zswh33.github.io/2022/09/03/Day11-Multithreading2-8/","excerpt":"","text":"单例模式创建的对象只有一个，程序运行过程中只使用这一个对象 构造方法私有private 程序运行过程中只有一个，使用getInstance()方法获取对象。 饿汉式单例恶汉！！！ 一次性分配所有空间。 123456789101112//饿汉式单例public class Hungry &#123; private final static Hungry HUNGRY = new Hungry(); public static Hungry getInstance()&#123; return HUNGRY; &#125; private Hungry()&#123; &#125;&#125; 懒汉式单例使用时分配空间。 普通的懒汉式单例（仅用于学习）代码12345678910111213//懒汉式单例public class LazyMan &#123; private static LazyMan lazyMan; public static LazyMan getInstance()&#123; if(lazyMan==null)&#123; lazyMan = new LazyMan(); &#125; return lazyMan; &#125; private LazyMan()&#123; System.out.println(Thread.currentThread().getName()); &#125;&#125; 相对于“饿汉式单例”，懒汉式单例在使用时才分配内存，避免了内存占用。 多线程下不适用12345678910111213141516171819202122//懒汉式单例public class LazyMan &#123; private static LazyMan lazyMan; public static LazyMan getInstance()&#123; if(lazyMan==null)&#123; lazyMan = new LazyMan(); &#125; return lazyMan; &#125; private LazyMan()&#123; System.out.println(Thread.currentThread().getName()); &#125; //多线程 public static void main(String[] args) &#123; for (int i = 0; i &lt; 10; i++) &#123; new Thread(()-&gt;&#123; LazyMan.getInstance(); &#125;).start(); &#125; &#125;&#125; 1234Thread-0Thread-4Thread-1Thread-2 出现错误：多线程下多次创建对象。 DCL懒汉式单例（仅用于学习）懒汉式单例dev0.2 代码1234567891011121314151617181920//懒汉式单例public class LazyMan &#123; private static LazyMan lazyMan; //双重监测锁模式的 懒汉式单例 DCL懒汉式 public static LazyMan getInstance()&#123; if(lazyMan==null)&#123; synchronized (LazyMan.class)&#123; if(lazyMan==null)&#123; lazyMan = new LazyMan(); &#125; &#125; &#125; return lazyMan; &#125; private LazyMan()&#123; &#125;&#125; 将getInstance()方法中创建对象的过程添加了“双重检测锁”。 解决了多线程下，对象反复创建的问题。 多线程下不适用2.0123456789101112131415161718192021222324252627282930313233343536373839404142//懒汉式单例public class LazyMan &#123; private volatile static LazyMan lazyMan; //双重监测锁模式的 懒但是单例 DCL懒汉式 public static LazyMan getInstance()&#123; if(lazyMan==null)&#123; synchronized (LazyMan.class)&#123; if(lazyMan==null)&#123; lazyMan = new LazyMan();// 不是一个原子性操作 /** * 将这个操作分割： * 1. 分配内存空间 * 2. 执行构造方法，初始化对象 * 3. 把这个对象指向这个空间 * * 在多线程执行过程中，可能会发生“指令编排”，导致操作顺序错乱，并造成问题。 * 如： * 线程A执行了顺序：132，执行到3结束时， * 线程B中的getInstance()发现lazyMan不为null，直接返回， * 在线程A的2执行前，也就是对象构造方法执行前，线程B使用了没有进行构造方法lazyMan对象，造成意外。 * 解决方法：在lazyMan前添加volatile，避免指令重排。 */ &#125; &#125; &#125; return lazyMan; &#125; private LazyMan()&#123; System.out.println(Thread.currentThread().getName()); &#125; //多线程 public static void main(String[] args) &#123; for (int i = 0; i &lt; 10; i++) &#123; new Thread(()-&gt;&#123; LazyMan.getInstance(); &#125;).start(); &#125; &#125;&#125; 在getInstance()方法中，lazyMan = new LazyMan();不是一个原子类操作，可以再分： 分配内存空间 执行构造方法，初始化对象 把这个对象指向这个空间 在多线程执行过程中，可能会发生“指令编排”，导致操作顺序错乱，并造成问题。 如：线程A执行了顺序：132，执行到3结束时，线程B中的getInstance()发现lazyMan不为null，直接返回，在线程A的2执行前，也就是对象构造方法执行前，线程B使用了没有进行构造方法lazyMan对象，造成意外。解决方法：在lazyMan前添加volatile，避免指令重排。 正确的DCL懒汉式单例1234567891011121314151617181920//懒汉式单例public class LazyMan &#123; private volatile static LazyMan lazyMan;//添加volatile，防止代码重新编排。具体影响位置：getInstance()下的lazyMan = new LazyMan(); //双重监测锁模式的 懒汉式单例 DCL懒汉式 public static LazyMan getInstance()&#123; if(lazyMan==null)&#123; synchronized (LazyMan.class)&#123; //双重检测锁模式 避免对象反复创建 if(lazyMan==null)&#123; lazyMan = new LazyMan(); &#125; &#125; &#125; return lazyMan; &#125; private LazyMan()&#123; &#125;&#125; 反破解DCL懒汉式单例1234567//懒汉式单例public enum LazyManV5 &#123; INSTANCE; public static LazyManV5 getInstance()&#123; return INSTANCE; &#125;&#125; 这 ….这还是懒汉式单例吗？","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://zswh33.github.io/tags/Java/"}]},{"title":"Day11 多线程进阶 7 JMM Volatile","slug":"Day11-Multithreading2-7","date":"2022-09-03T00:23:04.000Z","updated":"2022-09-06T08:43:01.792Z","comments":true,"path":"2022/09/03/Day11-Multithreading2-7/","link":"","permalink":"http://zswh33.github.io/2022/09/03/Day11-Multithreading2-7/","excerpt":"","text":"JMMJava Memory Model 介绍 JMM：Java内存模型。（一个约定，协议） 使用场景 &#x2F; 解决的问题 在不同硬件生产商和不同操作系统下，内存的访问逻辑有一定的差异，导致一段代码在某个系统环境下运行良好，并且线程安全，但是换了系统就出现各种问题。 Java内存模型，就是为了屏蔽系统和硬件的差异，让一套代码在不同平台下能达到相同的访问效果。 概念：内存划分 JMM规定内存主要划分为主内存和工作内存两种。 此处的主内存和工作内存与JVM内存划分（堆、栈、方法区）是在不同的层次上进行的，若非要对应起来，主内存对应的是Java堆中的对象实例部分，工作内存对应的是栈中的部分区域。 从底层来看，主内存对应的是硬件的物理内存，工作内存对应的是寄存器和高速缓存。 概念：内存交互操作 内存交互操作有8中，虚拟机实现必须保证每一个操作都是原子的（原子：即不可再分的）。 原子操作 说明 lock(锁定) 作用于主内存的变量，把一个变量标识为线程独占状态。 unlock(解锁) 作用于主内存的变量，把一个处于锁定状态的变量释放出来。 read(读取) 作用于主内存的变量，把一个变量的值从主内存传输到线程的工作内存中。与load一起使用。 load(载入) 作用于工作内存的变量，把 read操作从主存中传输的变量 放入工作内存中。与read一起使用。 use（使用） 作用于工作内存的变量，把工作内存的变量传输给执行引擎。每当虚拟机遇到一个需要使用到变量的值，就要用到这个指定。 assign（赋值） 作用于工作内存的变量，把一个从执行引擎中接受到的值放入工作内存的变量副本中。 store（存储） 作用于主内存中的变量，把一个从工作内存变量的值传输到主内存中。与write一起使用。 write（写入） 作用于主内存中的变量，把store操作从工作内存中得到的变量的值放入主内存的变量中。与store一起使用。 JMM原子操作的一些约定： 不允许read和load、store和write操作之一单独出现，即使用了read必须load，使用了store必须write； 不允许线程丢弃它最近的assign操作，即工作变量数据改变之后，必须告知内存； 不允许一个线程将没有assign的数据从工作内存同步回主内存； 一个新的变量必须在内存中诞生，不允许工作内存直接使用一个未被初始化的变量。也就是对变量实施use、store操作之前，必须经过assign和load操作； 一个变量同一时间只有一个线程能对其进行lock。多次lock后，必须执行相同次数的unlock才能解锁； 如果对一个变量进行lock操作，会清空所有工作内存中此变量的值，在执行引擎使用这个变量前，必须重新load或assign操作初始化变量的值； 如果一个变量没有被lock，就不能对其进行unlock操作，也不能unlock一个被其他线程锁住的变量； 对一个变量进行unlock操作之前，必须把此变量同步回主内存。 概念：一些约定 关于JMM的一些同步的约定 线程解锁前，必须立刻把共享变量立刻刷回主存； 线程加锁前，必须读取主存中的最新值到工作内存中； 加锁和解锁是同一把锁。 VolatileVolatile是Java虚拟机提供的轻量级同步机制。 介绍hole… 作用&#x2F;特征 保证可见性 不保证原子性 禁止指令重排 应用场景单例模式。 特征介绍特性1：保证可见性问题简述： 123456789101112131415//出现问题：num赋值为1后，线程并没有停止public class Demo29_Volatile &#123; private static int num = 0;//位于主存的一个变量 public static void main(String[] args) throws InterruptedException &#123; new Thread(()-&gt;&#123; while (num == 0)&#123; //在线程中使用num时，会读取到工作区的num值，并没有同步主存的num值， //当主线程修改了主存中的num值，线程仍旧不会停止 &#125; &#125;).start(); TimeUnit.SECONDS.sleep(1); num = 1;//修改num值为1 System.out.println(&quot;现在num为1&quot;); &#125;&#125; 当num赋值为1，子线程没有停止。因为在当前程序中，子线程运行后，会将num值复制到工作区，后续线程使用num值，只会使用到工作区的num，不使用主线程的num，主线程修改num后，子线程工作区的num仍为原来的值，导致在线程内num一直为0，子线程不会停止。 另外的说法：在子线程运行后，num被read&#x2F;load到子线程的工作区后，线程的执行引擎使用工作区的num。当主线程将num值修改后，子线程工作区的num仍为原来的值，线程不会停止。 解决方法： 12345678910111213141516//出现问题：num赋值为1后，线程并没有停止//解决方法：在num前加volatilepublic class Demo29_Volatile &#123; private volatile static int num = 0;//位于主存的一个变量 public static void main(String[] args) throws InterruptedException &#123; new Thread(()-&gt;&#123; while (num == 0)&#123; //在线程中使用num时，会读取到工作区的num值，并没有同步主存的num值， //当主线程修改了主存中的num值，线程仍旧不会停止 &#125; &#125;).start(); TimeUnit.SECONDS.sleep(1); num = 1;//修改num值为1 System.out.println(&quot;现在num为1&quot;); &#125;&#125; 在num前加：volatile。 待完善 volatile可以保证可见性。 特性2：不保证原子性基本问题代码： 1234567891011121314151617181920212223242526public class Demo29_Volatile不保证原子性 &#123; //volatile不保证原子性 private volatile static int num = 0; public static void add()&#123; num++; &#125; public static void main(String[] args) &#123; //理论上num结果应为20000 for (int i = 0; i &lt; 20; i++) &#123; new Thread(()-&gt;&#123; for (int j = 0; j &lt; 1000; j++) &#123; add(); &#125; &#125;,String.valueOf(i)).start(); &#125; //等待上面创建的线程执行结束 while (Thread.activeCount()&gt;2)&#123; //Java有两个默认线程：main和gc。所以这里写2。 Thread.yield();//让主线程从运行态变为就绪态 &#125; System.out.println(Thread.currentThread().getName()+&quot; &quot;+num);//输出结果 //main 18821 &#125;&#125; 在当前程序中，num输出结果并不是20000。 如何解决这个问题？方法1： 在add()方法前添加synchronized，或添加lock机制。 方法2： 将int替换为AtomicInteger原子Integer类。 使用原子类解决这个问题：将int替换为AtomicInteger原子Integer类。 分析add()的字节码 add()里的“num++”，是线程不安全的。从底层看，”num++”不是一个原子性操作。 使用原子类，解决原子性问题 12345678910111213141516171819202122232425262728public class Demo29_Volatile不保证原子性_从原子角度解决问题 &#123; // volatile不保证原子性 // 将int改为AtomicInteger原子类Integer。 private volatile static AtomicInteger num = new AtomicInteger(); public static void add()&#123; //num++;//不是一个原子性操作 num.getAndIncrement();// AtomicInteger + 1 方法 底层：CAS &#125; public static void main(String[] args) &#123; //理论上num结果应为20000 for (int i = 0; i &lt; 20; i++) &#123; new Thread(()-&gt;&#123; for (int j = 0; j &lt; 1000; j++) &#123; add(); &#125; &#125;,String.valueOf(i)).start(); &#125; //等待上面创建的线程执行结束 while (Thread.activeCount()&gt;2)&#123; //Java有两个默认线程：main和gc。所以这里写2。 Thread.yield();//让主线程从运行态变为就绪态 &#125; System.out.println(Thread.currentThread().getName()+&quot; &quot;+num);//输出结果 //main 20000 &#125;&#125; AtomicInteger 类的底层直接与操作系统挂钩！在内存中操作值。 hole…. 特性3：禁止指令重排 介绍 Volatile基于内存屏障，可以避免指令重排。 实现原理 在正常的指令流中，xx会为volatile指令前后添加内存屏障，禁止volatile前后的指令顺序交换。 依赖 内存屏障 作用： 保证特定的操作的执行顺序； 可以保证某些变量的内存可见性； 依赖于“内存屏障”，volatile实现了禁止指令重排。 其他指令重排 介绍 计算机不按照写的程序的顺序去执行。 可能触发指令重排 编译器优化的重排 指令并行可能会重排 内存系统重排 一个例子 1234int x = 1; // 1int y = 2; // 2x = x + 5; // 3y = x * x; // 4 我们期望的： 1234 实际执行可能的存在： 1324 、 2134等 不可能的存在：4123 查看class文件字节码javap -c 类名.class 原子性操作原子，即不可再分。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://zswh33.github.io/tags/Java/"}]},{"title":"Day10 多线程进阶 6 四大函数式接口 Stream流式计算 ForkJoin分支合并 CompletableFuture异步回调","slug":"Day10-Multitherading2-6","date":"2022-09-02T08:41:30.000Z","updated":"2022-09-03T00:23:51.181Z","comments":true,"path":"2022/09/02/Day10-Multitherading2-6/","link":"","permalink":"http://zswh33.github.io/2022/09/02/Day10-Multitherading2-6/","excerpt":"","text":"四大函数式接口 函数式接口 只有一个方法的接口。 12345678910//例 Callable接口public interface Callable&lt;V&gt; &#123; /** * Computes a result, or throws an exception if unable to do so. * * @return computed result * @throws Exception if unable to compute a result */ V call() throws Exception;&#125; Function函数式接口Function接口可以将一个函数变成一个变量。 Function可以用来写工具类，泛型参数里，第一个为传入类型，第二个为返回类型。 源码 使用 基本用法（不常用的用法）： 12345678910111213public class Demo21_Function &#123; public static void main(String[] args) &#123; //Function可以用来写工具类，泛型参数里，第一个为传入类型，第二个为返回类型。 //这里写一个工具类用于演示：返回输入整数+1。 Function&lt;Integer,Integer&gt; function_plus1 = new Function&lt;Integer,Integer&gt;() &#123; @Override public Integer apply(Integer o) &#123; return o+1; &#125; &#125;; System.out.println(function_plus1.apply(123)); &#125;&#125; 常用用法： 12345678public class Demo21_Function &#123; public static void main(String[] args) &#123; //Function可以用来写工具类，泛型参数里，第一个为传入类型，第二个为返回类型。 //这里写一个工具类用于演示：返回输入整数+1。 Function&lt;Integer,Integer&gt; function_plus1 = (in)-&gt;&#123;return (int)in+1;&#125;; System.out.println(function_plus1.apply(123)); &#125;&#125; 创建一个Function的引用，然后将一个lambda表达式的函数传值给引用； 调用使用方法apply(参数),返回值为lambda表达式的返回值。 Predicate断定型接口不同于Function，Predicate定义的函数只能返回boolean值，输入参数不限。 代码 123456789public class Demo22_Predicate &#123; public static void main(String[] args) &#123; //Predicate也是一个函数式接口，不同的是：Predicate创建的函数只能返回boolean类型。 //泛型参数为输入参数类型。 //当前代码：判断字符串是否为空。 Predicate&lt;String&gt; predicate_isEmpty = (string)-&gt;&#123;return string.isEmpty();&#125;; System.out.println(predicate_isEmpty.test(&quot;asdqwe&quot;)); &#125;&#125; 123falseProcess finished with exit code 0 Consumer消费型接口功能上与函数式接口基本一致。 特点：只有输入，没有返回值。 代码 12345678public class Demo23_Consumer &#123; public static void main(String[] args) &#123; //Consumer消费型接口，只有输入没有返回值。 //这里写一个：输出字符串。 Consumer&lt;String&gt; consumer = (str)-&gt;&#123;System.out.println(str);&#125;; consumer.accept(&quot;张三李四&quot;); &#125;&#125; 使用方法accept(参数)使用该接口的实现对象。 Supplier供给型接口“功能上与函数式接口基本一致。” 特点：没有输入，只有返回值。 源码 12345678910@FunctionalInterfacepublic interface Supplier&lt;T&gt; &#123; /** * Gets a result. * * @return a result */ T get();//没有参数，只有返回值&#125; 代码&#x2F;使用 1234567891011121314151617/** * Supplier供给型接口：没有参数，只有返回值。 */public class Demo24_Supplies &#123; public static void main(String[] args) &#123; //这里写一个：只会返回1024的函数。 Supplier&lt;Integer&gt; supplier = new Supplier&lt;Integer&gt;() &#123; @Override public Integer get() &#123; System.out.println(&quot;get!&quot;); return 1024; &#125; &#125;; System.out.println(supplier.get()); &#125;&#125; 使用get()方法执行函数。 代码 简化 1234567public class Demo24_Supplies &#123; public static void main(String[] args) &#123; //这里写一个：只会返回1024的函数。 Supplier&lt;Integer&gt; supplier = ()-&gt;&#123;return 1024;&#125;; System.out.println(supplier.get()); &#125;&#125; Stream流式计算java.util.stream 大数据时代，无非就是：存储 + 计算 比如：MySQL、Java集合等本质是用来存储东西的。 Stream流式计算就是用来计算。 一个题目 用一行代码实现： 现在有5个用户，要求筛选出： ID必须是偶数 年龄必须大于23岁 用户名转为大写字母 用户名字母倒着排序 只输出一个用户 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public class Demo26_Stream流式计算引入_一道题 &#123; /** * 用一行代码实现： * 现在有5个用户，要求筛选出： * 1. ID必须是偶数 * 2. 年龄必须大于23岁 * 3. 用户名转为大写字母 * 4. 用户名字母倒着排序 * 5. 只输出一个用户 */ public static void main(String[] args) &#123; User u1 = new User(1,&quot;a&quot;,21); User u2 = new User(2,&quot;b&quot;,22); User u3 = new User(3,&quot;c&quot;,23); User u4 = new User(4,&quot;d&quot;,24); User u5 = new User(6,&quot;e&quot;,25); //集合用于存储 List&lt;User&gt; userList = Arrays.asList(u1,u2,u3,u4,u5); //流用于计算 userList.stream() .filter(u-&gt;&#123;return u.getId()%2==0;&#125;)//ID为偶数 .filter(u-&gt;&#123;return u.getAge()&gt;23;&#125;)//年龄大于23 .map(u-&gt;&#123;return u.getName().toUpperCase();&#125;)//名字大写 .sorted((uu1,uu2)-&gt;&#123;return uu2.compareTo(uu1);&#125;)//逆序 .limit(1)//输出1个 .forEach(System.out::println); //Lambda表达式、链式编程、函数式接口、Stream流式计算 &#125;&#125;class User&#123; int id; String name; int age; public User(int id, String name, int age) &#123; this.id = id; this.name = name; this.age = age; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125;&#125; 好像没有说明Stream流式计算是什么？！ dig hole… ForkJoin 分支合并起源于JDK1.7 介绍 是一个分而治之的任务框架。 使用场景：一个任务需要多线程执行，分割成很多块计算的时候，使用ForkJoin方法。 ForkJoin的作用：对于大数据量计算，用于提高效率。 特点 动态规范：和分而治之不同的是，任务分割的每个小任务之间互相联系。 工作密取（工作窃取）：分割了每个任务之后，若某个线程提前完成了任务，就会去其他线程偷取任务来完成，加快执行效率。同时，第一个分配的线程从队列的头部拿取任务，当完成任务的线程后去其他队列拿任务时候是从尾部拿任务。 使用 Hole… 异步回调类似ajax，将Java的线程创建过程包装，使创建线程更加方便。缺点是远离了底层，减少了手动优化的机会。 CompletableFuture类API API 说明 static runAsync(Runnable runnable) 创建一个无返回值的异步回调。 static supplyAsync(Supplier supplier) 创建一个有返回值的异步回调 whenComplete(BiConsumer&lt;? super T, ? super Throwable&gt; action) 为CompletableFuture对象的异步回调添加运行结束时要执行的操作。T为运行成功返回的结果，运行失败为null。Throwable为运行失败的错误信息，成功为null（运行失败指抛出异常或其他错误）。action为BiConsumer对象，用于使用参数和添加回调方法。返回值为CompletableFuture对象，可以使用链式编程。 exceptionally(Function&lt;Throwable, ? extends T&gt; fn) 为CompletableFuture对象的异步回调添加出现异常时要执行的操作。T为抛出的异常。fn为要执行的操作。 get() 使用runAsync()或supplyAsync()方法后，会返回一个CompletableFuture对象，可以使用get()方法获取异步回调的返回值。若线程未运行结束，则会阻塞当前线程等待运行结束。runAsync()的返回值为Void(无返回值)，supplyAsync()返回值由输入指定。 … … 代码 runAsync()和supplyAsyn() 1234567891011121314151617181920212223242526/** * 异步调用：CompletableFuture */public class Demo28_Future &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; // 发起一个请求 // runAsync() 没有返回值的异步回调 CompletableFuture&lt;Void&gt; completableFuture = CompletableFuture.runAsync(()-&gt;&#123; try &#123; TimeUnit.SECONDS.sleep(2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+&quot; ok&quot;); &#125;); System.out.println(&quot;等待runAsync异步请求的结果....&quot;); completableFuture.get();//获取 //supplyAsync 有返回值的异步回调 CompletableFuture&lt;String&gt; completableFuture2 = CompletableFuture.supplyAsync(()-&gt;&#123; System.out.println(Thread.currentThread().getName()+&quot; supplyAsync异步回调&quot;); return &quot;今天吃Obsidian&quot;; &#125;); System.out.println(&quot;等待supplyAsync异步请求的结果.....&quot;); System.out.println(&quot;supplyAsync异步请求的结果：&quot;+completableFuture2.get()); &#125;&#125; supplyAsync()下的whenComplete()和exceptionally() 12345678910111213141516171819202122232425/** * 异步调用：CompletableFuture */public class Demo28_Future2 &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; //supplyAsync 有返回值的异步回调,包括成功、失败的回调。 CompletableFuture&lt;String&gt; completableFuture2 = CompletableFuture.supplyAsync(()-&gt;&#123; System.out.println(Thread.currentThread().getName()+&quot; supplyAsync异步回调&quot;); int t = 10/0; return &quot;今天吃Obsidian&quot;; &#125;); completableFuture2.whenComplete((t,u)-&gt;&#123; System.out.println( &quot;事件完成：&quot; + t+ //成功时，为正确的返回值，失败时为null &quot; &quot;+u //失败时，为错误信息，成功时为null ); &#125;).exceptionally((e)-&gt;&#123; System.out.println(e);//异常时，打印异常信息 return &quot;今天不吃Obsidian.&quot;; &#125;); System.out.println(&quot;等待supplyAsync异步请求的结果.....&quot;); System.out.println(&quot;supplyAsync异步请求的结果：&quot;+completableFuture2.get()); &#125;&#125; 其他forEach()使用代码： 1234List&lt;Integer&gt; list = Arrays.asList(1,2,3,4,5,6);list.forEach((d)-&gt;&#123; System.out.print(d);&#125;); 输出： 1123456 lambda代码简化原本： 123456Consumer&lt;String&gt; consumer = new Consumer&lt;String&gt;() &#123; @Override public void accept(String s) &#123; System.out.println(s); &#125;&#125;; 简化1： 1Consumer&lt;String&gt; consumer = (str)-&gt;&#123;System.out.println(str);&#125;; 简化2： 1Consumer&lt;String&gt; consumer = System.out::println; 当lambda代码块中只有一个方法，且方法的参数和lambda表达式的参数一致，才可以使用。 枚举enum123456789public class Demo25_枚举 &#123; public static void main(String[] args) &#123; Animal animal = Animal.cat; System.out.println(animal); &#125;&#125;enum Animal&#123; pig,cat,dog&#125; 三种方法的求和计算 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/** * 任务：求和计算 * 方法： * 1. 1000000000.for * 2. ForkJoin * 3. Stream并行流 */public class Demo27_求和计算三种方法 &#123; public static void main(String[] args) throws Exception &#123; //基本方法 System.out.println(&quot;sum=&quot;+ProgramTime.get(()-&gt;&#123; long sum = 0L; for (long i = 1; i &lt;= 9_0000_0000; i++) &#123; sum += i; &#125; return sum; &#125;)); System.out.println(&quot;===================&quot;); TimeUnit.SECONDS.sleep(1); //ForkJoin方法 System.out.println(&quot;sum=&quot;+ProgramTime.get(()-&gt;&#123; ForkJoinPool forkJoinPool = new ForkJoinPool(); ForkJoinTask&lt;Long&gt; task = new ForkJoinDemo(0l,9_0000_0000l); ForkJoinTask&lt;Long&gt; sumbit = forkJoinPool.submit(task); return sumbit.get(); &#125;)); System.out.println(&quot;===================&quot;); TimeUnit.SECONDS.sleep(1); //Stream并行流方法 System.out.println(&quot;sum=&quot;+ProgramTime.get(()-&gt;&#123; return LongStream.rangeClosed(0l,9_0000_0000l) .parallel() .reduce(0,Long::sum); &#125;)); System.out.println(&quot;===================&quot;); &#125;&#125;class ProgramTime&lt;T&gt;&#123; public static long get(Callable&lt;Long&gt; fun) throws Exception &#123; long rs; long start = System.currentTimeMillis(); rs = fun.call(); long end = System.currentTimeMillis(); System.out.println(&quot;执行了时间：&quot;+(end-start)); return rs; &#125;&#125;class ForkJoinDemo extends RecursiveTask&lt;Long&gt; &#123; private Long start; private Long end; private Long temp = 10000L;//临界值 public ForkJoinDemo(Long start, Long end) &#123; this.start = start; this.end = end; &#125; @Override protected Long compute() &#123; if (end - start &lt; temp) &#123;//若计算范围小于10000，就用普通方式计算 long sum = 0L; for (long i = start; i &lt;= end; i++) &#123; sum += i; &#125;// System.out.println(sum); return sum; &#125; else &#123; //ForkJoin 分支合并计算 long mid = (start + end) / 2;//中间值 ForkJoinDemo task1 = new ForkJoinDemo(start, mid); task1.fork();//拆分任务，把任务放入线程队列// System.out.println(&quot;qwe&quot;); ForkJoinDemo task2 = new ForkJoinDemo((mid + 1), end); task2.fork();//后半部分// System.out.println(&quot;asd&quot;); return task1.join() + task2.join(); &#125; &#125;&#125; 输出 123456789101112执行了时间：434sum=405000000450000000===================执行了时间：253sum=405000000450000000===================执行了时间：128sum=405000000450000000===================Process finished with exit code 0","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://zswh33.github.io/tags/Java/"}]},{"title":"Day9 多线程进阶 5 读写锁 阻塞队列 同步队列 线程池","slug":"Day9-Multithreading2-5","date":"2022-09-01T10:23:33.000Z","updated":"2022-09-07T00:29:36.042Z","comments":true,"path":"2022/09/01/Day9-Multithreading2-5/","link":"","permalink":"http://zswh33.github.io/2022/09/01/Day9-Multithreading2-5/","excerpt":"","text":"读写锁 ReentrantReadWriteLockReentrantReadWriteLock维护一对关联的Locks，一个用于只读操作，一个用于写入操作。 读操作可以由多个线程进行，写操作只能由一个线程操作。 当写操作由一个线程执行时，其他线程不能进行读操作，也不能进行写操作。 当读操作被执行时，其他线程不能进行写操作。 读锁和写锁互斥。 API 方法名 说明 writeLock().lock() 锁住写锁。若写锁或读锁本来已被锁住，则阻塞，直到写锁和读锁被释放。阻塞结束后，锁住写锁，然后继续运行。 writeLock().unlock() 释放写锁。 readLock().lock() 锁住读锁。若写锁被锁住，则该方法阻塞，直到写锁被释放。阻塞结束后，锁住读锁，然后继续运行。 readLock().unlock() 释放读锁。 … … 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * ReadWriteLock */public class Demo16_ReadWriteLock &#123; public static void main(String[] args) &#123; MyCache myCache = new MyCache(); //写入 for (int i = 1; i &lt;= 5; i++) &#123; final int temp = i; new Thread(()-&gt;&#123; myCache.put(String.valueOf(temp),temp+&quot;&quot;); &#125;,String.valueOf(i)).start(); &#125; //读取 for (int i = 1; i &lt;= 5; i++) &#123; final int temp = i; new Thread(()-&gt;&#123; myCache.get(String.valueOf(temp)); &#125;,String.valueOf(i)).start(); &#125; &#125;&#125;//自定义缓存class MyCache&#123; private volatile Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); private ReadWriteLock lock = new ReentrantReadWriteLock(); //存 写入的时候，只希望有一个线程写 public void put(String key,Object value)&#123; lock.writeLock().lock(); try &#123; System.out.println(Thread.currentThread().getName()+&quot; 写入开始&quot;); map.put(key,value); System.out.println(Thread.currentThread().getName()+&quot; 写入结束&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.writeLock().unlock(); &#125; &#125; //取 读，可以有多个线程读 public Object get(String key)&#123; lock.readLock().lock(); Object o = null; try &#123; System.out.println(Thread.currentThread().getName()+&quot; 读取开始&quot;); o = map.get(key); System.out.println(Thread.currentThread().getName()+&quot; 读取结束&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.readLock().unlock(); &#125; return o; &#125;&#125; 解释 写入时，用lock.writeLock().lock()锁住写锁；写入结束后，用lock.writeLock().unlock()释放写锁。 读取时，用lock.readLock().lock()锁住读锁；读取结束后，用lock.readLock().unlock()释放读锁。 阻塞队列 BlockingQueue引入Collection结构 和 队列类型介绍 Queue队列分三种： AbstractQueue非阻塞队列 Deque双端队列 BlockingQueue阻塞队列 队列FIFO 先进先出 写入：若队列满了，就必须等待消费； 取：若队列是空的，就必须等待生产； 分类 阻塞队列分两种：LinkedBlockingQueue和ArrayBlockingQueue。 使用场景多线程并发处理，线程池。 API分为四组：抛出异常，不抛出异常有返回值，阻塞等待，超时等待。 方式 抛出异常的API 有返回值不抛出异常的API 阻塞等待的API 超时等待的API 添加 add(对象)无返回值，失败则抛出异常 offer(对象)有返回值,boolean put(对象) offer(对象,超时时间, TimeUnit);例：offer(“a”,2,TimeUnit.SECOND)即：添加”a”，超时2秒。 移除 remove()无返回值，失败则抛出异常 poll()有返回值，null take() poll(超时时间,TimeUnit)例：offer(2,TimeUnit.SECOND)即：移除并返回，若队列空，则阻塞，超时等待2秒。 返回&#x2F;检测 队首元素 element() peek() &#x2F; &#x2F; 代码抛出异常1234567891011121314151617181920212223242526272829303132333435 public static void test1_Exception()&#123; ArrayBlockingQueue&lt;String&gt; queue = new ArrayBlockingQueue&lt;&gt;(2);//容量为2的阻塞队列 //添加 System.out.println(queue.add(&quot;a&quot;)); System.out.println(queue.add(&quot;b&quot;));// System.out.println(queue.add(&quot;c&quot;));//让阻塞队列超出容量 //异常 java.lang.IllegalStateException /** * 输出： * Exception in thread &quot;main&quot; java.lang.IllegalStateException: Queue full // 队列满 * at java.util.AbstractQueue.add(AbstractQueue.java:98) * at java.util.concurrent.ArrayBlockingQueue.add(ArrayBlockingQueue.java:312) * at com.yn.Demo17_BlockingQueue.test1_Exception(Demo17_BlockingQueue.java:19) * at com.yn.Demo17_BlockingQueue.main(Demo17_BlockingQueue.java:9) * true * true */ System.out.println(queue.remove()); System.out.println(queue.remove()); System.out.println(queue.remove());//若队列为空 //异常：java.util.NoSuchElementException 没有元素异常 /** * 输出内容： * a * b * Exception in thread &quot;main&quot; java.util.NoSuchElementException * at java.util.AbstractQueue.remove(AbstractQueue.java:117) * at com.yn.Demo17_BlockingQueue.test1_Exception(Demo17_BlockingQueue.java:35) * at com.yn.Demo17_BlockingQueue.main(Demo17_BlockingQueue.java:9) * * Process finished with exit code 1 */ &#125; 有返回值，不抛出异常123456789101112131415161718192021public static void test2_NoException()&#123; ArrayBlockingQueue&lt;String&gt; blockingQueue = new ArrayBlockingQueue&lt;&gt;(2); //offer() System.out.println(blockingQueue.offer(&quot;a&quot;)); System.out.println(blockingQueue.offer(&quot;b&quot;)); System.out.println(blockingQueue.offer(&quot;c&quot;));//返回boolean，不抛出异常 /** * true * true * false */ System.out.println(blockingQueue.poll()); System.out.println(blockingQueue.poll()); System.out.println(blockingQueue.poll());//若队列为空，则返回null /** * a * b * null */&#125; 等待 阻塞12345678910111213/** * 等待 阻塞 */public static void test3_blocking() throws InterruptedException &#123; ArrayBlockingQueue&lt;String&gt; queue = new ArrayBlockingQueue&lt;&gt;(2); queue.put(&quot;a&quot;);//进入队列 queue.put(&quot;b&quot;); queue.put(&quot;c&quot;);//队列已满，阻塞线程 System.out.println(queue.take());//从队列取出 System.out.println(queue.take()); System.out.println(queue.take());//没有元素 阻塞&#125; 等待阻塞 超时1234567891011121314/** * 等待 超时阻塞 */public static void test4_blocking() throws InterruptedException &#123; ArrayBlockingQueue&lt;String&gt; queue = new ArrayBlockingQueue&lt;&gt;(2); queue.offer(&quot;a&quot;); queue.offer(&quot;b&quot;); queue.offer(&quot;c&quot;,2, TimeUnit.SECONDS);//队列满，阻塞，超时等待2s。 queue.poll(); queue.poll(); queue.poll(2,TimeUnit.SECONDS);//同理&#125; 同步队列 SynchronousQueue容量为1。 API API 说明 put() 添加元素。若队列中有元素，则阻塞，直到队列为空。 take() 取出元素。若队列中没有元素，则阻塞，直到队列不为空。 代码123456789101112131415161718192021222324252627282930313233343536373839404142/** * 同步队列 * SynchronousQueue */public class Demo18_SynchronousQueue &#123; public static void main(String[] args) &#123; BlockingQueue&lt;String&gt; blockingQueue = new SynchronousQueue&lt;&gt;();// 同步队列 new Thread(()-&gt;&#123; try &#123; System.out.println(Thread.currentThread().getName()+&quot; put 1&quot;); blockingQueue.put(&quot;1&quot;); System.out.println(Thread.currentThread().getName()+&quot; put 2&quot;); blockingQueue.put(&quot;2&quot;); System.out.println(Thread.currentThread().getName()+&quot; put 3&quot;); blockingQueue.put(&quot;3&quot;); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;,&quot;T1&quot;).start(); new Thread(()-&gt;&#123; try &#123; TimeUnit.SECONDS.sleep(3); System.out.println(Thread.currentThread().getName()+&quot; &quot;+blockingQueue.take()); TimeUnit.SECONDS.sleep(3); System.out.println(Thread.currentThread().getName()+&quot; &quot;+blockingQueue.take()); TimeUnit.SECONDS.sleep(3); System.out.println(Thread.currentThread().getName()+&quot; &quot;+blockingQueue.take()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;,&quot;T2&quot;).start(); /** * T1 put 1 * T2 1 * T1 put 2 * T2 2 * T1 put 3 * T2 3 */ &#125;&#125; 线程池池化技术。线程池、连接池、内存池、对象池…………………….. 三大方法、7大参数、4种拒绝策略 好处 降低资源的消耗 提高响应的速度 方便管理 作用 线程复用 可以控制最大并发数 管理线程 三大方法Executors工具类有三个方法创建线程池。 1234567891011121314151617181920// Executors 工具类、3大方法public class Demo19_ThreadPool &#123; public static void main(String[] args) &#123;// ExecutorService threadPool = Executors.newSingleThreadExecutor();//创建一个只有一个线程的线程池// ExecutorService threadPool = Executors.newFixedThreadPool(5);//创建一个有5个线程的线程池 ExecutorService threadPool = Executors.newCachedThreadPool();//创建一个可伸缩的线程池 try &#123; for (int i = 0; i &lt; 10; i++) &#123; threadPool.execute(()-&gt;&#123; System.out.println(Thread.currentThread().getName()+&quot; ok&quot;); &#125;); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; threadPool.shutdown(); &#125; &#125;&#125; Exectors的部分API API 介绍 newSingleThreadExecutor() 创建一个有一个线程的线程池。 newFixedThreadPool(int) 创建一个指定数量的线程的线程池。 newCachedThreadPool() 创建一个可伸缩的线程池。 … … 七大参数引入 三个方法的源码分析 12345678910111213141516171819public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, //核心线程数和最大线程数为1 0L, TimeUnit.MILLISECONDS, // new LinkedBlockingQueue&lt;Runnable&gt;()));&#125;public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads,//核心线程数和最大线程数为nThreads 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125;public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE,//核心线程数为0，和最大线程数为Intger.MAX_VALUE 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125; 分析得知：都来源于ThreadPoolExecutor的构造方法。 ThreadPoolExecutor的构造方法 12345678910111213141516171819202122232425public ThreadPoolExecutor(int corePoolSize, //核心线程池大小 int maximumPoolSize,//最大线程池大小 long keepAliveTime,//超时释放时间 TimeUnit unit,//超时释放时间单位 BlockingQueue&lt;Runnable&gt; workQueue,//阻塞队列 ThreadFactory threadFactory,//线程工厂 RejectedExecutionHandler handler//拒绝策略 ) &#123; if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.acc = System.getSecurityManager() == null ? null : AccessController.getContext(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler;&#125; 构造方法的7个参数，即：七大参数。 ThreadPoolExecutor构造方法的七个参数 参数名 介绍 int corePoolSize 核心线程数量 int maximumPoolSize 最大线程数量 long keepAliveTime 超时释放时间 TimeUnit unit 超时释放时间单位 BlockingQueue&lt;Runnable&gt; workQueue 阻塞队列，若线程耗尽，则将新进入的任务放进阻塞队列。线程恢复后，依次为队列里的任务分配线程。 ThreadFactory threadFactory 线程工厂 RejectedExecutionHandler handler 拒绝策略 执行策略 若任务进入，则先分配到核心线程； 若核心线程耗尽，则分配到阻塞队列； 若阻塞队列已满，则创建额外线程，将新来的任务分配给新创建的线程。（而不是将阻塞队列的任务分配给新创建的线程） 若线程达最大数量，且阻塞队列已满，则对新来任务进行拒绝策略。 若额外线程空闲时间达到 keepAliveTime x unit，则释放额外线程。 代码 代码 12345678910111213141516171819202122232425262728293031323334public class Demo20_ThreadPoolExecutor &#123; public static void main(String[] args) &#123; //自定义线程池 ExecutorService threadPool = new ThreadPoolExecutor( 2,//corePoolSize核心线程数 3,//maximumPoolSize最大线程数 3,//keepAliveTime TimeUnit.SECONDS, new LinkedBlockingQueue&lt;&gt;(2), //队列 Executors.defaultThreadFactory(), new ThreadPoolExecutor.AbortPolicy() ); try &#123; for (int i = 1; i &lt;= 10; i++) &#123; final int id = i; System.out.println(Thread.currentThread().getName()+&quot; &quot;+id+&quot; processing...&quot;); threadPool.execute(()-&gt;&#123; try &#123; TimeUnit.SECONDS.sleep(2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+&quot; &quot;+id+&quot; ok&quot;); &#125;); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; threadPool.shutdown(); &#125; &#125;&#125; 输出 12345678910111213141516main 1 processing...main 2 processing...main 3 processing...main 4 processing...main 5 processing...main 6 processing...java.util.concurrent.RejectedExecutionException: Task com.yn.Demo20_ThreadPoolExecutor$$Lambda$1/1096979270@7cca494b rejected from java.util.concurrent.ThreadPoolExecutor@7ba4f24f[Running, pool size = 3, active threads = 3, queued tasks = 2, completed tasks = 0] at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2063) at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:830) at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1379) at com.yn.Demo20_ThreadPoolExecutor.main(Demo20_ThreadPoolExecutor.java:22)pool-1-thread-2 2 okpool-1-thread-1 1 okpool-1-thread-3 5 okpool-1-thread-2 3 okpool-1-thread-3 4 ok 说明 任务1和任务2分配给线程1和线程2； 到任务3和任务4的时候，核心线程已有任务，将任务3和任务4分配到阻塞队列； 到任务5，由于核心线程和阻塞队列都耗尽，开始创建额外线程，并将任务5分配给新创建的线程； 到任务6，由于线程数已达最大，进行拒绝策略：抛出异常（报错），中断主线程。 一些计算题 线程池的最大承载数量 &#x3D; 最大线程数 + 队列长度 四个拒绝策略ThreadPoolExecutor类的四个内部类 类名 介绍（若线程池已达最大承载，在执行execute()方法的线程会发生） ThreadPoolExecutor.AbortPolicy 抛出异常java.util.concurrent.RejectedExecutionException ThreadPoolExecutor.CallerRunsPolicy 任务直接在主线程执行。“你哪来的？回去！” ThreadPoolExecutor.DiscardPolicy 不抛出异常，丢弃任务。“马什么梅？” ThreadPoolExecutor.DiscardOldestPolicy 将等待队列里的最早来的任务丢弃，然后将新来的任务放进等待队列里。 代码 AbortPolicy 在上面 CallerRunsPolicy 1234567891011121314151617181920212223242526272829public class Demo20_ThreadPoolExecutor &#123; public static void main(String[] args) &#123; //自定义线程池 ExecutorService threadPool = new ThreadPoolExecutor( 2,//corePoolSize核心线程数 3,//maximumPoolSize最大线程数 3,//keepAliveTime TimeUnit.SECONDS, new LinkedBlockingQueue&lt;&gt;(2), //队列 Executors.defaultThreadFactory(),// new ThreadPoolExecutor.AbortPolicy() new ThreadPoolExecutor.CallerRunsPolicy() ); try &#123; for (int i = 1; i &lt;= 6; i++) &#123; final int id = i;// System.out.println(Thread.currentThread().getName()+&quot; &quot;+id+&quot; processing...&quot;); threadPool.execute(()-&gt;&#123; System.out.println(Thread.currentThread().getName()+&quot; &quot;+id+&quot; ok&quot;); &#125;); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; threadPool.shutdown(); &#125; &#125;&#125; 123456pool-1-thread-1 1 okpool-1-thread-3 5 okmain 6 okpool-1-thread-2 2 okpool-1-thread-1 3 okpool-1-thread-3 4 ok 任务6直接从main线程执行，未进入线程池。 DiscardPolicy 12345678910111213141516171819202122232425262728public class Demo20_ThreadPoolExecutor &#123; public static void main(String[] args) &#123; //自定义线程池 ExecutorService threadPool = new ThreadPoolExecutor( 2,//corePoolSize核心线程数 3,//maximumPoolSize最大线程数 3,//keepAliveTime TimeUnit.SECONDS, new LinkedBlockingQueue&lt;&gt;(2), //队列 Executors.defaultThreadFactory(), new ThreadPoolExecutor.DiscardPolicy() // 队列满了，丢掉任务，不会抛出异常 ); try &#123; for (int i = 1; i &lt;= 10; i++) &#123; final int id = i;// System.out.println(Thread.currentThread().getName()+&quot; &quot;+id+&quot; processing...&quot;); threadPool.execute(()-&gt;&#123; System.out.println(Thread.currentThread().getName()+&quot; &quot;+id+&quot; ok&quot;); &#125;); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; threadPool.shutdown(); &#125; &#125;&#125; 12345pool-1-thread-1 1 okpool-1-thread-3 5 okpool-1-thread-1 3 okpool-1-thread-2 2 okpool-1-thread-3 4 ok 创建了10个任务，实际运行了前5个，另外5个被抛弃。 DiscardOldestPolicy 123456789101112131415161718192021222324252627282930313233public class Demo20_ThreadPoolExecutor &#123; public static void main(String[] args) &#123; //自定义线程池 ExecutorService threadPool = new ThreadPoolExecutor( 2,//corePoolSize核心线程数 3,//maximumPoolSize最大线程数 3,//keepAliveTime TimeUnit.SECONDS, new LinkedBlockingQueue&lt;&gt;(2), //队列 Executors.defaultThreadFactory(), new ThreadPoolExecutor.DiscardOldestPolicy() // 队列满了，丢弃等待队列里最早的任务，将新来的任务加入到队列中 ); try &#123; for (int i = 1; i &lt;= 10; i++) &#123; final int id = i;// System.out.println(Thread.currentThread().getName()+&quot; &quot;+id+&quot; processing...&quot;); threadPool.execute(()-&gt;&#123; try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+&quot; &quot;+id+&quot; ok&quot;); &#125;); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; threadPool.shutdown(); &#125; &#125;&#125; 12345pool-1-thread-1 1 okpool-1-thread-3 5 okpool-1-thread-2 2 okpool-1-thread-1 9 okpool-1-thread-3 10 ok 任务1,2,5,9,10正常执行。 最大线程数在理论上如何定义 CPU密集型。 CPU密集型：CPU密集型也叫计算密集型，指的是系统的硬盘，内存性能要比CPU好很多，大部分情况是CPU满载，I&#x2F;O占用率不高。 CPU密集：任务需要大量的运算，没有阻塞，CPU一直全速运行。 这类多出现在在开发中的一些业务复杂计算和逻辑处理过程中。 CPU密集任务只有在真正的多核CPU上才能得到加速，而在单核CPU上，不论开几个模拟的线程，任务都不可能得到加速。 CPU密集时，线程数一般只需要设置为CPU核心数的线程个数就可。计算密集型任务的特点是要进行大量的计算，消耗CPU资源。这种计算密集型任务虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低，所以，要最高效地利用CPU，计算密集型任务同时进行的数量应当等于CPU的核心数，避免线程或进程的切换。 Java获取CPU核心数：Runtime().getRuntime().availableProcessors() IO密集型。 IO密集型指的是系统的CPU性能相对硬盘，内存要好很多。此时，系统运作大部分的状况是，CPU在等I&#x2F;O（硬盘&#x2F;内存）的读&#x2F;写操作，CPU负载并不高。 CPU使用率较低，程序中会存在大量的I&#x2F;O操作占用时间，导致线程的空余时间很多，通常就需要开CPU核心数数倍的线程。 计算公式：IO密集型核心线程数 &#x3D; CPU核数 &#x2F; ( 1 - 阻塞系数 ) ​ 阻塞系数 &#x3D; 阻塞时间 &#x2F; (阻塞时间 + 计算时间) 一般取0.8或0.9 当线程进行I&#x2F;O操作CPU空闲时，启动其他线程继续使用CPU，以提高CPU的利用率。 在实际业务中的线程数选择实际业务往往与理论值有所偏差，依据实际情况选择线程数。 “粗调，微调” 粗调 IO密集型两个公式 至2022.9.2为止，目前的我了解到的线程数选择方式有两个公式，两个选一个就好，我认为后者更有道理， 线程数 &#x3D; 2 x 核心数 + 1 核心线程数 &#x3D; CPU核数 &#x2F; ( 1 - 阻塞系数 ) 阻塞系数 &#x3D; 阻塞时间 &#x2F; (阻塞时间 + 计算时间) 一般取0.8或0.9 CPU密集型 线程数 &#x3D; 核心数 + 1 微调 公式面向的是普遍情况，但业务总是千奇百态。 先粗调获得基本线程数，然后使用数据分析（Java可以用jstack），然后根据实际情况调整线程数。 运行程序，采集各种情况下的压力数据，统计分析得到结果。 若CPU多数线程处于等待状态，则说明线程数够用； 若CPU多数线程处于运行状态，可以适当调高线程数量。 一个新奇的想法： 动态线程数，依据情况自动调整线程数。 参考资料https://www.bilibili.com/video/BV1B7411L7tE https://zhuanlan.zhihu.com/p/433310450 https://blog.csdn.net/youanyyou/article/details/78990156 https://www.cnblogs.com/ming-blogs/p/10897242.html https://blog.csdn.net/GmwEnterprise/article/details/103839295","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://zswh33.github.io/tags/Java/"}]},{"title":"Day9 多线程进阶 4 Callable 和 常用的并发用三个辅助类","slug":"Day9-Multithreading2-4","date":"2022-09-01T08:16:59.000Z","updated":"2022-09-02T09:49:42.153Z","comments":true,"path":"2022/09/01/Day9-Multithreading2-4/","link":"","permalink":"http://zswh33.github.io/2022/09/01/Day9-Multithreading2-4/","excerpt":"","text":"CallableCallable创建线程的优势 可以有返回值 可以抛出异常 FutureTask简述 Runnable、FutureTask、Thread和Callable的关系 12new Thread(new FutureTask&lt;V&gt;(new Callable&lt;V&gt;() &#123;...&#125;))new Thread(new Runnable()&#123;...&#125;) 使用Callable 实现Callable接口创建类MyThread，并创建类的对象thread； 使用对象thread创建FutureTask适配类对象futureTask； 使用futureTask对象创建Thread对象并start()，即可使用Callable创建线程； 创建线程后，使用futureTask.get()并cast可以得到返回值。 12345678910111213141516public class Demo12_Callable &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; MyThread thread = new MyThread(); FutureTask futureTask = new FutureTask(thread);//适配类 new Thread(futureTask,&quot;A&quot;).start();//运行线程 String rs = (String) futureTask.get();//获取Callback的返回结果 System.out.println(rs);//输出返回值 &#125;&#125;class MyThread implements Callable&lt;String&gt;&#123; @Override public String call() throws Exception &#123; System.out.println(&quot;call()&quot;); return &quot;这是一个返回值&quot;; &#125;&#125; 其他需要注意的地方 futureTask.get()方法会阻塞线程，因为要等待Callback的返回结果。 解决方法：异步通信。 new Thread(futureTask,&quot;A&quot;).start();的运行结果会被缓存，提高效率。 若同时执行两个这个语句，第二个不会输出。 123456789101112131415161718public class Demo12_Callable &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; new Thread().start(); MyThread thread = new MyThread(); FutureTask futureTask = new FutureTask(thread);//适配类 new Thread(futureTask,&quot;A&quot;).start();//运行线程 new Thread(futureTask,&quot;A&quot;).start();// String rs = (String) futureTask.get();//获取Callback的返回结果 System.out.println(rs);//输出返回值 &#125;&#125;class MyThread implements Callable&lt;String&gt;&#123; @Override public String call() throws Exception &#123; System.out.println(&quot;call()&quot;); return &quot;这是一个返回值&quot;; &#125;&#125; 常用的辅助类 CountDownLatch CyclicBarrier SemaphoreCountDownLatch一个减法计数器 常用方法 方法名 介绍 CountDownLatch(int) 构造方法，参数为计数器的起点。 countDown() 计数器值-1。 await() 阻塞线程，直到计数器归零。 … … 代码 123456789101112131415public class Demo13_CountDownLatch &#123; public static void main(String[] args) throws InterruptedException &#123; // 这里设总数为6 CountDownLatch countDownLatch = new CountDownLatch(6); for (int i = 0; i &lt; 6; i++) &#123; new Thread(()-&gt;&#123; System.out.println(Thread.currentThread().getName()+&quot; come on.&quot;); countDownLatch.countDown(); &#125;,String.valueOf(i)).start(); &#125; countDownLatch.await(); System.out.println(&quot;程序结束&quot;); &#125;&#125; countDownLatch初始值为6。创建6个线程，每个线程都会执行一个countDownLatch.countDown();。然后countDownLatch.await();会阻塞线程，直到countDownLatch归零为止。 CyclicBarrier与CountDownLatch相反，CyclicBarrier是一个加法计数器。 用处 用在协调多个线程同步的场合，所有线程等待完成，然后一起继续下一步。 使用介绍 使用new CyclicBarrier(数量，方法)来创建一个CyclicBarrier对象。 构造方法有两个参数， 第一个参数为一个整数，表示计时器的总数。 第二个参数为Callback接口，使用lambda表达式填充。表示计时器到达指定数量后要进行的操作。 await()方法用在需要协调的线程中，执行该方法： 计数器+1，然后阻塞当前线程。当计数器达到指定值，计数器会唤醒线程，线程继续运行。 为需要协调的多个线程都添加该方法，可以让多个线程协调工作。 代码 12345678910111213141516171819202122public class Demo14_CyclicBarrier &#123; public static void main(String[] args) &#123; /** * Java的寻宝者：在Java中收集到10个华丽宝箱。 */ CyclicBarrier cyclicBarrier = new CyclicBarrier(10,()-&gt;&#123; System.out.println(&quot;获得成就：Java的寻宝者&quot;); &#125;); for (int i = 0; i &lt; 10; i++) &#123; final int temp = i; new Thread(()-&gt;&#123; System.out.println(Thread.currentThread().getName()+&quot;打开了第&quot;+temp+&quot;个华丽宝箱。&quot;); try &#123; cyclicBarrier.await(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;,String.valueOf(i)).start(); &#125; &#125;&#125; Java的寻宝者：在Java中打开10个华丽宝箱 创建10个打开宝箱的线程。线程打开宝箱后，进入await状态，计数器+1，直到计数器计数结束，即所有线程都打开宝箱，然后将进入await的线程全部唤醒，继续运行。 获得成就：Java的寻宝者 Semaphore信号量 一般用来表示资源的可用量。 比如，数据库的最大并发连接数为3。 方法 方法名 介绍 Semaphore(permits) 构造方法。参数为信号量的计数器容量。 acquire() 得到。若Semaphore没有剩余的信号量，则阻塞，等待信号量释放。若有，则信号量减一，继续运行。 release() 释放。释放一个Semaphore的信号量，唤醒等待的线程。 代码 1234567891011121314151617181920public class Demo15_Semaphore &#123; public static void main(String[] args) &#123; //例如：一个数据库的最高并发连接数为3。 Semaphore semaphore = new Semaphore(3);//最高并发连接数 for (int i = 1; i &lt;= 10; i++) &#123; new Thread(()-&gt;&#123; try &#123; semaphore.acquire();//获得 System.out.println(Thread.currentThread().getName()+&quot; 得到一个连接权，连接数据库&quot;); TimeUnit.SECONDS.sleep(1);//模拟数据库操作 System.out.println(Thread.currentThread().getName()+&quot; 操作结束，断开数据库。&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; semaphore.release();//释放 &#125; &#125;,String.valueOf(i)).start(); &#125; &#125;&#125; 使用场景 限流，数据库限制并发数。 多个共享资源互斥的使用！并发限流，控制最大的线程数。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://zswh33.github.io/tags/Java/"}]},{"title":"Day9 多线程进阶 3 集合类不安全","slug":"Day9-Multithreading2-3","date":"2022-09-01T04:05:00.000Z","updated":"2022-09-06T11:51:53.214Z","comments":true,"path":"2022/09/01/Day9-Multithreading2-3/","link":"","permalink":"http://zswh33.github.io/2022/09/01/Day9-Multithreading2-3/","excerpt":"","text":"引入：集合类不安全例：使用多线程操作List&lt;String&gt; 代码 123456789101112public class Demo9_多线程操作字符串ArrayList &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10; i++) &#123; new Thread(()-&gt;&#123; list.add(UUID.randomUUID().toString().substring(0,5));//随机生成一个字符串，添加到list中。 System.out.println(list); &#125;,String.valueOf(i)).start();//线程名为i对应的值 &#125; &#125;&#125; 输出 1234567891011121314151617181920[058ac][058ac, e749b, a5fec][058ac, e749b, a5fec, a8e9a][058ac, e749b, a5fec, a8e9a, 06bae, 09588][058ac, e749b, a5fec, a8e9a, 06bae][058ac, e749b, a5fec, a8e9a, 06bae, 09588, 20884][058ac, e749b, a5fec, a8e9a, 06bae, 09588, 20884, 1edab][058ac, e749b, a5fec, a8e9a, 06bae, 09588, 20884, 1edab, ce3d3][058ac, e749b, a5fec, a8e9a, 06bae, 09588, 20884, 1edab, ce3d3, 86bcf]Exception in thread &quot;2&quot; java.util.ConcurrentModificationException at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:909) at java.util.ArrayList$Itr.next(ArrayList.java:859) at java.util.AbstractCollection.toString(AbstractCollection.java:461) at java.lang.String.valueOf(String.java:2994) at java.io.PrintStream.println(PrintStream.java:821) at com.yn.Demo9_多线程操作字符串ArrayList.lambda$main$0(Demo9_多线程操作字符串ArrayList.java:14) at java.lang.Thread.run(Thread.java:748)Process finished with exit code 0 java.util.ConcurrentModificationException 上面例子中出现了java.util.ConcurrentModificationException异常。 java.util.ConcurrentModificationException异常，即：并发修改异常。 结论：并发下ArrayList 不安全。 解决方案 List&lt;String&gt; list = new Vector&lt;&gt;(); Vector是线程安全的，ArrayList是线程不安全的。 在Vector类下，add()方法带有synchronized修饰；ArrayList下的add()方法没有synchronized修饰。 List&lt;String&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt;()); （ JUC方案 ）List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;(); CopyOnWriteArrayList写入时复制 原理首先把原数组复制一份，然后把要添加的内容添加进新数组，最后将新的数组直接赋值给原引用。 1234567891011121314public boolean add(E e) &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; Object[] elements = getArray(); int len = elements.length; Object[] newElements = Arrays.copyOf(elements, len + 1);//复制数组 newElements[len] = e;//插入 setArray(newElements);//新的数组赋值给原引用 return true; &#125; finally &#123; lock.unlock(); &#125; &#125; 写入时复制 读写分离 CopyOnWriteArrayList 和 VectorCopyOnWriteArrayList效率比Vector高。 Set不安全 例：使用多线程操作Set&lt;String&gt; 代码 1234567891011public class Demo10_多线程操作字符串Set &#123; public static void main(String[] args) &#123; Set&lt;String&gt; set = new HashSet&lt;&gt;(); for (int i = 0; i &lt; 15; i++) &#123; new Thread(()-&gt;&#123; set.add(UUID.randomUUID().toString().substring(0,5)); System.out.println(set); &#125;,String.valueOf(i)).start(); &#125; &#125;&#125; 输出 12345678910111213141516171819202122[1cb01, eb758, aa01b, 9af06, c57bf, 847f3, 2b7e6, e2f07, 96c2f, bc219, b0027][1cb01, eb758, aa01b, 9af06, c57bf, 847f3, 2b7e6, e2f07, 96c2f, bc219, b0027][1cb01, eb758, aa01b, 9af06, c57bf, 847f3, 2b7e6, e2f07, 96c2f, bc219, b0027][1cb01, eb758, aa01b, 9af06, c57bf, 847f3, 2b7e6, e2f07, 96c2f, bc219, b0027][eb758, aa01b, c57bf, 847f3, e2f07, 96c2f, b9460, bc219, 1cb01, 9af06, 2b7e6, b0027, 93907][eb758, aa01b, c57bf, 847f3, e2f07, 96c2f, b9460, bc219, 1cb01, 9af06, 2b7e6, b0027, 93907][1cb01, eb758, aa01b, 9af06, c57bf, 847f3, 2b7e6, e2f07, 96c2f, b9460, bc219, b0027][1cb01, eb758, aa01b, 9af06, c57bf, 847f3, 2b7e6, e2f07, 96c2f, b9460, bc219, b0027][eb758, aa01b, 6e750, c57bf, 847f3, e2f07, 96c2f, b9460, bc219, 1cb01, 9af06, 2b7e6, b0027, 93907][eb758, aa01b, 6e750, c57bf, 847f3, e2f07, 96c2f, b9460, bc219, 1cb01, 9af06, 2b7e6, b0027, 93907][eb758, aa01b, 6e750, c57bf, 847f3, e2f07, 96c2f, b9460, bc219, 1cb01, 9af06, 2b7e6, b0027, 93907][eb758, aa01b, 6e750, c57bf, 847f3, e2f07, 96c2f, b9460, bc219, 1cb01, 9af06, 2b7e6, b0027, 93907][eb758, aa01b, 6e750, c57bf, 847f3, e2f07, 96c2f, b9460, bc219, 1cb01, 9af06, 2b7e6, b0027, 93907][eb758, aa01b, 6e750, c57bf, 847f3, e2f07, 96c2f, b9460, bc219, 1cb01, 9af06, 2b7e6, b0027, 93907]Exception in thread &quot;1&quot; java.util.ConcurrentModificationException at java.util.HashMap$HashIterator.nextNode(HashMap.java:1445) at java.util.HashMap$KeyIterator.next(HashMap.java:1469) at java.util.AbstractCollection.toString(AbstractCollection.java:461) at java.lang.String.valueOf(String.java:2994) at java.io.PrintStream.println(PrintStream.java:821) at com.yn.Demo10_多线程操作字符串Set.lambda$main$0(Demo10_多线程操作字符串Set.java:13) at java.lang.Thread.run(Thread.java:748) 出现了错误java.util.ConcurrentModificationException。 解决方案 Set&lt;String&gt; set = Collections.synchronizedSet(new HashSet&lt;&gt;()); ( JUC方案 ) Set&lt;String&gt; set = new CopyOnWriteArraySet&lt;&gt;(); HashSet底层12345678910public HashSet() &#123; map = new HashMap&lt;&gt;();&#125;//add set的本质是map的key key是无法宠物的public boolean add(E e) &#123; return map.put(e, PRESENT)==null;&#125;private static final Object PRESENT = new Object();//PRESENT是一个常量，是一个不变的值。 HashSet的底层是HashMap。 多线程的HashMap 引入： Map&lt;String,String&gt; map = new HashMap&lt;&gt;(); map是这么用的吗？默认等价于什么？ 不是这样用的。用法：Hole….（挖坑，后续填） 默认等价于new HashMap&lt;&gt;(16,0.75) HashMapHashMap是一个集合，键值对的集合，每个节点用Node&lt;K,V&gt;表示 Node 123456static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; V value; Node&lt;K,V&gt; next;&#125; Node是一个内部类，key为键，value为值，next指向下一个元素。 数据结构 HashMap的数据结构为：数组+（链表或红黑树） 在JDK1.8之前，HashMap的数据结构为“数组 + 链表”，数组是HashMap的主体，链表则是为了解决哈希冲突问题； Jdk1.8之后，当链表长度大于阈值（或者红黑树的边界值，默认为8），并且当前数组长度大于64时，此索引位置上的所有数据改为使用红黑树存储。 注：若链表长度大于64，但数组长度小于64，此时并不会将链表转换为红黑树，而是进行数组扩容。 因为红黑树需要保持平衡，影响效率，为了提高性能和减少搜索时间，当链表长度大于阈值且数组长度大于64时，链表才会转换为红黑树。 HashMap的构造函数 123456789101112public HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(&quot;Illegal load factor: &quot; + loadFactor); this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity);&#125; HashMap有两个参数：initialCapacity 和 loadFactor （初始容量和加载因子） 初始容量是创建时数组分配的容量大小，默认为16； 加载因子 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123;// K 键 V值 onlyIfAbsent evict Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;//tab 为节点头 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else &#123; Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123; for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null; &#125; 例：使用多线程操作Set&lt;String&gt; 代码 1234567891011public class Demo11_多线程操作HashMap &#123; public static void main(String[] args) &#123; Map&lt;String,String&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; 10; i++) &#123; new Thread(()-&gt;&#123; map.put(Thread.currentThread().getName(), UUID.randomUUID().toString().substring(0,5)); System.out.println(map); &#125;,String.valueOf(i)).start(); &#125; &#125;&#125; 输出 12345678910111213141516171819202122232425262728293031323334&#123;0=c16d6, 1=a939d, 3=96525, 4=27c75&#125;&#123;0=c16d6, 1=a939d, 3=96525, 4=27c75, 5=ead0a, 6=a81ee, 7=96a76, 9=ec2fb&#125;&#123;0=c16d6, 1=a939d, 3=96525, 4=27c75, 5=ead0a, 6=a81ee, 9=ec2fb&#125;&#123;0=c16d6, 1=a939d, 3=96525, 4=27c75, 5=ead0a, 9=ec2fb&#125;&#123;0=c16d6, 1=a939d, 3=96525, 4=27c75, 5=ead0a&#125;&#123;0=c16d6, 1=a939d, 3=96525, 4=27c75&#125;&#123;0=c16d6, 1=a939d, 3=96525, 4=27c75, 5=ead0a, 6=a81ee, 7=96a76, 8=78b79, 9=ec2fb&#125;Exception in thread &quot;3&quot; Exception in thread &quot;2&quot; Exception in thread &quot;0&quot; java.util.ConcurrentModificationException at java.util.HashMap$HashIterator.nextNode(HashMap.java:1445) at java.util.HashMap$EntryIterator.next(HashMap.java:1479) at java.util.HashMap$EntryIterator.next(HashMap.java:1477) at java.util.AbstractMap.toString(AbstractMap.java:554) at java.lang.String.valueOf(String.java:2994) at java.io.PrintStream.println(PrintStream.java:821) at com.yn.Demo11_多线程操作HashMap.lambda$main$0(Demo11_多线程操作HashMap.java:13) at java.lang.Thread.run(Thread.java:748)java.util.ConcurrentModificationException at java.util.HashMap$HashIterator.nextNode(HashMap.java:1445) at java.util.HashMap$EntryIterator.next(HashMap.java:1479) at java.util.HashMap$EntryIterator.next(HashMap.java:1477) at java.util.AbstractMap.toString(AbstractMap.java:554) at java.lang.String.valueOf(String.java:2994) at java.io.PrintStream.println(PrintStream.java:821) at com.yn.Demo11_多线程操作HashMap.lambda$main$0(Demo11_多线程操作HashMap.java:13) at java.lang.Thread.run(Thread.java:748)java.util.ConcurrentModificationException at java.util.HashMap$HashIterator.nextNode(HashMap.java:1445) at java.util.HashMap$EntryIterator.next(HashMap.java:1479) at java.util.HashMap$EntryIterator.next(HashMap.java:1477) at java.util.AbstractMap.toString(AbstractMap.java:554) at java.lang.String.valueOf(String.java:2994) at java.io.PrintStream.println(PrintStream.java:821) at com.yn.Demo11_多线程操作HashMap.lambda$main$0(Demo11_多线程操作HashMap.java:13) at java.lang.Thread.run(Thread.java:748) 解决方案 Map&lt;String,String&gt; map = Collections.synchronizedMap(new HashMap&lt;&gt;()); ( JUC方案 ) Map&lt;String,String&gt; map = new ConcurrentHashMap&lt;&gt;(); ConcurrentHashMap 介绍….-&gt; Hole…其他 随机生成字符串 UUID.randomUUID().toString() 可以随机生成字符串，使用substring(0,x)取出其中一部分。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://zswh33.github.io/tags/Java/"}]},{"title":"Day9 多线程进阶 2 八锁现象","slug":"Day9-Multithreading2-2","date":"2022-09-01T01:16:48.000Z","updated":"2022-09-02T09:49:52.101Z","comments":true,"path":"2022/09/01/Day9-Multithreading2-2/","link":"","permalink":"http://zswh33.github.io/2022/09/01/Day9-Multithreading2-2/","excerpt":"","text":"8锁现象（加深synchronized锁的理解）8个关于锁的问题 锁是什么？如何判断锁的是谁！ 对象、Class synchronized若修饰于实例方法，则锁住的是方法的对象。123456789101112131415161718192021222324252627282930313233public class Demo5_synchronized锁住的是方法的对象 &#123; //synchronized锁住的是方法的对象 public static void main(String[] args) throws InterruptedException &#123; Phone phone = new Phone();//对象 new Thread(()-&gt;&#123;phone.sendSms();&#125;,&quot;A&quot;).start(); TimeUnit.SECONDS.sleep(1); new Thread(()-&gt;&#123;phone.call();&#125;,&quot;B&quot;).start(); //结果 /* 发短信 打电话 */ /* 解释：A线程启动后，synchronized锁住了对象phone，B线程启动后，必须等待A线程结束后，才会开始执行。 */ &#125;&#125;class Phone&#123; public synchronized void sendSms() &#123; try &#123; TimeUnit.SECONDS.sleep(5); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;发短信&quot;); &#125; public synchronized void call()&#123; System.out.println(&quot;打电话&quot;); &#125;&#125; 一个对象加锁之后，不影响没有synchronized修饰的方法的正常执行。12345678910111213141516171819202122232425262728293031public class Demo6_synchronized锁住对象后_没有synchronized修饰的方法正常执行 &#123; //synchronized锁住的是方法的对象 public static void main(String[] args) throws InterruptedException &#123; Phone2 phone = new Phone2();//对象 new Thread(()-&gt;&#123;phone.sendSms();&#125;,&quot;A&quot;).start(); TimeUnit.SECONDS.sleep(1); new Thread(()-&gt;&#123;phone.hello();&#125;,&quot;B&quot;).start(); //结果 /* Hello 发短信 */ /* 解释：A线程启动后，synchronized锁住了对象phone，B线程启动后，hello()方法未用synchronized修饰，不受锁的影响，正常执行。 */ &#125;&#125;class Phone2&#123; public synchronized void sendSms() &#123; try &#123; TimeUnit.SECONDS.sleep(5); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;发短信&quot;); &#125; public void hello()&#123;//不用synchronized修饰 System.out.println(&quot;Hello&quot;); &#125;&#125; 两个对象 两个同步方法 互不影响1234567891011121314151617181920212223242526272829303132public class Demo7_synchronized_两个对象两个同步方法 &#123; public static void main(String[] args) throws InterruptedException &#123; Phone3 phone1 = new Phone3(); Phone3 phone2 = new Phone3(); new Thread(()-&gt;&#123;phone1.sendSms();&#125;,&quot;A&quot;).start(); TimeUnit.SECONDS.sleep(1); new Thread(()-&gt;&#123;phone2.call();&#125;,&quot;B&quot;).start(); //结果 /* 打电话 发短信 */ /* 解释：A线程启动后，synchronized锁住了对象phone1，B线程启动后，synchronized锁住了对象phone2，两者互不影响，正常执行。 A线程的sendSms()方法中有sleep，相对输出要比B线程的输出方法要晚。 */ &#125;&#125;class Phone3&#123; public synchronized void sendSms() &#123; try &#123; TimeUnit.SECONDS.sleep(5); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;发短信&quot;); &#125; public synchronized void call()&#123; System.out.println(&quot;打电话&quot;); &#125;&#125; 静态同步方法锁住的是类的Class对象，不影响实例方法的正常执行123456789101112131415161718192021222324252627282930313233343536public class Demo8_静态同步方法锁住的是类的Class对象_不影响实例方法的正常执行 &#123; public static void main(String[] args) throws InterruptedException &#123; Phone4 phone = new Phone4(); new Thread(() -&gt; &#123; phone.sendSms(); &#125;, &quot;A&quot;).start(); TimeUnit.SECONDS.sleep(1); new Thread(() -&gt; &#123; phone.call(); &#125;, &quot;B&quot;).start(); //结果 /* 打电话 发短信 */ /* 解释：A线程启动后，synchronized锁住了类Phone4的Class对象，B线程启动后，synchronized锁住了对象phone，两者互不影响，正常执行。 A线程的sendSms()方法中有sleep，相对输出要比B线程的输出方法要晚。 */ &#125;&#125;class Phone4 &#123; public static synchronized void sendSms() &#123;//静态同步方法 try &#123; TimeUnit.SECONDS.sleep(5); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;发短信&quot;); &#125; public synchronized void call() &#123; System.out.println(&quot;打电话&quot;); &#125;&#125; 小结同步实例方法锁住的是调用者&#x2F;当前对象，会影响当前对象的所有同步实例方法的正常执行。 静态同步实例方法锁住的是类模板对象Class，会影响类的所有类方法的正常执行。 其他 TimeUnit类 设置延迟的类，（用来代替Thread.sleep()） 方法 介绍 TimeUnit.SECONDS.sleep(timeout) 延时，单位：秒 TimeUnit.DAYS.sleep(timeout) 延时，单位：天 TimeUnit.HOURS.sleep(timeout); 延时，单位：小时 … …","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://zswh33.github.io/tags/Java/"}]},{"title":"DayX AllNote 个人全局需要注意的","slug":"DayX-AllNote-个人全局需要注意的","date":"2022-08-31T12:15:28.000Z","updated":"2022-09-15T09:33:29.931Z","comments":true,"path":"2022/08/31/DayX-AllNote-个人全局需要注意的/","link":"","permalink":"http://zswh33.github.io/2022/08/31/DayX-AllNote-%E4%B8%AA%E4%BA%BA%E5%85%A8%E5%B1%80%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84/","excerpt":"","text":"面向工作需要学会的 了解的 个人收集到的 … 从课程视频中得到的 单例模式、八大排序算法、生产者消费者问题、死锁。 基础 泛型、枚举、反射、lambda表达式、链式编程、函数式接口、Stream流式计算。 留下的坑 位于Day9 Multithreading2 3的HashMap不安全下的 Map&lt;String,String&gt; map = new HashMap&lt;&gt;(); map是这么用的吗？默认等价于什么？ ConcurrentHashMap 介绍 位于Day10-Multithreading2 6下的 Stream流式计算，链式编程，ForkJoin. 待完善：异步回调。 位于 Day11-Multithreading2 7 下的 JMM的原子操作的约定。 AtomicInteger原子类。 Volatile的禁止指令重排。 指令重排。 视频里没讲到的，要重新学习的 … 画个饼，万一要学呢？ Dobbo底层Netty 待办完成一个基于SpringBoot的完整的博客项目 有一套自己熟悉的后台模板：x-admin； 前端界面：至少自己能够通过前端框架，组合出来一个网站页面； index about blog post user 让网站独立运行。","categories":[],"tags":[{"name":"Job","slug":"Job","permalink":"http://zswh33.github.io/tags/Job/"}]},{"title":"Day8 Java多线程进阶 1","slug":"Day8-Multithreading2-1","date":"2022-08-31T09:31:48.000Z","updated":"2022-09-01T01:16:25.473Z","comments":true,"path":"2022/08/31/Day8-Multithreading2-1/","link":"","permalink":"http://zswh33.github.io/2022/08/31/Day8-Multithreading2-1/","excerpt":"","text":"JUCjava.util.concurrent 子类介绍java.util.concurrent.atomic 原子性 java.util.concurrent.locks lock锁 在业务中普通的线程代码：Thread Runnable： 没有返回值，效率相对于Callable低。 线程和进程对于Java而言的线程：Thread、Runnable、Callable。 并发和并行 并发（多线程操作同一个资源） CPU一核，模拟出多条线程。天下武功，唯快不破，快速交替。 并行（多个人一起行走） CPU多核，多个线程可以同时执行。线程池 线程有几个状态 六个。 123456NEW,//线程新生RUNNABLE,//运行状态BLOCKED,//阻塞WAITING,//等待TIMED_WAITING,//超时等待TERMINATED;//终止 wait&#x2F;sleep区别 来自不同的类 wait -&gt; Object sleep -&gt; Thread 关于锁的释放 wait 会释放锁 sleep 不会释放锁 使用的范围不同 wait 必须在同步代码块中 sleep 可以在任何地方使用 是否需要捕获异常 wait 不需要捕获异常 sleep 必须要捕获异常 Lock锁synchronized Lock接口以及其实现类 Lock是一个接口，有以下实现类。 ReentrantLock 可重用锁 ReadLock 读锁 WriteLock 写锁 公平锁 非公平锁 公平锁：先来后到。 非公平锁：可以插队。（默认） synchronized 和 Lock 区别 synchronized 内置的Java关键字。 Lock是一个Java类。 synchronized 无法判断获取锁的状态。Lock可以判断是否获取到了锁。 synchronized 会自动释放锁。Lock必须要手动释放锁，若不释放，则会死锁。 synchronized 线程1（获得锁，阻塞），线程2（等待）（悲）。Lock锁不一定会一直等待，可以尝试获取锁。 synchronized 可重入锁，不可中断的，非公平；Lock，可重入锁，可以判断锁，非公平（可以自己设置）。 synchronized 适合锁少量的代码同步问题，Lock适合锁大量的同步代码。 生产者和消费者问题synchronized版本代码：(错误的版本，正确的版本下面) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * 线程之间的通信问题：生产者和消费者问题。 等待唤醒，通知唤醒 * 线程交替执行 * A B 操作同一个变量 num = 0 * */public class Demo3_生产者和消费者 &#123; public static void main(String[] args) &#123; Data data = new Data(); new Thread(()-&gt;&#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; data.increment(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;,&quot;A&quot;).start(); new Thread(()-&gt;&#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; data.decrement(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;,&quot;B&quot;).start(); &#125;&#125;// 判断等待 业务 通知class Data&#123;//资源类 private int number = 0; //+1 public synchronized void increment() throws InterruptedException &#123; if (number!=0)&#123; //等待 this.wait(); &#125; number++; System.out.println(Thread.currentThread().getName()+&quot; -&gt; &quot;+number); //通知其他线程 this.notifyAll(); &#125; // - 1 public synchronized void decrement() throws InterruptedException &#123; if(number==0)&#123; //等待 this.wait(); &#125; number--; //通知其他线程 System.out.println(Thread.currentThread().getName()+&quot; -&gt; &quot;+number); this.notifyAll(); &#125;&#125; 出现问题：两个线程正常运行 四个线程出现问题。 虚假唤醒。 当出现超过两个线程，就会出现虚假唤醒。 当一个生产者生产结束后，会唤醒其他所有消费者，导致消费者全部开始消费，若消费者多于1个，会出现多次消费，导致错误。 为解决这个问题，可以将if换成while，来防止虚假唤醒。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * 线程之间的通信问题：生产者和消费者问题。 等待唤醒，通知唤醒 * 线程交替执行 * A B 操作同一个变量 num = 0 * */public class Demo3_生产者和消费者 &#123; public static void main(String[] args) &#123; Data data = new Data(); new Thread(()-&gt;&#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; data.increment(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;,&quot;A&quot;).start(); new Thread(()-&gt;&#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; data.decrement(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;,&quot;B&quot;).start(); &#125;&#125;// 判断等待 业务 通知class Data&#123;//资源类 private int number = 0; //+1 public synchronized void increment() throws InterruptedException &#123; while (number!=0)&#123; //等待 this.wait(); &#125; number++; System.out.println(Thread.currentThread().getName()+&quot; -&gt; &quot;+number); //通知其他线程 this.notifyAll(); &#125; // - 1 public synchronized void decrement() throws InterruptedException &#123; while(number==0)&#123; //等待 this.wait(); &#125; number--; //通知其他线程 System.out.println(Thread.currentThread().getName()+&quot; -&gt; &quot;+number); this.notifyAll(); &#125;&#125; JUC版生产者和消费者问题 Lock用来替代synchronized的名词 代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public class Demo3_生产者和消费者JUC版 &#123; public static void main(String[] args) &#123; Data2 data = new Data2(); new Thread(()-&gt;&#123; for (int i = 0; i &lt; 10; i++) &#123; data.increment(); &#125; &#125;,&quot;A&quot;).start(); new Thread(()-&gt;&#123; for (int i = 0; i &lt; 10; i++) &#123; data.increment(); &#125; &#125;,&quot;B&quot;).start(); new Thread(()-&gt;&#123; for (int i = 0; i &lt; 10; i++) &#123; data.decrement(); &#125; &#125;,&quot;C&quot;).start(); new Thread(()-&gt;&#123; for (int i = 0; i &lt; 10; i++) &#123; data.decrement(); &#125; &#125;,&quot;D&quot;).start(); &#125;&#125;// 判断等待 业务 通知class Data2&#123;//资源类 private int number = 0; Lock lock = new ReentrantLock(); Condition condition = lock.newCondition();// condition.await();//等待// condition.signalAll();//唤醒全部 //+1 public void increment() &#123; lock.lock(); try &#123; //业务代码 while (number!=0)&#123; condition.await(); &#125; number++; condition.signalAll(); System.out.println(Thread.currentThread().getName()+&quot; =&gt; &quot;+number); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; // - 1 public void decrement() &#123; lock.lock(); try &#123; while (number==0)&#123; //等待 condition.await(); &#125; number--; //通知 condition.signalAll(); System.out.println(Thread.currentThread().getName()+&quot; =&gt; &quot;+number); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; Condition精准通知唤醒12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485/** * 当前需求：A执行完通知B，B执行完通知C，C执行完通知A。 */public class Demo4_通过生产者消费者问题学习Condition精准通知 &#123; public static void main(String[] args) &#123; Data3 data = new Data3(); new Thread(()-&gt;&#123; for (int i = 0; i &lt; 10; i++) &#123; data.printA(); &#125; &#125;,&quot;A&quot;).start(); new Thread(()-&gt;&#123; for (int i = 0; i &lt; 10; i++) &#123; data.printB(); &#125; &#125;,&quot;B&quot;).start(); new Thread(()-&gt;&#123; for (int i = 0; i &lt; 10; i++) &#123; data.printC(); &#125; &#125;,&quot;C&quot;).start(); &#125;&#125;class Data3&#123;//资源类 private Lock lock = new ReentrantLock(); private Condition condition1 = lock.newCondition(); private Condition condition2 = lock.newCondition(); private Condition condition3 = lock.newCondition(); private int number = 1; // 1 A 2 B 3 C public void printA()&#123; lock.lock(); try &#123; //业务 判断 &gt; 执行 &gt; 通知 while (number!=1)&#123; //等待 condition1.await(); &#125; System.out.println(Thread.currentThread().getName()+&quot; A&quot;); //唤醒B number = 2; condition2.signal(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; public void printB()&#123; lock.lock(); try &#123; //业务 判断 &gt; 执行 &gt; 通知 while (number!=2)&#123; condition2.await(); &#125; System.out.println(Thread.currentThread().getName()+&quot; B&quot;); number = 3; condition3.signal(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; public void printC()&#123; lock.lock(); try &#123; //业务 判断 &gt; 执行 &gt; 通知 while (number != 3) &#123; condition3.await(); &#125; System.out.println(Thread.currentThread().getName()+&quot; C&quot;); number = 1; condition1.signal(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125;&#125; 其他 native 本地方法。 获取CPU核数方法 123//获取CPU核数// CPU 密集型，IO密集型System.out.println(Runtime.getRuntime().availableProcessors()); 并发编程的本质：充分利用CPU的资源 一些问题Q：Java默认有几个线程？ A：2个。main和GC。 Q： Java可以开启线程吗？ A：不可以。通过分析new Thread().start()，可以得到一个native方法private native void start0();，这个方法是个本地方法，调用的是底层的C++。Java不能直接操作硬件。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://zswh33.github.io/tags/Java/"}]},{"title":"Day8 反射机制 2","slug":"Day8-Reflection-2","date":"2022-08-31T07:26:30.000Z","updated":"2022-08-31T09:15:24.522Z","comments":true,"path":"2022/08/31/Day8-Reflection-2/","link":"","permalink":"http://zswh33.github.io/2022/08/31/Day8-Reflection-2/","excerpt":"","text":"Java Reflection 反射机制2获取运行时类的对象的属性Class类的方法 方法名 介绍 参数 getName() 获得类的全名，包括包。如：com.uwupu.User getSimpleName() 获得类的名字。如：User getFields() 获取类的public属性。 getDeclaredFields() 获得类的所有属性。 getDeclaredField(param) 通过名字获得类的属性 属性的名字 getDeclaredConstructors() 获得类的所有的构造器 getConstructors() 获得类的public的构造器 getConstructor(param) 通过构造器的参数获得类的构造器 构造器的参数 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class Test &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, NoSuchMethodException &#123; Class c1 = Class.forName(&quot;Demo2_Reflection.User&quot;);//引用一个之前用过的类 //获得类的名字 System.out.println(c1.getName());//获得包名和类名 System.out.println(c1.getSimpleName());//获得类名 /* Demo2_Reflection.User User */ //获得类的属性 System.out.println(&quot;------------------&quot;); Field[] fields = c1.getFields();//仅为public的属性 for (Field f : fields)&#123; System.out.println(f); &#125; System.out.println(&quot;------------------&quot;); fields = c1.getDeclaredFields();//全部的属性 for (Field f : fields)&#123; System.out.println(f); &#125; /* ------------------ public int Demo2_Reflection.User.length ------------------ private java.lang.String Demo2_Reflection.User.name private int Demo2_Reflection.User.id private int Demo2_Reflection.User.age public int Demo2_Reflection.User.length */ //获得指定属性 Field name = c1.getDeclaredField(&quot;name&quot;); System.out.println(name);//private java.lang.String Demo2_Reflection.User.name //获得类的方法 Method[] methods = c1.getMethods();//获得本类及其父类的public方法。 for (Method method : methods) &#123; System.out.println(&quot;getMethods：&quot;+method); &#125; methods = c1.getDeclaredMethods();//获得本类及其父类的所有方法 for (Method method : methods) &#123; System.out.println(&quot;getDeclaredMethods：&quot;+method); &#125; //获得指定方法 Method getMethod = c1.getMethod(&quot;getName&quot;); Method setMethod = c1.getMethod(&quot;setName&quot;,String.class);//后面的参数用于筛选方法重载时的多个方法。 System.out.println(getMethod);//public java.lang.String Demo2_Reflection.User.getName() System.out.println(setMethod);//public void Demo2_Reflection.User.setName(java.lang.String) //获得指定的构造器 Constructor[] constructors = c1.getDeclaredConstructors(); for (Constructor constructor : constructors) &#123; System.out.println(constructor); &#125; constructors = c1.getConstructors(); for (Constructor constructor : constructors) &#123; System.out.println(constructor); &#125; /* public Demo2_Reflection.User() public Demo2_Reflection.User(java.lang.String,int,int) */ Constructor constructor = c1.getConstructor(String.class,int.class,int.class); System.out.println(constructor);//public Demo2_Reflection.User(java.lang.String,int,int) &#125;&#125; 对Class对象进行一些操作创建类的对象：方法1：调用Class对象的newInstance()方法。 类必须有一个无参构造器； 需要足够的类的构造器访问权限。 代码： 12345678910public class Demo8_通过Class对象对类进行一些操作 &#123; public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException &#123; //获得Class对象 Class c1 = Class.forName(&quot;Demo2_Reflection.User&quot;); //构造一个对象 User user = (User)c1.newInstance();//本质上调用了类的无参构造器。若没有无参构造器，会报错。 System.out.println(user); //User&#123;name=&#x27;null&#x27;, id=0, age=0&#125; &#125;&#125; 方法2：1234567891011public class Demo8_通过Class对象对类进行一些操作 &#123; public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException &#123; //获得Class对象 Class c1 = Class.forName(&quot;Demo2_Reflection.User&quot;); //通过构造器创建对象 Constructor constructor = c1.getDeclaredConstructor(String.class,int.class,int.class); User user2 = (User) constructor.newInstance(&quot;张三&quot;,1,22); System.out.println(user2); //User&#123;name=&#x27;张三&#x27;, id=1, age=22&#125; &#125;&#125; 通过反射操作方法Invoke 可以操作方法，参数1为操作的对象，后面的参数为方法的参数。 返回值为原方法的返回值。 代码 1234567891011121314151617public class Demo8_通过Class对象对类进行一些操作 &#123; public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException &#123; //获得Class对象 Class c1 = Class.forName(&quot;Demo2_Reflection.User&quot;); //通过构造器创建对象 Constructor constructor = c1.getDeclaredConstructor(String.class,int.class,int.class); User user2 = (User) constructor.newInstance(&quot;张三&quot;,1,22); System.out.println(user2); //通过反射调用普通方法 //通过反射获取一个方法 Method setName = c1.getDeclaredMethod(&quot;setName&quot;,String.class); setName.invoke(user2,&quot;李四&quot;); System.out.println(user2); &#125;&#125; 12User&#123;name=&#x27;张三&#x27;, id=1, age=22&#125;User&#123;name=&#x27;李四&#x27;, id=1, age=22&#125; 通过反射操作属性代码 1234567891011121314151617181920public class Demo8_通过Class对象对类进行一些操作 &#123; public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException &#123; //获得Class对象 Class c1 = Class.forName(&quot;Demo2_Reflection.User&quot;); //通过构造器创建对象 Constructor constructor = c1.getDeclaredConstructor(String.class,int.class,int.class); User user2 = (User) constructor.newInstance(&quot;张三&quot;,1,22); System.out.println(user2); //通过反射操作属性 //不能直接操作私有属性，通过setAccessible方法关掉权限监测。 Field name = c1.getDeclaredField(&quot;name&quot;); name.setAccessible(true);//关掉权限监测 name.set(user2,&quot;王五&quot;);//直接操作权限不够 name属性为private System.out.println(user2); &#125;&#125; 12User&#123;name=&#x27;李四&#x27;, id=1, age=22&#125;User&#123;name=&#x27;王五&#x27;, id=1, age=22&#125; 注意 若要”使用Field的set方法操作属性“或“使用invoke方法操作原方法”，若属性或方法用private修饰，则不能直接操作，需要用setAccessible(true)方法关掉权限监测，才可直接操作。 setAccessible Method、Field和Constructor对象都有setAccessible()方法； **setAccessible**作用是启动和禁用访问安全检查的开关。 参数为true表示关闭反射对象的访问检查。默认为false。 可以提高反射效率。若代码中必须使用反射，且该句代码需要频繁地被调用，请一定设置为true。 获取泛型信息Java采用泛型擦除的机制来引入泛型，Java中的泛型仅仅是给编译器javac使用的，确保数据的安全性和免去强制类型转换问题。一旦编译完成，所有和泛型有关的类型全部擦除。 为了通过反射操作这些类型，Java新增了集中类型来代表不能归一到Class类中的类型但是又和原始类型齐名的类型。 类型名 描述 ParameterizedType 表示一种参数化类型，如Collection&lt;String&gt; GenericArrayType 表示一种元素类型是参数化类型或者类型变量的数组类型。 TypeVariable 是各种类型变量的公共父接口。 WildcardType 代表一种通配符类型表达式。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940public class Test9 &#123; public void test01(Map&lt;String, User&gt; map, List&lt;User&gt; list)&#123; System.out.println(&quot;test01&quot;); &#125; public Map&lt;String,User&gt; test02()&#123; System.out.println(&quot;test02&quot;); return null; &#125; public static void main(String[] args) throws NoSuchMethodException &#123; Method method = Test9.class.getMethod(&quot;test01&quot;,Map.class,List.class); //获得参数是泛型 //Generic 泛型 Type[] types = method.getGenericParameterTypes();//获得参数类型列表 for (Type type : types)&#123; System.out.println(&quot;# &quot;+type); if(type instanceof ParameterizedType)&#123; Type[] type2 =((ParameterizedType) type).getActualTypeArguments();//获得真实参数信息 获得参数的泛型参数列表 for (Type type3 :type2)&#123; System.out.println(type3); &#125; &#125; &#125; System.out.println(&quot;--------------------------------&quot;); //获得返回值是泛型的参数 method = Test9.class.getMethod(&quot;test02&quot;); Type returnType = method.getGenericReturnType(); System.out.println(&quot;# &quot;+returnType); if(returnType instanceof ParameterizedType)&#123; Type[] type2 =((ParameterizedType) returnType).getActualTypeArguments();//获得真实参数信息 获得参数的泛型参数列表 for (Type type3 :type2)&#123; System.out.println(type3); &#125; &#125; &#125;&#125; 获取注解信息ORM Object relationship Mapping -&gt; 对象关系映射 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class Demo10_通过反射获得注解 &#123; public static void main(String[] args) throws Exception &#123; //获取类 Class c1 = Class.forName(&quot;MyClass&quot;); //获取类的注解的值 MyAnnotation classAnnotation = (MyAnnotation) c1.getAnnotation(MyAnnotation.class);//获取注解对象 System.out.println(classAnnotation);//输出 System.out.println( &quot;id: &quot; + classAnnotation.id() + &quot; name: &quot; +classAnnotation.name() );//获取注解的值 //获取属性的注解的值 Field field = c1.getField(&quot;id&quot;); MyAnnotation myAnnoation = field.getAnnotation(MyAnnotation.class); System.out.println(myAnnoation); System.out.println( &quot;id: &quot; + myAnnoation.id() + &quot; name: &quot; +myAnnoation.name() ); //获取方法的注解的值 Method method = c1.getMethod(&quot;int2String&quot;, int.class); MyAnnotation methodAnnoation = method.getAnnotation(MyAnnotation.class); System.out.println(methodAnnoation); System.out.println( &quot;id: &quot; + methodAnnoation.id() + &quot; name: &quot; +methodAnnoation.name() ); &#125;&#125;//一个类@MyAnnotation(name = &quot;MyClass&quot;,id = 1)class MyClass&#123; @MyAnnotation(name = &quot;id&quot;,id = 2) public int id;//一个属性 //一个方法 @MyAnnotation(name = &quot;int2String&quot;,id = 3) public String int2String(int value)&#123; return String.valueOf(value); &#125;&#125;//声明注解//一个Target可以是属性，类或方法的注解@Target(&#123;ElementType.FIELD,ElementType.TYPE,ElementType.METHOD&#125;)@Retention(RetentionPolicy.RUNTIME)@interface MyAnnotation&#123; String name(); int id();&#125; 123456@MyAnnoation(name=MyClass, id=1)id: 1 name: MyClass@MyAnnoation(name=id, id=2)id: 2 name: id@MyAnnoation(name=int2String, id=3)id: 3 name: int2String","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://zswh33.github.io/tags/Java/"}]},{"title":"Day8 Reflection 反射机制","slug":"Day8-Reflection","date":"2022-08-31T01:29:04.000Z","updated":"2022-08-31T09:18:42.658Z","comments":true,"path":"2022/08/31/Day8-Reflection/","link":"","permalink":"http://zswh33.github.io/2022/08/31/Day8-Reflection/","excerpt":"","text":"Java Reflection 反射机制静态语言 动态语言动态语言是一类在运行时可以改变其结构的语言。 即：在运行时代码可以根据某些条件改变自身结构。 主要动态语言：Object-C、C#、JavaScript、PHP、Python等。 静态语言运行时结构不可变的语言就是静态语言，如Java，C，C++。 Java不是动态语言，但可以称为“准动态语言”。可以通过反射机制获得类似动态语言的特性。 Java ReflectionReflection反射机制允许程序在执行期间借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。 1Class c = Class.forName(&quot;java.lang.String&quot;) 加载完类之后，在堆内存的方法区就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象就包含了完整的类的结构信息。通过这个对象可以看到类的结构。 透过这个对象看到类结构的过程，称为反射。 功能在运行时： 判断任意一个对象所属的类； 构造任意一个类的对象； 判断任意一个类所具有的成员变量和方法； 获取泛型信息； 调用任意一个对象的成员变量和方法； 处理注解； 生产动态代理； … 优点 缺点优点：可以实现动态创建对象和编译； 缺点：这类操作慢于直接执行的操作。 主要API java.lang.Class 代表一个类 java.lang.Method 代表类的方法 java.lang.Field 代表类的成员变量 java.lang.Constructor 代表类的构造器 …… 1234567891011121314151617181920212223public class Test1 &#123; public static void main(String[] args) throws ClassNotFoundException &#123; //通过反射获取类的class对象 Class c1 = Class.forName(&quot;Demo2_Reflection.User&quot;); System.out.println(c1);//获取类 Class c2 = Class.forName(&quot;Demo2_Reflection.User&quot;); System.out.println(c1==c2);//true 每个类只有一个Class对象 Method[] methods = c1.getMethods();//获取类的方法 for (Method i : methods)&#123; System.out.println(i.getName()); &#125; /* toString getName getId ... */ &#125;&#125;//一个实体类 ： 一般用POJO或entity表示class User&#123;...&#125;//getter setter constructor ... Class类Class是Java的一个类。 Class对象只能由系统建立对象。 一个加载的类在JVM中只会有一个Class实例； 一个Class对象对应的是一个加载到JVM中的一个class文件； 通过Class可以完整地得到一个类中的所有被加载的结构。 常用方法 方法名 功能 static ClassforName(String name) 返回指定类名name的Class对象 Object newInstance() 调用缺省构造函数，返回Class对象的一个实例。 getName() 返回Class对象表示的实体的名称 Class getSuperClass() 返回当前Class对象分类的Class对象。 Class[] getinterfaces() 获取当前Class对象的接口 ClassLoader getClassLoader() 返回该类的类加载器 Constructor[] getConstructors() 返回一个包含某些Constructor对象的数组。 Method getMethod(String name,Class ... T) 返回Method对象，形参类型为paramType Field[] getDeclaredFiedlds() 返回Field对象的一个数组 获取Class对象123456789101112131415161718public class Demo3_CreateClass &#123; public static void main(String[] args) throws ClassNotFoundException &#123; User2 user2 = new User2(); //1. 通过对象获得 Class c1 = user2.getClass(); //2. 通过forname获得 Class c2 = Class.forName(&quot;User2&quot;); //3. 通过类名.class获得 Class c3 = User2.class; //获取父类类型 Class c4 = c1.getSuperclass(); System.out.println(c4);//class java.lang.Object &#125;&#125; 哪些类型可以有Class对象 class：外部类，成员，局部内部类，匿名内部类； interface接口 []数组 enum枚举 annotation注解@interface void 12345678910111213public class Demo4_ClassFromWhere &#123; public static void main(String[] args) &#123; Class c1 = Object.class;//类 Class c2 = Comparable.class;//接口 Class c3 = String[].class;//数组 Class c4 = int[][].class;//二维数组 Class c5 = Override.class;//注解 Class c6 = ElementType.class; //枚举 Class c7 = Integer.class; // 基本数据类型 Class c8 = void.class;//void Class c9 = Class.class; //Class对象 &#125;&#125; Java内存分析类的加载过程 序号 过程 解释 1 类的加载Load 将类的class文件读入内存，并为之创建一个java.lang.Class对象。这个过程由类加载器完成。 2 类的链接Link 将类的二进制数据合并到JVM中。 3 类的初始化Initialize JVM负责对类进行初始化。 链接 过程 验证：确保加载的类信息符合JVM规范，没有安全方面问题； 准备：为类变量static分配内存并设置类变量默认初始值的阶段，这些内存都将在方法区中分配； 解析：虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程。 类初始化顺序代码1234567891011121314151617181920212223public class Demo5_初始化顺序 &#123; public static void main(String[] args) &#123; System.out.println(&quot;程序开始&quot;); AClass aClass = new AClass(); System.out.println(&quot;程序结束&quot;); /* 运行结果： 程序开始 类代码块初始化 无参构造初始化 程序结束 */ &#125;&#125;class AClass&#123; static &#123; System.out.println(&quot;类代码块初始化&quot;); &#125; public AClass()&#123; System.out.println(&quot;无参构造初始化&quot;); &#125;&#125; 初始化顺序 代码212345678910111213141516171819202122public class Test &#123; static&#123; System.out.println(&quot;main方法所在类被加载&quot;); &#125; public static void main(String[] args) throws ClassNotFoundException &#123; //主动引用：new Son son = new Son(); &#125;&#125;class Father&#123; static &#123; System.out.println(&quot;父类被加载&quot;); &#125;&#125;class Son extends Father&#123; static &#123; System.out.println(&quot;子类被加载&quot;); m = 300; &#125; static int m = 100; static final int M = 1;&#125; 输出 123main方法所在类被加载父类被加载子类被加载 初始化 过程 即，执行构造器&lt;clinit&gt;方法的过程。 &lt;clinit&gt;类构造器&lt;clinit&gt;()方法是由编译器自动收集类中所有类变量的赋值动作和静态代码块中的语句合并产生的。（类构造器用来构造类信息，而不是用来构造该类对象的构造器） 虚拟机会保证一个类的&lt;clinit&gt;()方法在多线程环境中被正确加锁和同步。 类的初始化 当发生类的主动引用，则一定会发生类的初始化。 当虚拟机启动，先初始化main方法所在的类。 new一个类的对象。（new一个类的数组不计入。） 调用类的静态成员和静态方法（除了final常量） 使用java.lang.reflect包的方法对类进行反射调用。 当初始化一个类，如果其父类没有被初始化，则先会初始化它的父类。 类的被动引用，不会发生类的初始化 当访问一个静态域时，只有真正声明这个域的类才会被初始化。 如：当通过子类引用父类的静态变量，不会导致子类初始化。 通过数组定义类引用，不会触发此类的初始化。 引用常量不会触发此类的初始化（常量在链接阶段就存入调用类的常量池中） 12int a = Son.M;//引用常量Son[] array = new Son[5];//new一个数组，不引发初始化 类加载器类加载：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后在堆中生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口。 类缓存：标准的JavaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，将维持加载（缓存）一段时间。 JVM垃圾回收机制可以回收这些Class对象 类加载器分类引导类加载器：用C++编写，是JVM自带的类加载器，负责Java平台核心库，用来装载核心类库。该加载器无法直接获取。Bootstap Classloader 扩展类加载器：负责jre/lib/ext目录下的jar包或-D java.ext.dirs指定目录下的jar包装入工作库。Extension Classloader、ExtClassLoader 系统类加载器：负责java --classpath或--D java.class.path所指目录下的类与jar包装入工作，是最常用的类加载器。System Classloader、 AppClassLoader 注释：Java平台核心库，即rt.jar包。文件位置：jre&#x2F;lib&#x2F;rt.jar（内含有如：java.lang.*等类的字节码文件。） 代码查看12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Demo6_系统类的加载器 &#123; public static void main(String[] args) throws ClassNotFoundException &#123; //获取系统类的加载器 ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader(); System.out.println(&quot;系统类加载器： &quot;+systemClassLoader); //获取系统类加载器的父类加载器-&gt;扩展类加载器 ClassLoader parent = systemClassLoader.getParent(); System.out.println(&quot;系统类加载器的父类扩展类加载器： &quot;+parent); //获取扩展类加载器的父类加载器 -&gt; 根加载器(c/c++) ClassLoader parent2 = parent.getParent(); System.out.println(&quot;扩展类加载器的父类根加载器：&quot;+parent2); //当前类是哪个加载器加载的 ClassLoader classLoader = Class.forName(&quot;Demo6_系统类的加载器&quot;).getClassLoader(); System.out.println(&quot;自定义类的加载器： &quot;+classLoader); //JDK内置类是哪个加载器加载的 ClassLoader classLoader2 = Class.forName(&quot;java.lang.Object&quot;).getClassLoader(); System.out.println(&quot;JDK内置类的类加载器： &quot;+classLoader2); /* 系统类加载器： sun.misc.Launcher$AppClassLoader@18b4aac2 系统类加载器的父类扩展类加载器： sun.misc.Launcher$ExtClassLoader@1b6d3586 扩展类加载器的父类根加载器：null //根加载器不能直接获得 自定义类的加载器： sun.misc.Launcher$AppClassLoader@18b4aac2 JDK内置类的类加载器： null */ //获得系统类加载器可以加载的路径 System.out.println(System.getProperty(&quot;java.class.path&quot;)); /* D:\\AboutProgram\\Env\\jdk1.8.0_202\\jre\\lib\\charsets.jar; D:\\AboutProgram\\Env\\jdk1.8.0_202\\jre\\lib\\deploy.jar; ... D:\\AboutProgram\\Env\\jdk1.8.0_202\\jre\\lib\\resources.jar; D:\\AboutProgram\\Env\\jdk1.8.0_202\\jre\\lib\\rt.jar; //这个是rt.jar D:\\ uwupu\\ideaProject\\Java反射\\out\\production\\Java反射; //项目 D:\\Software\\IntelliJ IDEA 2021.2.2\\lib\\idea_rt.jar //idea_rt.jar包 */ &#125;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://zswh33.github.io/tags/Java/"}]},{"title":"Day7 Java 注解","slug":"Day7-Java-Annotation-1","date":"2022-08-30T14:19:55.000Z","updated":"2022-08-31T01:30:51.358Z","comments":true,"path":"2022/08/30/Day7-Java-Annotation-1/","link":"","permalink":"http://zswh33.github.io/2022/08/30/Day7-Java-Annotation-1/","excerpt":"","text":"Annotation注解Annotation是JDK5.0引入的技术 作用 对程序进行解释 可以被编译器读取 格式 以“@注释名”在代码中存在，也可以添加一些参数值， 如：@SuppressWarnings(value&#x3D;”unchecked”) @Override 重写方法的注解 &#96;&#96;&#96;javaclass MyThread implements Runnable{ @Override//注解 public void run() &#123; &#125; } 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556## 一些内置注解- @Override，java.lang.Override。表示一个方法声明打算重写超累中另一个方法声明。- @Deprecated，java.lang.Deprecated。表示不鼓励程序员使用这样的元素或者有更好的方式，但是可以使用。- @SuppressWarnings，java.lang.SuppressWarnings。用来抑制编译时的警告信息。 - 参数： - @SuppressWarnings(&quot;all&quot;) - 等...## 元注解作用：负责注解其他注解。Java顶一个4个标准的meta-annotation，用来提供对其他annotation类型做说明。位于`java.lang.annotation`有以下几种：- @Target 用于描述注解的使用范围。（被描述的注解可以用在什么地方）- @Retention：表示需要在什么级别保存该注释信息，用于描述注解的生命周期。 - （SOURCE &lt; CLASS &lt; RUNTIME）- @Document：说明该注解将被包含在Javadoc中。- @Inherited：说明子类可以继承父类中的该注解。示例：```java@MyAnnoation//类 TYPEpublic class Demo2_MetaAnnoation &#123; @MyAnnoation //方法 METHOD public void Test()&#123; @MyAnnoation int a;//局部变量 LOCAL_VARIABLE &#125;&#125;//定义一个注解//可以用在 类，方法，局部变量中@Target(value = &#123;ElementType.TYPE,ElementType.METHOD,ElementType.LOCAL_VARIABLE&#125;)//表示注解在什么地方有效//运行时@Retention(value = RetentionPolicy.RUNTIME)// 出现在JavaDoc中@Documented//子类可以继承父类的注解@Inherited@interface MyAnnoation&#123;&#125; 自定义注解使用@interface自定义注解，自动继承java.lang.Annotation接口 格式：public @interface 注解名{定义内容} 定义内容中一个方法指一个配置参数。 返回值类型就是参数的类型，只能是Class，String，enum。 可以通过default来声明参数的默认值。 注解元素必须要有值。 只有一个值时，一般用value()表示。 123456789101112131415161718192021222324252627public class Demo3_CustomAnnotation &#123; @MyAnnotation2(name = &quot;zhangsan&quot;,//name为zhangsan。参数age有默认值，可以不写。 say = &#123;&quot;小张&quot;,&quot;小兰&quot;&#125;//可以有数组 ) @MyAnnotation3(&quot;只有一个参数&quot;) public void test()&#123; &#125;&#125;@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)@Retention(RetentionPolicy.RUNTIME)@interface MyAnnotation2&#123; //注解的参数 //参数类型 + 参数名 String name();//没有默认值一定要传值 int age() default 0;//有默认值，可以不传值 String[] say() default &#123;&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;,&quot;赵六&quot;&#125;;//这是一个数组参数&#125;@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)@Retention(RetentionPolicy.RUNTIME)@interface MyAnnotation3 &#123; String value();//若注解只有一个参数 只需要一个value就可。&#125; 注解在哪里使用可以附加在package，class，method，field上面，相当于给他们添加了额外的辅助信息。 可以通过反射机制编程实现对这些元数据的访问。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://zswh33.github.io/tags/Java/"}]},{"title":"Day7 Java 网络编程 1","slug":"Day7-Java-Network-1","date":"2022-08-30T07:05:17.000Z","updated":"2022-08-30T14:19:31.107Z","comments":true,"path":"2022/08/30/Day7-Java-Network-1/","link":"","permalink":"http://zswh33.github.io/2022/08/30/Day7-Java-Network-1/","excerpt":"","text":"IP地址 唯一定位一台网络上的计算机 127.0.0.1：本机localhost ip地址分为IPv4和IPv6 IPv4 四个字节组成； IPv6：128位，8个无符号整数组成。 2001:0bb2:aaaa:bbbb:cccc:dddd:eeee:2222 Javajava.net.InetAddress 这个类用来表示IP地址。 一些方法： static InetAddress getAllByName(String name)，给出主机的名称，根据系统上配置的名称服务返回其IP地址数组。 使用1234567891011121314151617181920212223import java.net.InetAddress;import java.net.UnknownHostException;public class Test &#123; public static void main(String[] args) &#123; try &#123; //通过域名获取InetAddress对象 InetAddress address = InetAddress.getByName(&quot;www.baidu.com&quot;); System.out.println(address); //获取本地InetAddress对象 InetAddress address2 = InetAddress.getLocalHost(); System.out.println(address2); //常用方法 System.out.println(address.getHostAddress());//ip地址 System.out.println(address.getHostName());//域名 &#125; catch (UnknownHostException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 端口范围：0-65535 端口分类： 公有端口 0~1023 程序注册端口：1024~49151，分配用户或者程序 动态、私有：49152~65535 Windows下查看进程端口12netstat -ano # 查看所有程序端口netstat -ano|findstr &quot;5900&quot; # 寻找字符存在5900的行 InetSocketAddress这个类的对象可以包含有地址+端口 123456789public class Test &#123; public static void main(String[] args) &#123; InetSocketAddress socketAddress = new InetSocketAddress(&quot;127.0.0.1&quot;,1234); System.out.println(socketAddress); /* /127.0.0.1:1234 */ &#125;&#125; 通信协议TCP&#x2F;IP协议簇 重要的协议： TCP 用户传输协议 UDP 用户数据报协议 TCP和UDP对比 TCP: 连接稳定 三次握手 四次挥手 UDP： 不稳定 Java上的TCP客户端 连接服务器Socket； 发送消息。 服务端 建立服务的端口ServerSocket； 等待用户的连接Socket； 接收消息。 Client和Server示例Client1234567891011121314151617181920212223242526272829public class Client &#123; public static void main(String[] args) &#123; Socket socket = null; //IO流 OutputStream os = null; try &#123; //声明地址和端口号 InetAddress server = InetAddress.getByName(&quot;127.0.0.1&quot;); int port = 9999; //创建一个Socket连接 socket = new Socket(server,port); //IO流 os = socket.getOutputStream(); os.write(&quot;你好，吃黑曜石吗。&quot;.getBytes()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; try &#123; os.close(); socket.close(); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; Server123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Server &#123; public static void main(String[] args) &#123; ServerSocket serverSocket = null; //等待客户端连接 Socket accept = null; //读取消息 InputStream is = null; //管道流 ByteArrayOutputStream outputStream = null; try &#123; // serverSocket = new ServerSocket(9999); //等待客户端连接 while (true)&#123; accept = serverSocket.accept(); //读取消息 is = accept.getInputStream(); //管道流 outputStream = new ByteArrayOutputStream(); byte[] buffer = new byte[1024]; int len; while ((len=is.read(buffer))!=-1)&#123; outputStream.write(buffer,0,len); &#125; System.out.println(outputStream.toString()); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; try &#123; outputStream.close(); is.close(); serverSocket.close(); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://zswh33.github.io/tags/Java/"}]},{"title":"Day7 Java 多线程 2","slug":"Day7-Java-Multithreading-2","date":"2022-08-30T01:33:54.000Z","updated":"2022-08-30T07:27:46.323Z","comments":true,"path":"2022/08/30/Day7-Java-Multithreading-2/","link":"","permalink":"http://zswh33.github.io/2022/08/30/Day7-Java-Multithreading-2/","excerpt":"","text":"线程协作生产者消费者问题这是一个线程同步问题，生产者和消费者共享同一个资源，并且生产者和消费者之间相互依赖，互为条件。 Java线程通信 方法名 作用 wait() 表示线程一直等待，直到其他线程通知，与sleep不同，会释放锁； wait(long timeout) 指定等待的秒数 notify() 唤醒一个处于等待状态的线程 notifyAll() 唤醒同一个对象上所有调用wait()方法的线程，优先级别高的线程优先调度 注：均是Object类的方法，都只能在同步方法或者同步代码块中使用，否则会抛出异常IllEgalMonitorStateException。 问题解决方式1并发协作模型“生产者&#x2F;消费者模式” -&gt; 管程法 生产者：负责生产数据的模块（可能是方法，对象，线程，进程）； 消费者：负责处理数据的模块（可能是方法，对象，线程，进程）； 缓冲区：消费者不能直接使用生产者的数据，他们之间有个“缓冲区” 生产者将生产好的数据放入缓冲区，消费者从缓冲区拿出数据。 方式2并发协作模型“生产者&#x2F;消费者模式” -&gt; 信号灯法 通过一个标志位解决问题。 线程池背景：经常创建和销毁，使用了特别大的资源，比如并发情况下的线程，对性能影响很大。 思路：提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁，实现重复利用。 优点： 提高响应速度(减少了创建新线程的时间) 降低资源消耗（重复利用线程池中线程，不需要每次都创建） 便于线程管理 使用线程池JDK5.0起提供了线程池相关的API：ExecutorService和Executors ExecutorService：线程池接口。子类有：ThreadPoolExecutor。 方法： void execute(Runnable command)：执行任务&#x2F;命令，没有返回值，一般用来执行Runnable。 &lt;T&gt;Future&lt;T&gt; submit(Callable&lt;T&gt; task)：执行任务，有返回值，一般用来执行Callable。 void shutdown()关闭连接池。 Executors：工具类，线程池的工厂类，用于创建并返回不同类型的线程池。 123456789101112131415161718192021222324252627public class Demo19_ThreadPool &#123; public static void main(String[] args) &#123; //创建线程池 //newFixedThreadPool参数为线程池大小 ExecutorService service = Executors.newFixedThreadPool(10); //执行 service.execute(new MyThread()); service.execute(new MyThread()); service.execute(new MyThread()); //关闭连接 service.shutdownNow(); &#125;&#125;class MyThread implements Runnable&#123; @Override public void run() &#123; for (int i = 0; i &lt; 5; i++) &#123; System.out.println(Thread.currentThread().getName()+&quot; &quot;+i); &#125; &#125;&#125; 创建线程小结12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import java.util.concurrent.Callable;import java.util.concurrent.FutureTask;//创建线程方式 3种public class CreateThread &#123; public static void main(String[] args) &#123; new MyThread().start();//1 new Thread(new MyRunnable()).start();//2 //3 FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;&gt;(new MyCall()); new Thread(futureTask).start(); Integer rs=0; try &#123; rs = futureTask.get(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; System.out.println(rs+&quot; &quot;); &#125;&#125;//1. 继承Thread类class MyThread extends Thread&#123; @Override public void run() &#123; System.out.println(&quot;继承Thread&quot;); &#125;&#125;//2. 实现Runnable接口class MyRunnable implements Runnable &#123; @Override public void run() &#123; System.out.println(&quot;实现Runnable接口&quot;); &#125;&#125;//3. 实现Callable接口class MyCall implements Callable&lt;Integer&gt;&#123; @Override public Integer call()&#123; System.out.println(&quot;Call .&quot;); return 123; &#125;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://zswh33.github.io/tags/Java/"}]},{"title":"Day6 Java多线程 1","slug":"Day6-Java-Multithreading-1","date":"2022-08-29T14:21:15.000Z","updated":"2022-09-01T03:49:24.511Z","comments":true,"path":"2022/08/29/Day6-Java-Multithreading-1/","link":"","permalink":"http://zswh33.github.io/2022/08/29/Day6-Java-Multithreading-1/","excerpt":"","text":"Java 多线程 1程序：指令和数据的有序集合，其本身没有任何运行的含义，是一个静态的概念；进程：执行程序的一次执行过程，它是一个动态的概念。是系统资源分配的单位；一个进程中可以包含若干个线程，一个进程至少有一个线程。线程是CPU调度和执行的单位。 线程就是独立的执行路径在程序运行时，即使没有自己创建线程，后台也会有多个线程，如主线程，gc线程；main()可以称为主线程，为系统的入口，用于执行整个程序； 线程创建.三种方式 继承Thread类 实现Runnable接口 实现Callback接口 继承Thread类 自定义类继承Thread类； 重写**run()**方法，编写线程执行体； 创建线程对象，调用start()方法启动线程。 123456789101112131415161718192021public class UThread1 extends Thread&#123; @Override public void run() &#123; for (int i = 0; i &lt; 20; i++) &#123; System.out.println(&quot;当前是线程： &quot;+i); &#125; &#125; public static void main(String[] args) &#123; System.out.println(&quot;程序开始\\n-----------------&quot;); //启动线程 UThread1 uThread1 = new UThread1(); uThread1.start(); //与线程对照 for (int i = 0; i &lt; 200; i++) &#123; System.out.println(&quot;这里是主线程：&quot;+i); &#125; &#125;&#125; 实现Runnable接口.对于两种线程创建方式，建议使用”实现Runnable接口”方式实现多线程 目的避免单继承的局限性，灵活方便，方便同一个对象被多个线程使用 实现1234567891011121314151617public class RunnableImpl implements Runnable&#123; int id; int rest; public RunnableImpl(int id, int rest) &#123; this.id = id; this.rest = rest; &#125; @Override public void run() &#123; while(rest&gt;0)&#123; System.out.println(&quot;我是&quot;+id+&quot; 剩余：&quot;+rest+&quot;次数&quot;); rest--; &#125; &#125;&#125; 使用123456public class Test &#123; public static void main(String[] args) &#123; Thread t1 = new Thread(new RunnableImpl(1,20)); t1.start();//启动线程 &#125;&#125; 其他线程开启不一定立即执行，由CPU调度执行 Callable方式123456789101112131415161718192021222324252627282930public class Test implements Callable&lt;Boolean&gt; &#123; int id; @Override public Boolean call() throws Exception &#123; System.out.println(id); return Math.random()&gt;0.5;//随机返回一个结果 &#125; public Test(int id)&#123; this.id = id; &#125; public static void main(String[] args) &#123; Test t1 = new Test(1); //创建执行服务 ExecutorService ser = Executors.newFixedThreadPool(3); //提交执行 Future&lt;Boolean&gt; rs1 = ser.submit(t1); //获取结果 try &#123; System.out.println(&quot;1. &quot;+rs1.get()); &#125;catch (Exception e)&#123; System.out.println(e); &#125; //关闭 ser.shutdownNow(); &#125;&#125; 静态代理123456789101112131415161718192021222324252627282930313233343536373839404142434445public class StaticProxy &#123; public static void main(String[] args) &#123; Restaurant restaurant = new Restaurant(new You()); restaurant.startEat(); &#125;&#125;//目标：You要Eat//过程：代理Restaurant，Restaurant准备饭前饭后要做的事情//结果：Restaurant代理You去startEat//注意：真实对象和代理对象实现同一个接口//好处：代理对象可以做好多真实对象做不了的事情// 真实对象专注做自己的事情interface Eat&#123; //吃饭 void startEat();//开始吃&#125;//吃饭对象class You implements Eat&#123; @Override public void startEat() &#123; System.out.println(&quot;开始吃饭，超开心&quot;); &#125;&#125;//代理对象class Restaurant implements Eat&#123; private Eat target; public Restaurant(Eat target)&#123; this.target = target; &#125; @Override public void startEat() &#123; before();//做饭 target.startEat();//吃饭 after();//收拾 &#125; private void after()&#123; //收拾残局 System.out.println(&quot;吃完离开 Leave&quot;); &#125; private void before()&#123; //做饭 System.out.println(&quot;烤Food&quot;); &#125;&#125; Lambda 表达式函数式接口 任何接口，如果只包含一个抽象方法，则是一个函数式接口 对于函数式接口，可以通过lambda表达式来创建该接口的对象 匿名内部类123456789101112131415161718public class Test &#123; public static void main(String[] args) &#123; //匿名内部类 Eat lunch = new Eat() &#123; @Override public void startEat() &#123; System.out.println(&quot;吃午饭&quot;); &#125; &#125;; lunch.startEat(); &#125;&#125;//定义一个函数式接口interface Eat&#123; void startEat();&#125; lambda表达式使用1234567891011121314public class Test &#123; public static void main(String[] args) &#123; //lambda表达式 Eat lunch = ()-&gt;&#123; System.out.println(&quot;吃午饭&quot;); &#125;; lunch.startEat(); &#125;&#125;//定义一个函数式接口interface Eat&#123; void startEat();&#125; 代参Lambda表达式12345678910111213public class Test &#123; public static void main(String[] args) &#123; Callback callback = (a)-&gt;&#123; System.out.println(&quot;传入参数为：&quot;+a); return ++a; &#125;; System.out.println(callback.call(123)); &#125;&#125;//一个函数式接口interface Callback&#123; int call(int t);&#125; 可以简化的内容 简化括号：若参数只有一个，则可以简化括号 简化花括号: 若代码只有一行，这可以简化花括号 简化括号1234567891011121314public class Test &#123; public static void main(String[] args) &#123; Callback callback = a-&gt;&#123; System.out.println(&quot;传入参数为：&quot;+a); return ++a; &#125;; System.out.println(callback.call(123)); &#125;&#125;//一个函数式接口interface Callback&#123; int call(int t);&#125; 简化花括号1234567891011public class Test &#123; public static void main(String[] args) &#123; Callback callback = t -&gt; System.out.println(++t); callback.call(123); &#125;&#125;//一个函数式接口interface Callback&#123; void call(int t);&#125; 线程的一些方法 方法名 功能 setPriority(int newPriority) 更改线程优先级 sleep(long millis) 在指定的毫秒数内使正在执行的线程休眠 join() 等待线程终止 yield() 暂停当前线程，执行其他线程 interrupt() 中断线程，一般不用 isAlive() 测试线程是否处于活跃状态 停止线程不推荐使用JDK提供的stop()和destroy()推荐让线程自己停下来，建议使用一个标志位进行终止变量，当flag&#x3D;false，则终止线程运行。 123456789101112131415161718192021222324252627class YThread extends Thread&#123; boolean flag=true;//停止标志 @Override public void run() &#123; while (flag)&#123; System.out.println(&quot;Thread running...&quot;); &#125; &#125; public void requestStop()&#123; flag = false; &#125;&#125;public class ThreadStop &#123; public static void main(String[] args) &#123; YThread yThread = new YThread(); yThread.start(); //主线程 for (int i = 0; i &lt; 100; i++) &#123; System.out.println(&quot;Main &quot;+i); //当i==60，请求线程停止 if(i==60)&#123; yThread.requestStop(); &#125; &#125; &#125;&#125; 线程休眠.每个对象都有一个锁，sleep不会释放锁 Thread.sleep(毫秒) 线程礼让.礼让不一定成功，看CPU心情调度 Thread.yield(); 线程强制执行 join.少用 123456789101112131415161718192021222324252627public class Test &#123; public static void main(String[] args) &#123; Thread thread = new Thread(new ARun(),&quot;vip&quot;); thread.start(); //主线程 for (int i = 0; i &lt; 100; i++) &#123; if(i==20)&#123; try &#123; thread.join();//插队 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(&quot;main &quot;+i); &#125; &#125;&#125;class ARun implements Runnable&#123; @Override public void run() &#123; for (int i=0;i&lt;100;i++)&#123; System.out.println(Thread.currentThread().getName()+&quot;执行到&quot;+i); &#125; &#125;&#125; 获取线程状态Thread.getState(); 线程状态 Thread.State 表达 NEW 尚未启动的线程 RUNNABLE 在Java虚拟机中执行的线程处于此状态 BLOCKED 被阻塞的线程 WAITING 等待另一个线程执行特定状态的状态 TIMED_WAITING 等待另一个线程执行动作达到指定等待时间的状态 TERMINATED 已退出的线程处于此状态 代码 1234567891011121314151617181920212223242526272829303132public class Test &#123; public static void main(String[] args) &#123; Thread thread = new Thread(new ARun()); thread.start(); System.out.println(&quot;线程开始&quot;); //监测状态 while (thread.getState()!= State.TERMINATED)&#123; System.out.println(thread.getState()); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(thread.getState()); &#125;&#125;class ARun implements Runnable&#123; @Override public void run() &#123; for (int i = 0; i &lt; 5; i++) &#123; System.out.println(&quot;/////&quot;); try &#123; sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 线程优先级线程优先级用数字表示，范围1~10 常量名 值 介绍 Thread.MIN_PRIORITY 1 最低 Thread.MAX_PRIORITY 10 最高 Thread.NORM_PRIORITY 5 默认 改变优先级&#x2F;获取优先级setPriority(int p)getPriority() 守护线程thread.setDaemon(true);//false为用户线程，true为守护线程。默认为false。 虚拟机必须保证用户线程执行完毕，不用等待守护线程执行完毕。比如：后台记录操作日志，监控内存，垃圾回收等等。 线程同步多个线程访问同一个对象，为了保障数据在方法中被访问时的正确性，在访问时加入锁机制synchronized，当一个线程获得对象的排它锁，独占资源，其他线程必须等待，使用后释放锁即可。 存在问题： 一个线程持有锁会导致其他所有需要锁的线程挂起； 在多线程竞争下，加锁，释放锁会导致比较多的上下文切换和调度延时，引起性能问题。 线程同步安全 synchronizedsynchronized有两种用法：synchronized方法和synchronized块。同步方法public synchronized void method(int args)&#123;&#125; synchronized方法必须获得调用该方法的对象的锁才能执行，否则线程会阻塞。方法一旦执行，就独占该锁，直到该方法返回才释放锁，后面被阻塞的线程才能获得这个锁，继续执行。 方法里面需要修改的内容需要锁。只读的代码不需要锁。 缺陷：若将一个大的方法申明为synchronized将会影响效率。 synchronized锁住的对象 修饰实例方法：作用于当前实例加锁。 修饰静态方法：作用于当前类对象加锁（锁住Class对象，然后，该对象的静态方法都得等待）。 修饰代码块：指定加锁对象，对给定对象加锁。 加锁之后，锁只对有synchronized修饰的方法有效。 同步块同步块：synchronized(Obj)&#123;&#125; Obj称为同步监视器。Obj可以是任何对象，但是推荐使用共享资源作为同步监视器。Obj一般是同步块内变化的量。（增删改的对象） CopyOnWriteArrayList安全的ArrayList 死锁产生死锁必要条件 互斥条件：一个资源每次只能被一个进程使用； 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放； 不剥夺条件：进程进程已获得的资源，在未使用完之前，不能强行剥夺； 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。 Lock锁java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁。 ReentrantLock类实现了Lock，拥有与synchronized相同的并发性和内存语义。 ReentrantLock即可重入的互斥锁。 1234567891011121314151617181920212223242526272829303132public class Test &#123; public static void main(String[] args) &#123; BuyTicket buyTicket = new BuyTicket(); new Thread(buyTicket,&quot;a&quot;).start(); new Thread(buyTicket,&quot;b&quot;).start(); new Thread(buyTicket,&quot;c&quot;).start(); &#125;&#125;class BuyTicket implements Runnable&#123; int ticket=10; private final ReentrantLock lock = new ReentrantLock(); @Override public void run() &#123; while (true)&#123; lock.lock(); try&#123; if (ticket&gt;0)&#123; Thread.sleep(100); System.out.println(Thread.currentThread().getName()+&quot; &quot;+ticket--); &#125;else&#123; break; &#125; &#125;catch (InterruptedException e)&#123; System.out.println(e); &#125;finally &#123; lock.unlock(); &#125; &#125; &#125;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://zswh33.github.io/tags/Java/"}]},{"title":"Day5 Java 5","slug":"Day5-Java-5","date":"2022-08-29T14:21:04.000Z","updated":"2022-08-29T14:23:58.520Z","comments":true,"path":"2022/08/29/Day5-Java-5/","link":"","permalink":"http://zswh33.github.io/2022/08/29/Day5-Java-5/","excerpt":"","text":"Java 个人总结 5异常分类检查性异常，运行时异常，错误。 Throwable分为 Error和Exception。 Error不可预见，尽可能避免；Exception可以被开发者预见。 Exception分为IOException和RuntimeException（运行时异常）。 ErrorError类对象由Java虚拟机生成并抛出，大多数错误与开发者所执行的操作无关。例：OutOfMemoryError，当JVM不再有继续执行所需的内存资源。 Exception一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。 Error和Exception的区别Error通常是灾难性的致命错误，是程序无法控制和处理的。当出现这些异常，Java虚拟机（JVM）一般会选择终止线程；Exception通常情况下是可以被程序处理的，并却在程序中应该尽可能的去处理这些异常。 异常处理关键字try、catch、finally、throw、throws 捕获异常和错误12345678910111213141516171819202122232425public class Test &#123; public static void main(String[] args) &#123; try &#123; int t = 1 / 0;//除以0的异常 ArithmeticException &#125;catch (ArithmeticException e)&#123; System.out.println(&quot;/0 Exception&quot;); &#125; try &#123; a();//栈溢出错误 StackOverflowError &#125;catch (StackOverflowError t)&#123; System.out.println(&quot;Error: &quot;+t.toString()); &#125; /* /0 Exception Error: java.lang.StackOverflowError */ &#125; public static void a()&#123; b(); &#125; public static void b()&#123; a(); &#125;&#125; 抛出异常123456public class Test2 &#123; public static void main(String[] args) &#123; //主动抛出异常 throw new ArithmeticException(&quot;主动抛出的异常&quot;); &#125;&#125; 12Exception in thread &quot;main&quot; java.lang.ArithmeticException: 主动抛出的异常 at Demo7.Test2.main(Test2.java:6) 自定义异常自定义异常类1234567891011121314151617//自定义异常类public class MyException extends Exception&#123; //假设a大于10，则抛出异常 private int a; public MyException(int a) &#123; this.a = a; &#125; //异常打印的信息 @Override public String toString() &#123; return &quot;MyException&#123;&quot; + &quot;a=&quot; + a + &#x27;&#125;&#x27;; &#125;&#125; 使用12345678910111213141516public class Test &#123; public static void main(String[] args) &#123; try &#123; yTest(11); &#125;catch (MyException e)&#123; System.out.println(&quot;异常&quot;); &#125; &#125; public static void yTest(int a) throws MyException &#123; System.out.println(&quot;a= &quot; + a); if (a &gt; 10) &#123; throw new MyException(a); &#125; System.out.println(&quot;ok&quot;); &#125;&#125; 12a= 11异常 其他 处理运行时异常时，合理规避同时辅助try-catch处理; 在多重catch块后面，可以加一个catch(Exception) 来处理可能会被遗漏的异常; 对于不确定的代码，也可加上try-catch处理潜在异常; 尽量去处理异常，切忌简单地调用printStackTrace()去打印输出; 尽量添加finally语句块去释放占用的资源。 一些转义字符\\u0000\\b 退格键\\n 换行\\t 制表 小结 &gt;&gt;&gt; 无符号右移 移位运算符 JavaDoc注释 @author 作者 @Version 版本 @Since JDK版本 @param 参数 @return 返回 @throws 类与对象 类是对象的抽象：模板class； 对象是类的具体； 单例模式，需要构造器私有； 单例模式 目的：保证一个雷仅有一个实例，并提供一个访问它的全局访问点； 主要解决：一个全局使用的类频繁地创建与销毁； 如何解决：判断系统是否已经有这个实例，若有则返回，没有则创建； 关键代码：构造函数私有； 多态：父类引用指向子类对象。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://zswh33.github.io/tags/Java/"}]},{"title":"Day4 Nginx 1","slug":"Day4-Nginx","date":"2022-08-29T14:20:35.000Z","updated":"2022-09-26T11:57:01.903Z","comments":true,"path":"2022/08/29/Day4-Nginx/","link":"","permalink":"http://zswh33.github.io/2022/08/29/Day4-Nginx/","excerpt":"","text":"NginxNginx一个高性能的HTTP和反向代理的web服务器，同时也提供IMAP&#x2F;POP3&#x2F;SMTP服务。 作用即：反向代理、负载均衡、动静分离。 Http代理，反向代理， 正向代理代理客户端。多个客户端 -&gt; 代理 -&gt; … -&gt; 单个服务器 反向代理代理服务器多个客户端 -&gt; … -&gt; 代理 -&gt; 多个服务器 负载均衡轮询、加权轮询、iphash iphash可以解决Session不共享的问题 不建议使用Nginx用作Session共享，建议使用Redis动静分离将动态服务请求和静态服务请求分开。 conf文件… Nginx 常用命令nginx 启动nginx -s stop 停止nginx -s quit 安全退出nginx -s reload 重新加载配置文件ps aux|grep nginx 查看nginx进程 多项目负载均衡用Nginx均衡来自8080和8081的负载。 12345678910111213141516171819202122232425262728293031http &#123; include mime.types; default_type application/octet-stream; upstream yupstream&#123; # 服务器资源 server 127.0.0.1:8080 weight=1; # 权重为1 server 127.0.0.1:8081 weight=1; &#125; server&#123; listen 801; server_name localhost; # 代理 # 根目录请求 location / &#123; root html; index index.html,index.htm; proxy_pass http://yupstream; # 反向代理 &#125; location /admin &#123; &#125; &#125;&#125;","categories":[],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://zswh33.github.io/tags/Nginx/"}]},{"title":"Day4 Java 4","slug":"Day4-Java-4","date":"2022-08-29T14:20:24.000Z","updated":"2022-08-29T14:23:32.821Z","comments":true,"path":"2022/08/29/Day4-Java-4/","link":"","permalink":"http://zswh33.github.io/2022/08/29/Day4-Java-4/","excerpt":"","text":"Java 个人总结 4对象三大特性封装、继承、多态 面向对象.以类的方式组织代码，以对象的组织（封装）数据 对象内存分析 多态存在条件 有继承关系 子类重写父类方法 父类引用指向子类对象 注意多态是方法的多态，属性没有多态性 instanceof功能：判断前面的对象是否属于后面的类，或者属于其子类。 Object是所有类的父类代码块12345678910111213141516171819202122232425262728293031public class CodeBlock &#123; //匿名代码块 // 一般用于赋初值 // 每创建一次对象 运行一次 &#123; System.out.println(&quot;匿名代码块&quot;); &#125; //静态代码块 //类加载后运行，只运行一次 static &#123; System.out.println(&quot;静态代码块&quot;); &#125; public CodeBlock()&#123; System.out.println(&quot;构造方法&quot;); &#125; public static void main(String[] args) &#123; CodeBlock codeBlock = new CodeBlock(); System.out.println(&quot;-------------------------&quot;); CodeBlock codeBlock2 = new CodeBlock(); /* 静态代码块 匿名代码块 构造方法 ------------------------- 匿名代码块 构造方法 */ &#125;&#125; 抽象.抽象的抽象：约束 抽象类不能new，只能靠子类去实现; 抽象类中可以写普通方法; 抽象方法必须在抽象类中. 定义&#x2F;声明12345678public abstract class UAbstract &#123; public abstract void run(); public abstract void say(); public void all()&#123; run(); say(); &#125;&#125; 使用1234567891011121314151617181920public class UAbstract2 extends UAbstract&#123; @Override public void run() &#123; System.out.println(&quot;run&quot;); &#125; @Override public void say() &#123; System.out.println(&quot;say&quot;); &#125; public static void main(String[] args) &#123; UAbstract uAbstract = new UAbstract2(); uAbstract.all(); /* run say */ &#125;&#125; 意义：提高开发效率。 接口 是一种约束； 定义一些方法，让不同的人实现； 接口不能被实例化； 接口可以实现多个； 类实现接口后，必须要重写接口中的方法。 内部类概念在一个类的内部再定义一个类。 分类 成员内部类 静态内部类 12345678910111213141516171819202122232425262728293031323334//外部类public class Outer &#123; private int id=6; public void out()&#123; System.out.println(&quot;外部类的方法&quot;); &#125; //内部类 public class Inner&#123; public void InnerFunction()&#123; System.out.println(&quot;内部类的方法&quot;); &#125; //获得外部类的私有属性 public void InnerGetOuterId()&#123; System.out.println(id); &#125; &#125; //静态内部类 用static修饰 //不能访问Outer的属性 public static class StaticInner&#123; public void InnerFunction()&#123; System.out.println(&quot;内部类的方法&quot;); &#125; //获得外部类的私有属性 public void InnerGetOuterId()&#123;// System.out.println(id); //报错 &#125; &#125;&#125; 局部内部类 123456789public class Outer2 &#123; public void method()&#123; //局部内部类 //放在方法里 class Inner&#123; &#125; &#125;&#125; 匿名内部类 123456789101112131415public class Outer4 &#123; public static void main(String[] args) &#123; //匿名内部类 UserService3 userService3 = new UserService3() &#123; @Override public void hello() &#123; System.out.println(&quot;Hello&quot;); &#125; &#125;; userService3.hello(); &#125;&#125;interface UserService3&#123; void hello();&#125; 其他 一个java文件中可以有多个class类，但只能有一个public class;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://zswh33.github.io/tags/Java/"}]},{"title":"Day3 Java 3","slug":"Day3-Java-3","date":"2022-08-29T14:20:14.000Z","updated":"2022-08-31T04:41:25.653Z","comments":true,"path":"2022/08/29/Day3-Java-3/","link":"","permalink":"http://zswh33.github.io/2022/08/29/Day3-Java-3/","excerpt":"","text":"Java 个人总结 3位运算符位运算效率极高。 A &#x3D; 0011 1100B &#x3D; 0000 1101-————————–A&amp;B &#x3D; 0000 1100 且A|B &#x3D; 0011 1101 或A^B &#x3D; 0011 0001 异或~B &#x3D; 1111 0010 取反 Q： 对于计算机来说，更快地计算2*8&#x3D;?A： 位运算，2 &lt;&lt; 3 &#x3D; 16 包机制为了更好地组织类 Java提供了包机制，用于区别类名的命名空间。一般利用公司域名倒置作为包名：com.uwupu.blog在类里需要添加 package com.uwupu.blog JavaDoc 文档注释123456789101112131415161718192021/** * 类注释 * @author uwupu 作者 * @version 1.0 版本 * @since 1.8 JDK版本 */public class UDoc &#123; String name; // 类变量 /** * 方法注释 * @author uwupu 作者 * @param name 参数 * @return 返回值 * @throws Exception 抛出 */ public String uTest(String name) throws Exception&#123; return name; &#125;&#125; 生成文档在类所在文件夹中打开终端，执行以下命令，可以生成类的文档。javadoc -encoding UTF-8 -charset UTF-8 类名.java 增强的for循环.JDK 5 引入用于数组和集合的循环 12345678910111213141516public class ForDemo &#123; public static void main(String[] args) &#123; int[] ns = &#123;10,20,30,40,50&#125;; for ( int i : ns)&#123; System.out.println(i); &#125; /* 结果： 10 20 30 40 50 */ &#125;&#125; 方法重载规则： 方法名必须相同； 参数必须不同； 方法返回类型可以相同也可不同； 仅仅返回类型不同不足以成为方法的重载； 命令行传参public static void main(String[] args)中的args即为参数。 12345678public class Args &#123; public static void main(String[] args) &#123; for(String i : args)&#123; System.out.println(i); &#125; &#125;&#125; 可变参数.Java 1.5开始，可以通过“…”来创建可变参数 1234567891011121314151617public class Demox3 &#123; public static void main(String[] args) &#123; Demox3.printMax(123,123,234); &#125; public static void printMax(double... numbers)&#123; for(double i : numbers)&#123; System.out.println(i); &#125; /* 结果： 123.0 123.0 234.0 */ &#125;&#125; 注意 若有多个参数，将可变参数放在最后一个； 一个方法只能有一个可变参数。 数组创建在Java中，一般用DataType[] arrayRefVar;方式声明数组变量，一般不用DataType arrayRefVar[]; 创建数组用new DataType[];即 1234567public class Array &#123; public static void main(String[] args) &#123; int[] nums; //定义 nums = new int[10]; //创建并赋值 int[] nums2 = &#123;1,2,3&#125;; //静态初始化 &#125;&#125; 内存分析堆： 存放new的对象和数组; 可以被所有的线程共享，不会存放别的对象引用。 栈： 存放基本变量类型(会包含这个基本类型的具体数值); 引用对象的变量(会存放这个引用在堆里面的具体地址)。 方法区： 可以被所有的线程共享； 包含了所有的class和static变量。 其他数组下标越界异常：ArrayIndexOutOfBoundsException 数组 数组是引用类型。一旦分配，会被隐式地初始化。 长度是确定的，一旦被创建，不可改变； 数组中的元素可以是任何数据类型，包括基本类型和引用类型； 数组对象本身在堆中。 Arrays类数组工具类：java.util.Arrays Arrays.toString(数组)方法可以将数组转换为字符串；Arrays.sort(数组) 将数组排序。Arrays.fill(数组，值) 将数组填充为指定值。Arrays.fill(数组，开始，结束，值) 将从开始到结束的位置设置为指定值。 冒泡排序时间复杂度：O(n^2) 123456789101112131415161718192021222324public class BubbleSort &#123; public static void main(String[] args) &#123; int[] array = &#123;1,5,2,3,2,1,5&#125;; array = UBubbleSort(array); System.out.println(Arrays.toString(array)); &#125; public static int[] UBubbleSort(int []array)&#123; int len = array.length; int temp; for(int i = 0 ; i &lt; len-1 ; i++)&#123; for(int j = len-1 ; j &gt; i ;j--)&#123; if(array[j] &lt; array[j-1])&#123; temp = array[j]; array[j] = array[j-1]; array[j-1] = temp; &#125; &#125; &#125; return array; &#125;&#125; 优化12345678910111213141516171819202122232425262728293031323334public class BubbleSort &#123; public static void main(String[] args) &#123; int[] array = &#123;1,5,2,3,2,1,5&#125;; array = UBubbleSort(array); System.out.println(Arrays.toString(array)); &#125; public static int[] UBubbleSort(int []array)&#123; int len = array.length; int temp; for(int i = 0 ; i &lt; len-1 ; i++)&#123; boolean flag = false; // 通过flag表示位减少没有意义的比较 //内层循环 for(int j = len-1 ; j &gt; i ;j--)&#123; if(array[j] &lt; array[j-1])&#123; temp = array[j]; array[j] = array[j-1]; array[j-1] = temp; flag = true; // 当前有交换项 &#125; &#125; if(!flag)&#123; //若没有交换项，表示剩下已排好序 break; &#125; &#125; return array; &#125;&#125; 稀疏数组.当一个数组中大部分元素为0，或者为同一值的数组时，可以使用稀疏数组来保存该数组 一个5x5的二维数组 . . . . . 0 0 0 0 6 0 3 5 0 0 0 0 4 0 0 0 0 0 0 0 0 0 0 0 0 稀疏数组表示 rows cols value 0 4 6 1 1 3 1 2 5 2 2 4","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://zswh33.github.io/tags/Java/"}]},{"title":"Day3 Java 2","slug":"Day3-Java-2","date":"2022-08-29T14:20:06.000Z","updated":"2022-09-08T23:43:39.623Z","comments":true,"path":"2022/08/29/Day3-Java-2/","link":"","permalink":"http://zswh33.github.io/2022/08/29/Day3-Java-2/","excerpt":"","text":"Java 个人总结 2类型转换小 —————————————— 大byte,short -&gt; char -&gt; int -&gt; long -&gt; float -&gt; double 小 -&gt; 大 需要强制转换大 -&gt; 小 自动转换 12345678910111213141516171819// 低转高 低 -&gt; 高 强制转换int i = 128;byte b = (byte)i; //强制转换System.out.println(i);System.out.println(b);//结果：//128//-128// 高转低 高 -&gt; 低 自动转换int i2 = 128;double d = i2; //自动转换 不需要强制转换 注意： 不能对布尔值进行转换 不能把对象类型转换为不相干类型 高容量转低容量，需要强制转换 转换可能内存溢出，或精度问题 变量局部变量：必须声明和初始化值 实例变量： 从属于类，如果不初始化，默认值为 类型 值 布尔值 false 基本类型 0 其他 null 12345678910111213141516171819public class UVatiable &#123; static int b; //类变量 String s;// 实例变量 从属于对象 public static void main(String[] args) &#123; int i = 10;//局部变量 必须声明和初始化值 System.out.println(i); //实例变量使用 UVatiable yv = new UVatiable(); System.out.println(yv.s); //为null System.out.println(UVatiable.b);//输出类变量 //为null &#125;&#125; 常量初始化后不能再改变值 使用final 常量名 &#x3D; 值final int PI = 3.1415 命名规范 所有变量，方法、类名：见名知义； 类成员变量：首字母小写和驼峰原则：monthSalary 局部变量：驼峰原则 常量：大写字母和下划线：MAX_VALUE 类名 首字母大写和驼峰原则：Man,GoodMan,SpringBoot 方法名：首字母小写和驼峰原则：run(),runRunRun() 运算符 名字 表现 算数运算符 + - * &#x2F; % ++ – 赋值运算符 &#x3D; 关系运算符 &gt; &lt; &gt;&#x3D; &lt;&#x3D; &#x3D;&#x3D; !&#x3D; instanceof 逻辑运算符 &amp;&amp; || ! 位运算符 &amp; | ^ ~ &gt;&gt; &lt;&lt; &gt;&gt;&gt; 条件运算符 ? : 扩展赋值运算符 +&#x3D; -&#x3D; ^&#x3D; &#x2F;&#x3D; instanceof 用来判断一个对象是否属于某个指定的类或其子类的实例 自增 自减123456789101112public class Dx2 &#123; public static void main(String[] args) &#123; int a = 3; int b = a++;//先b赋值，再进行a=a+1 int c = ++a;//先进行a=a+1。再赋值c System.out.println(a);//5 System.out.println(b);//3 System.out.println(c);//5 &#125;&#125; 幂运算1Math.pow(2,3)//即2^3，返回值类型为double … 其他 JDK新特性 数字之间可以用下划线分割，并不影响原效果int money = 10_0000_0000 大整数计算 int到long 12345int a = 10_0000_0000;int b = 20;int total = a*b; //-1474836480 计算溢出long total2 = a*b;//仍旧溢出long total3 = money*((long)years);//先转换一个为long，计算则不会出错 long类型的变量值在赋值时数字后面的L，用大写或小写都可，为保障易读，使用大写L. 修饰符 不存在先后顺序 cast 转换v.。 测验","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://zswh33.github.io/tags/Java/"}]},{"title":"Day3 Java 1","slug":"Day3-Java-1","date":"2022-08-29T14:19:58.000Z","updated":"2022-08-29T14:22:20.897Z","comments":true,"path":"2022/08/29/Day3-Java-1/","link":"","permalink":"http://zswh33.github.io/2022/08/29/Day3-Java-1/","excerpt":"","text":"Java个人小结Java 强类型语言； 标识符注意概念 所有标识符都应该以字母，美元符，或者下划线开始； 由字母，美元符，下划线或数字的任意组合； 不能使用关键字作为变量名或方法名； 大小写敏感。 拓展 中文支持 但用起来麻烦 一般不用。不要用拼音； 见名知义。 Java数据类型数据类型 基本类型 引用类型 基本数据类型：数值类型、boolean类型。引用类型： 类、接口、数组。数据类型：整数类型、浮点类型、字符类型。 类型 范围 占用 byte -128 ~ 127 一个字节 short -32768 ~ 32767 2个字节 int -2^31 ~ 2^31-1 4个字节 long 2^63 ~ 2^63-1 8个字节 float 四个字节 double 8个字节 char 2个字节 boolean true或false 一位 使用123456789101112131415161718int num1 = 10;byte num2 = 20;short num3 = 30;long num4 = 30L; //加Lfloat num5 = 30.5F //加Fdouble num6 = 3.14159265358979;char name = &#x27;A&#x27;;//单个字符char namw2 = &#x27;张&#x27;;//布尔值boolean flag = true;//String不是关键字，是一个类String namea = &quot;张三&quot;; 强类型语言 弱类型语言强类型语言要求变量的使用要严格符合规定，变量要求先定义后使用 弱类型语言… 其他字节换算1B(byte 字节) &#x3D; 8bit (位)1字节 &#x3D; 8位 一般表示B byte 字节b bit 位 考试&#x2F;测验整数进制 进制 前缀 二进制 0b 八进制 0 十六进制 0x 十进制 123456int i = 10;int i2 = 010;int i3 = 0x10;//i 10//i2 8//i3 16 浮点数在银行业务里用什么表示钱?答： BigDecimal float 有限 离散 舍入误差 为大约值 接近但不等于尽少使用浮点数去比较 字符char c3 = &#39;\\u0061&#39;Unicode编码“\\u0061”表示字符a … 字符串123456789101112String sa = new String(&quot;Hello World&quot;);String sb = new String(&quot;Hello World&quot;);System.out.println(sa==sb);String sc = &quot;Hello World&quot;;String sd = &quot;Hello World&quot;;System.out.println(sc==sd);//结果为// false// true","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://zswh33.github.io/tags/Java/"}]},{"title":"Day2 Idea使用","slug":"Day2-Idea使用","date":"2022-08-29T14:19:51.000Z","updated":"2022-09-10T03:29:20.674Z","comments":true,"path":"2022/08/29/Day2-Idea使用/","link":"","permalink":"http://zswh33.github.io/2022/08/29/Day2-Idea%E4%BD%BF%E7%94%A8/","excerpt":"","text":"Idea部分使用:Settings中的一些设置在Settings -&gt; Editor下，Font 字体Color Scheme 颜色模板Code Style 代码风格 文档注释示例1234/** * @Des 描述 * @Author 作者 */ 国际化Idea项目的多语言 使用Idea编辑一个多语言文件，可以将文件合并到一个列表里面。 只需要将”_en_US”、”zh_CN”或其他语言简写作为文件的后缀即可实现。 插件：Resource Bundle Editor可以将合并到同一个列表里面的多个文件放到一个页面编辑。","categories":[],"tags":[{"name":"Idea","slug":"Idea","permalink":"http://zswh33.github.io/tags/Idea/"}]},{"title":"Day1 Markdown 学习","slug":"Day1-Markdown-学习","date":"2022-08-29T14:19:29.000Z","updated":"2022-09-11T04:24:46.945Z","comments":true,"path":"2022/08/29/Day1-Markdown-学习/","link":"","permalink":"http://zswh33.github.io/2022/08/29/Day1-Markdown-%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"Markdown 学习简介Markdown 是一种轻量级标记语言，一般用来写文章。 符号||–|–一级标题|#二级标题|##三级标题|###加粗| **内容**斜体| *内容*加粗和斜体| ***内容***链接|[链接名](地址)有序列表| 1. 2. 3.无序列表| - - -表格| 标头1|标头2|标头3 --|--|-- 内容1|内容2|内容3 内容4|内容5|内容6图片| ![图片名](链接)代码| &#96;&#96; &#96;&#96;&#96;&#96;&#96;&#96; 使用基本文字**加粗字体** 加粗字体 *斜体* 斜体 ***加粗和斜体*** 加粗和斜体 [链接名](地址) [uwupu的博客](https://www.cnblogs.com/uwupu/) uwupu的博客 图片![图片名](链接) ![图片名](链接) 表格1234标头1|标头2|标头3--|--|--内容1|内容2|内容3内容4|内容5|内容6 标头1 标头2 标头3 内容1 内容2 内容3 内容4 内容5 内容6 代码12单行代码 `代码内容`多行代码 ```代码内容``` 1`System.out.println(&quot;Hello World&quot;);//单行代码` System.out.println(&quot;Hello World&quot;);//单行代码 1234567```//多行代码public class HelloWorld &#123; public static void main(String[] args) &#123; System.out.println(&quot;Hello World&quot;); &#125;&#125;``` 123456//多行代码public class HelloWorld &#123; public static void main(String[] args) &#123; System.out.println(&quot;Hello World&quot;); &#125;&#125; 注意事项暂无","categories":[],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://zswh33.github.io/tags/Markdown/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-08-28T08:47:13.783Z","updated":"2022-09-27T07:46:21.081Z","comments":true,"path":"2022/08/28/hello-world/","link":"","permalink":"http://zswh33.github.io/2022/08/28/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"jar","slug":"jar","permalink":"http://zswh33.github.io/tags/jar/"},{"name":"java","slug":"java","permalink":"http://zswh33.github.io/tags/java/"},{"name":"加密","slug":"加密","permalink":"http://zswh33.github.io/tags/%E5%8A%A0%E5%AF%86/"},{"name":"Java","slug":"Java","permalink":"http://zswh33.github.io/tags/Java/"},{"name":"Job","slug":"Job","permalink":"http://zswh33.github.io/tags/Job/"},{"name":"openssl","slug":"openssl","permalink":"http://zswh33.github.io/tags/openssl/"},{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"http://zswh33.github.io/tags/RabbitMQ/"},{"name":"Redis","slug":"Redis","permalink":"http://zswh33.github.io/tags/Redis/"},{"name":"算法","slug":"算法","permalink":"http://zswh33.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"Linux","slug":"Linux","permalink":"http://zswh33.github.io/tags/Linux/"},{"name":"Note","slug":"Note","permalink":"http://zswh33.github.io/tags/Note/"},{"name":"Nginx","slug":"Nginx","permalink":"http://zswh33.github.io/tags/Nginx/"},{"name":"openEuler Linux","slug":"openEuler-Linux","permalink":"http://zswh33.github.io/tags/openEuler-Linux/"},{"name":"Java并发","slug":"Java并发","permalink":"http://zswh33.github.io/tags/Java%E5%B9%B6%E5%8F%91/"},{"name":"Effective Java","slug":"Effective-Java","permalink":"http://zswh33.github.io/tags/Effective-Java/"},{"name":"C","slug":"C","permalink":"http://zswh33.github.io/tags/C/"},{"name":"git","slug":"git","permalink":"http://zswh33.github.io/tags/git/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://zswh33.github.io/tags/SpringBoot/"},{"name":"Mysql","slug":"Mysql","permalink":"http://zswh33.github.io/tags/Mysql/"},{"name":"SpringBoot Java","slug":"SpringBoot-Java","permalink":"http://zswh33.github.io/tags/SpringBoot-Java/"},{"name":"SpringBoot Dubbo Zookeeper","slug":"SpringBoot-Dubbo-Zookeeper","permalink":"http://zswh33.github.io/tags/SpringBoot-Dubbo-Zookeeper/"},{"name":"Swagger","slug":"Swagger","permalink":"http://zswh33.github.io/tags/Swagger/"},{"name":"Shiro","slug":"Shiro","permalink":"http://zswh33.github.io/tags/Shiro/"},{"name":"templates","slug":"templates","permalink":"http://zswh33.github.io/tags/templates/"},{"name":"DataStructure","slug":"DataStructure","permalink":"http://zswh33.github.io/tags/DataStructure/"},{"name":"Idea","slug":"Idea","permalink":"http://zswh33.github.io/tags/Idea/"},{"name":"Markdown","slug":"Markdown","permalink":"http://zswh33.github.io/tags/Markdown/"}]}