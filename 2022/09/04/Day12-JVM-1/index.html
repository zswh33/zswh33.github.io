<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Day12 JVM 1 JVM体系结构 类加载器 沙箱安全机制 Native 栈 堆 JProfiler"><meta name="keywords" content="Java"><meta name="author" content="YN"><meta name="copyright" content="YN"><title>Day12 JVM 1 JVM体系结构 类加载器 沙箱安全机制 Native 栈 堆 JProfiler | uwupu Blog</title><link rel="shortcut icon" href="/melody-favicon.ico"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="manifest" href="/manifest.json"><link rel="manifest" href="/manifest.json"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '6.2.0'
} </script><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="uwupu Blog" type="application/atom+xml">
<script>function loadCss(l){var d=document,h=d.head,s=d.createElement('link');s.rel='stylesheet';s.href=l;!function e(f){if (d.body)return f();setTimeout(function(){e(f)})}(function(){h.appendChild(s);});}loadCss('/style.css');loadCss('https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.1');</script><noscript><link rel="stylesheet" href="/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.1"></noscript></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#JVM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">JVM体系结构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">2.</span> <span class="toc-text">类加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E7%B1%BB"><span class="toc-number">2.1.</span> <span class="toc-text">分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E7%B1%BB%EF%BC%8C%E6%9F%A5%E7%9C%8B%E5%85%B6%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">2.2.</span> <span class="toc-text">自定义一个类，查看其加载器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87getParent-%EF%BC%8C%E6%8E%A2%E7%B4%A2%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">2.3.</span> <span class="toc-text">通过getParent()，探索类加载器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="toc-number">2.4.</span> <span class="toc-text">双亲委派机制</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B2%99%E7%AE%B1%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6"><span class="toc-number">3.</span> <span class="toc-text">沙箱安全机制</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Native%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="toc-number">4.</span> <span class="toc-text">Native、方法区</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Native"><span class="toc-number">4.1.</span> <span class="toc-text">Native</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#PC%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">5.</span> <span class="toc-text">PC寄存器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="toc-number">6.</span> <span class="toc-text">方法区</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%88"><span class="toc-number">7.</span> <span class="toc-text">栈</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87main%E6%96%B9%E6%B3%95%E7%90%86%E8%A7%A3%E6%A0%88"><span class="toc-number">7.1.</span> <span class="toc-text">通过main方法理解栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM%E6%A0%88"><span class="toc-number">7.2.</span> <span class="toc-text">JVM栈</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A0%86"><span class="toc-number">8.</span> <span class="toc-text">堆</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E9%87%8C%E9%9D%A2%E6%94%BE%E4%BB%80%E4%B9%88"><span class="toc-number">8.1.</span> <span class="toc-text">堆里面放什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E4%B8%89%E4%B8%AA%E5%8C%BA%E5%9F%9F"><span class="toc-number">8.2.</span> <span class="toc-text">分三个区域</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E7%94%9F%E5%8C%BA"><span class="toc-number">8.2.1.</span> <span class="toc-text">新生区</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Eden"><span class="toc-number">8.2.1.1.</span> <span class="toc-text">Eden</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B8%E5%AD%98%E5%8C%BA"><span class="toc-number">8.2.1.2.</span> <span class="toc-text">幸存区</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B0%B8%E4%B9%85%E5%8C%BA"><span class="toc-number">8.2.2.</span> <span class="toc-text">永久区</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E4%BB%A3%E7%A0%81%E8%A1%A8%E7%8E%B0%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA"><span class="toc-number">8.3.</span> <span class="toc-text">用代码表现内存溢出</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JProfiler%E5%B7%A5%E5%85%B7"><span class="toc-number">9.</span> <span class="toc-text">JProfiler工具</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-number">10.</span> <span class="toc-text">其他</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E7%9A%84%E9%83%A8%E5%88%86%E5%8F%82%E6%95%B0"><span class="toc-number">10.1.</span> <span class="toc-text">Java程序运行的部分参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E4%BB%A3%E7%A0%81%E6%A0%A1%E9%AA%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">10.2.</span> <span class="toc-text">Java代码校验过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E7%9A%84Robot%E7%B1%BB%EF%BC%9Ajava-awt-Robot"><span class="toc-number">10.3.</span> <span class="toc-text">Java的Robot类：java.awt.Robot</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JNI-%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%8E%A5%E5%8F%A3"><span class="toc-number">10.4.</span> <span class="toc-text">JNI 本地方法接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E7%A7%8DJVM"><span class="toc-number">10.5.</span> <span class="toc-text">三种JVM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98"><span class="toc-number">10.6.</span> <span class="toc-text">一些问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9"><span class="toc-number">10.6.1.</span> <span class="toc-text">请谈谈你对</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-number">10.6.2.</span> <span class="toc-text">知识点</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">YN</div><div class="author-info__description text-center">一个包含有学习日记的博客</div><div class="follow-button"><a target="_blank" rel="noopener" href="https://uwupu.tk/">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">101</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">27</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://uwupu.tk/">uwupuBlog</a></div></div></div><div id="content-outer"><div class="plain" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">uwupu Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">诶嘿</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div></div><div class="layout" id="content-inner"><article id="post"><div class="plain" id="post-title">Day12 JVM 1 JVM体系结构 类加载器 沙箱安全机制 Native 栈 堆 JProfiler</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-09-04</time><span class="post-meta__separator">|</span><span class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">5k</span><span class="post-meta__separator">|</span><span>阅读时长: 18 分钟</span></span></div><div class="article-container" id="post-content"><h1 id="JVM体系结构"><a href="#JVM体系结构" class="headerlink" title="JVM体系结构"></a>JVM体系结构</h1><blockquote>
<p>JVM完整架构图</p>
</blockquote>
<img src="/2022/09/04/Day12-JVM-1/JVM架构图.svg" alt="JVM体系结构总图">

<blockquote>
<p>JVM简图</p>
</blockquote>
<img src="/2022/09/04/Day12-JVM-1/image-20220904164709847.png" alt="JVM体系结构简图" style="zoom:80%;">

<p>Java程序执行过程：java文件编编译 —&gt; class字节码文件  —&gt; 类加载器 —&gt; 运行时数据区；</p>
<p>其中：</p>
<ul>
<li><strong>Java栈、本地方法栈和程序计数器</strong>不能进行垃圾回收；</li>
<li><strong>JVM调优</strong>一般指的是调优<strong>方法区</strong>和<strong>堆</strong></li>
</ul>
<h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><p><img src="/2022/09/04/Day12-JVM-1/Class%E5%9C%A8JVM.svg" alt="Class在JVM"></p>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ol>
<li>虚拟机自带的加载器</li>
<li>启动类（根）加载器</li>
<li>扩展类加载器</li>
<li>应用程序加载器</li>
<li>用户自定义类加载器</li>
</ol>
<blockquote>
<p>类加载器加载的文件</p>
</blockquote>
<p>Bootstrap ClassLoader (启动类加载器) ：主要负责加载Java核心类库，目录：/lib下的rt.jar、resources.jar、charsets.jar和class等；</p>
<p>Extention ClassLoader(扩展类加载器)：主要负责加载目录/jre/lib/ext目录下的jar包文件和class文件；</p>
<p>Appliation ClassLoader（应用程序类加载器）：主要负责加载当前应用的classpath下的所有类；</p>
<p>User ClassLoader（用户自定义类加载器）：科技在指定路径的class文件。</p>
<h2 id="自定义一个类，查看其加载器"><a href="#自定义一个类，查看其加载器" class="headerlink" title="自定义一个类，查看其加载器"></a>自定义一个类，查看其加载器</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Student{}"</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        System.out.println(student.getClass().getClassLoader());</span><br><span class="line">        System.out.println(student);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">Student{}</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></tbody></table></figure>

<p>自定义类的类加载器为<code>AppClassLoader</code>应用程序类加载器。</p>
<h2 id="通过getParent-，探索类加载器"><a href="#通过getParent-，探索类加载器" class="headerlink" title="通过getParent()，探索类加载器"></a>通过<code>getParent()</code>，探索类加载器</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoader</span>学习 {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line"></span><br><span class="line">        System.out.println(dog1.hashCode());</span><br><span class="line">        System.out.println(dog2.hashCode());</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 460141958</span></span><br><span class="line"><span class="comment">         * 1163157884</span></span><br><span class="line"><span class="comment">         * 表明 dog1和dog2不是同一个对象</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Class&lt;? <span class="keyword">extends</span> <span class="title class_">Dog</span>&gt; aClass = dog1.getClass();</span><br><span class="line">        Class&lt;? <span class="keyword">extends</span> <span class="title class_">Dog</span>&gt; aClass2 = dog2.getClass();</span><br><span class="line"></span><br><span class="line">        System.out.println(aClass.hashCode());</span><br><span class="line">        System.out.println(aClass2.hashCode());</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1956725890</span></span><br><span class="line"><span class="comment">         * 1956725890</span></span><br><span class="line"><span class="comment">         * 表明aClass和aClass2是同一个对象</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> dog1.getClass().getClassLoader();</span><br><span class="line"></span><br><span class="line">        System.out.println(classLoader);<span class="comment">//AppClassLoader  应用程序类加载器  java.lang.ClassLoader</span></span><br><span class="line">        System.out.println(classLoader.getParent());<span class="comment">//ExtClassLoader  扩展类加载器  \jre\lib\ext</span></span><br><span class="line">        System.out.println(classLoader.getParent().getParent());<span class="comment">//null  rt.jar</span></span><br><span class="line">        <span class="comment">//null   1.  不存在    2. java程序获取不到</span></span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><blockquote>
<p>介绍</p>
</blockquote>
<p>当一个类加载器收到了类加载的请求，它不会直接去加载指定的类， 而是把这个请求委托给自己的父加载器去加载。只有父加载器无法加载这个类的时候，才会由当前这个加载器来负责类的加载。如果都不能加载，就会触发<code>findclass</code>，抛出异常<code>classNotFoundException</code>。</p>
<ol>
<li>类加载器收到类加载请求；</li>
<li>将请求委托给父类加载器去完成；</li>
<li>启动加载器检查是否能够加载当前这个类，能加载则加载，使用当前的加载器；若不能，则通知子加载器去加载这个类；</li>
<li>若都不能加载，则抛出异常<code>classNotFoundException</code>。</li>
</ol>
<p><img src="/2022/09/04/Day12-JVM-1/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6_%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F.svg" alt="双亲委派机制_类加载器执行顺序"></p>
<blockquote>
<p>存在的意义</p>
</blockquote>
<ol>
<li>通过委派的方式，可以避免类的重复加载，当父加载器已经加载过某个类时，子加载器就不会再重新加载这个类；</li>
<li>通过双亲委派的方式，保证了安全性。<code>Bootstrap ClassLoader</code>在加载的时候，只会加载JAVA_HOME中jar包里面的类,如<code>java.lang.Integer</code>，那么这个类是不会被随意替换的，除非有人故意破坏JDK。就可以避免有自人定义一个有破坏功能的<code>java.lang.Integer</code>类被加载。这样可以有效方式核心Java API被篡改。</li>
</ol>
<blockquote>
<p>尝试定义一个String类，并运行使用。</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">String</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 错误: 在类 java.lang.String 中找不到 main 方法, 请将 main 方法定义为:</span></span><br><span class="line"><span class="comment">     *    public static void main(String[] args)</span></span><br><span class="line"><span class="comment">     * 否则 JavaFX 应用程序类必须扩展javafx.application.Application</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当一个类加载器收到了类加载的请求，它不会直接去加载指定的类， 而是把这个请求委托给自己的父加载器去加载。</span></span><br><span class="line"><span class="comment">     * 只有父加载器无法加载这个类的时候，才会由当前这个加载器来负责类的加载。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//双亲委派机制 安全</span></span><br><span class="line">    <span class="comment">//1. Application -&gt; Extention -&gt; Bootstrap</span></span><br><span class="line">    <span class="comment">//执行过程中，依据上面的顺序依次寻找String的类，优先执行BOOT，然后Exc，最后App。</span></span><br><span class="line">    <span class="comment">//由于String在BOOT中找到String的类，所以运行BOOT中的String类；</span></span><br><span class="line">    <span class="comment">//而BOOT中的String类没有main方法，所以出现错误。</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">get</span><span class="params">()</span>{</span><br><span class="line">        <span class="keyword">return</span>  <span class="string">"Hello World"</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>();</span><br><span class="line">        s.get();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">错误: 在类 java.lang.String 中找不到 main 方法, 请将 main 方法定义为:</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">否则 JavaFX 应用程序类必须扩展javafx.application.Application</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p><code>Application</code> -&gt; <code>Extention</code> -&gt; <code>Bootstrap</code></p>
<p>执行过程中，依据上面的顺序依次寻找String的类，优先执行Bootstrap，然后<code>Extention</code>，最后Application。<br>由于String在BOOT中找到String的类，所以运行BOOT中的String类；<br>而BOOT中的String类没有main方法，所以出现错误。</p>
<h1 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h1><p>Java安全模型的核心是<strong>Java沙箱</strong>（sandbox）。</p>
<blockquote>
<p>介绍</p>
</blockquote>
<p>沙箱是一个限制程序运行的环境，沙箱机制就是将Java代码限定在虚拟机（JVM）特定的运行范围中，并且严格限制代码对本地系统资源的访问，通过这样的错误来保证代码的有效隔离，防止对本地系统造成破坏。</p>
<p>Java沙箱<strong>主要限制系统资源访问</strong>。</p>
<blockquote>
<p>历史</p>
</blockquote>
<p>在Java中，执行程序分为<strong>本地代码</strong>和<strong>远程代码</strong>两种。</p>
<p>本地代码默认视为<strong>可信任的</strong>，而远程代码被看做是<strong>不受信任的</strong>。</p>
<ul>
<li>对于<strong>受信任的本地代码</strong>，可以访问一切本地资源；</li>
<li>对于<strong>非授信的远程代码</strong>在早期的Java实现中，安全依赖于<strong>沙箱</strong>（SandBox机制）。</li>
</ul>
<p><strong>Java1.0 安全模型</strong></p>
<p><img src="/2022/09/04/Day12-JVM-1/JDK1.0%E5%AE%89%E5%85%A8%E6%A8%A1%E5%9E%8B.svg" alt="JDK1.0安全模型"></p>
<p><strong>Java 1.1 安全模型</strong></p>
<p><img src="/2022/09/04/Day12-JVM-1/JDK1.1%E5%AE%89%E5%85%A8%E6%A8%A1%E5%9E%8B.svg" alt="JDK1.1安全模型"></p>
<p><strong>Java1.6安全模型 （目前最新的安全模型）</strong></p>
<p><img src="/2022/09/04/Day12-JVM-1/Java1.6%E5%AE%89%E5%85%A8%E6%A8%A1%E5%9E%8B.svg" alt="Java1.6安全模型"></p>
<p>在当前最新的安全机制实现，引入了域（Domain）的概念，虚拟机会把所有代码加载到不同的系统域和应用域；</p>
<p>系统域部分专门负责与关键资源进行交互，各个应用域部分则通过系统域的部分代理来对各种需要的资源进行访问。</p>
<p>虚拟机中不同的受保护域（Protected Domain），对应不一样的权限（Permission）。存在于不同域中的类文件就具有了当前域的全部权限。</p>
<blockquote>
<p>组成沙箱的基本组件</p>
</blockquote>
<ul>
<li><strong>字节码校验器</strong>（bytecode verifier）：确保java类文件遵循java语言规范。但并不是所有的类文件都会经过字节码校验，比如核心类。</li>
<li>类装载器（class loader）：<ul>
<li>防止恶意代码去干涉正常的代码  //双亲委派机制</li>
<li>守护了被信任的类库边界；//双亲委派机制</li>
<li>代码归入保护域，确定了代码可以进行哪些操作。  //沙箱安全机制</li>
</ul>
</li>
</ul>
<blockquote>
<p>类加载器采用双亲委派模式</p>
</blockquote>
<p>通过包区分了访问域，外层恶意的类通过内置代码无法获得权限访问到内置类，破坏代码因此无法生效。</p>
<ul>
<li><p><strong>存取控制器（access controller）</strong>：存取控制器可以控制核心API对操作系统的存取权限，而这个控制的策略设定，可以由用户指定。</p>
</li>
<li><p>**安全管理器(security manager)**：是核心API和操作系统之间的主要接口，实现权限控制，比存取控制器优先级高。</p>
</li>
<li><p><strong>安全软件包（security package）</strong>：java.scurity下的类和扩展包下的类，允许用户为自己的应用增加新的安全特性，包括：</p>
<ul>
<li>安全提供者</li>
<li>消息摘要</li>
<li>数字签名</li>
<li>加密</li>
<li>鉴别</li>
</ul>
</li>
</ul>
<h1 id="Native、方法区"><a href="#Native、方法区" class="headerlink" title="Native、方法区"></a>Native、方法区</h1><blockquote>
<p>Thread.start()简述</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This method is not invoked for the main method thread or "system"</span></span><br><span class="line"><span class="comment">     * group threads created/set up by the VM. Any new functionality added</span></span><br><span class="line"><span class="comment">     * to this method in the future may have to also be added to the VM.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * A zero status value corresponds to state "NEW".</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)<span class="comment">//线程的状态不是启动状态</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalThreadStateException</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Notify the group that this thread is about to be started</span></span><br><span class="line"><span class="comment">     * so that it can be added to the group's list of threads</span></span><br><span class="line"><span class="comment">     * and the group's unstarted count can be decremented. */</span></span><br><span class="line">    group.add(<span class="built_in">this</span>);<span class="comment">//将线程加入线程组</span></span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">started</span> <span class="operator">=</span> <span class="literal">false</span>;<span class="comment">//默认线程未启动</span></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        start0();<span class="comment">//启动线程</span></span><br><span class="line">        started = <span class="literal">true</span>;<span class="comment">//若启动成功，表示没有抛出异常，标志位设true。</span></span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">if</span> (!started) {</span><br><span class="line">                group.threadStartFailed(<span class="built_in">this</span>);<span class="comment">//向group表示线程执行失败</span></span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (Throwable ignore) {</span><br><span class="line">            <span class="comment">/* do nothing. If start0 threw a Throwable then</span></span><br><span class="line"><span class="comment">              it will be passed up the call stack */</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">start0</span><span class="params">()</span>;<span class="comment">//启动线程，是一个本地方法</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="Native"><a href="#Native" class="headerlink" title="Native"></a>Native</h2><p>Java里用native修饰的方法，不在java作用范围内，调用的是底层c语言的库。</p>
<p>使用native修饰的方法，会进入本地方法栈，调用JNI（本地方法接口），JNI调用本地方法库。</p>
<p><strong>JNI本地方法接口</strong>：，扩展Java的使用，融合不同的编程语言为Java所用。（最初是C、C++）</p>
<p><strong>Native Method Stack本地方法栈</strong>：登记Native方法。</p>
<h1 id="PC寄存器"><a href="#PC寄存器" class="headerlink" title="PC寄存器"></a>PC寄存器</h1><p>程序计数器：Program Counter Register</p>
<p>每个线程都有一个程序计数器，是线程私有的，就是一个指针，指向方法区中的方法字节码（用来存储指向一条指令的地址，也是将要执行的指令代码）。</p>
<p>当执行引擎读取下一条指令，PC计数器会+1。</p>
<p>PC寄存器是一个非常小的内存空间。（小到可以忽略不计）</p>
<h1 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h1><p><em>Method Area</em></p>
<p>方法区被所有线程共享。</p>
<p><img src="/2022/09/04/Day12-JVM-1/%E5%8F%98%E9%87%8F%E5%92%8CJVM%E5%AD%98%E5%82%A8.svg" alt="变量和JVM存储"></p>
<p>所有定义的方法的信息都保存在该区域。</p>
<p>属于<strong>共享区间</strong>。</p>
<blockquote>
<p>内容</p>
</blockquote>
<p><strong>静态变量，常量，类信息（构造方法、接口定义），运行时常量池</strong>都在方法区中；</p>
<ul>
<li>static , final , Class ，常量池。</li>
</ul>
<p><strong>实例变量存在于堆内存中</strong>，与方法区无关。</p>
<blockquote>
<p>JVM中内存分析</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JVM</span>内存分配部分 {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">12</span>,<span class="string">"张三"</span>);</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>{</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">"anonymous"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(<span class="type">int</span> age, String name)</span> {</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/2022/09/04/Day12-JVM-1/Java%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E5%9C%A8JVM%E4%B8%AD.svg" alt="Java类与对象在JVM中"></p>
<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p><em>持续学习：程序 = 数据结构 + 算法       饭碗：程序 = 框架 + 业务逻辑</em></p>
<p>栈：先进后出，后进先出。</p>
<p>队列：先进先出。(FIFO：First Input First Output)</p>
<h2 id="通过main方法理解栈"><a href="#通过main方法理解栈" class="headerlink" title="通过main方法理解栈"></a>通过main方法理解栈</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnderstandStackByMainMethod</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        System.out.println(<span class="string">"main start"</span>);</span><br><span class="line">        hello();</span><br><span class="line">        System.out.println(<span class="string">"main stop"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span>{</span><br><span class="line">        System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">main start</span><br><span class="line">hello</span><br><span class="line">main stop</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></tbody></table></figure>

<p>程序运行：main方法开始，然后其他方法，最后main方法结束。</p>
<p><img src="/2022/09/04/Day12-JVM-1/main%E5%BC%80%E5%A7%8B%EF%BC%8Cmain%E7%BB%93%E6%9D%9F.svg" alt="main开始，main结束"></p>
<p>在栈中，main先进入栈，然后是hello()入栈，然后hello()出栈，最后main出栈。</p>
<h2 id="JVM栈"><a href="#JVM栈" class="headerlink" title="JVM栈"></a>JVM栈</h2><p>栈：主管程序的运行，生命周期和线程同步（线程结束 —&gt; 栈内存释放）。因此，对于栈来说，<strong>不存在垃圾回收问题</strong>。</p>
<blockquote>
<p>介绍</p>
</blockquote>
<p><img src="/2022/09/04/Day12-JVM-1/%E6%A0%88%E6%A0%88%E5%B8%A7%E5%92%8C%E6%96%B9%E6%B3%95.svg" alt="栈、栈帧和方法"></p>
<p>JVM栈描述的是每个线程Java方法执行的内存模型：每个方法被执行的时候，<strong>JVM会同步创建一个栈帧</strong>用于存储<strong>局部变量表，操作数栈，动态链接，方法出口</strong>等信息。</p>
<p>栈是运行时单位，堆是存储的单位，即：</p>
<p>栈解决的是运行问题，即程序如何执行，或者如何处理数据。</p>
<p>堆解决的事数据存储问题，即数据怎么放，放哪儿。</p>
<blockquote>
<p>特点</p>
</blockquote>
<ul>
<li>访问速度快，仅次于程序计数器</li>
<li><strong>线程私有</strong></li>
<li>存在OOM，不存在GC</li>
</ul>
<blockquote>
<p>存放类型</p>
</blockquote>
<p>8种数据类型、对象的引用，实例的方法。</p>
<blockquote>
<p>其他</p>
</blockquote>
<ul>
<li><p>Java虚拟机栈是<strong>线程私有</strong>的，<strong>生命周期与线程相同</strong>。（随线程而生，随线程而灭。）</p>
</li>
<li><p>如果线程请求的栈深度大于虚拟机所允许的深度，就会抛出StackOverflowError异常；</p>
</li>
<li><p>若虚拟机栈可以动态扩展，如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。</p>
<p>（当前大部分JVM都可以动态扩展，只不过JVM规范也允许固定长度的虚拟机栈）</p>
</li>
<li><p>Java虚拟机栈描述的是<strong>Java方法执行的内存模型</strong>。</p>
</li>
</ul>
<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><p>Heap，一个JVM只有一个堆内存，堆内存的大小可以调节。</p>
<h2 id="堆里面放什么"><a href="#堆里面放什么" class="headerlink" title="堆里面放什么"></a>堆里面放什么</h2><p>类，方法，常量，变量，保存引用类型的指向类型（真实对象）。</p>
<h2 id="分三个区域"><a href="#分三个区域" class="headerlink" title="分三个区域"></a>分三个区域</h2><p>Java 7及之前堆内存逻辑上分为3个部分：新生区 + 养老区 + 永久区</p>
<p>Java 8及之后堆内存逻辑上分为3个部分：新生区 + 养老区 + 元空间</p>
<ul>
<li>新生区 Young Generation Space   Young/New<ul>
<li>Eden区  伊甸区</li>
<li>Survivor区  幸存区</li>
</ul>
</li>
<li>Tenure generation Space 养老区 Old/Tenure</li>
<li>Permanent Space 永久区 Perm   </li>
<li>Meta Space 元空间 Meta</li>
</ul>
<p><img src="/2022/09/04/Day12-JVM-1/image-20220905184426273.png" alt="JVM堆内存在逻辑上分为"></p>
<p><img src="/2022/09/04/Day12-JVM-1/JVM%E5%A0%86%E5%88%86%E5%8C%BA.svg" alt="JVM堆分区"></p>
<p>GC垃圾回收主要在伊甸园区和老年区。</p>
<p>在JDK8之后，永久存储区改为<strong>元空间</strong>。</p>
<p>若内存满了，会触发OOM：java.lang.OutOfMemoryError: java heap space。</p>
<p>新生区的内存比例： Eden : from : to =  8 : 1 : 1 </p>
<h3 id="新生区"><a href="#新生区" class="headerlink" title="新生区"></a>新生区</h3><h4 id="Eden"><a href="#Eden" class="headerlink" title="Eden"></a>Eden</h4><p>新创建的对象会放在Eden区，每经历一次GC，位于Eden区存活的对象会被移到幸存区的from区。</p>
<h4 id="幸存区"><a href="#幸存区" class="headerlink" title="幸存区"></a>幸存区</h4><ul>
<li>幸存区分为from和to两部分，两部分会互相交换；</li>
<li>分辨from分区和to分区：<strong>一般情况下，空的为to分区。</strong></li>
<li>每次GC，都会把Eden中没有被清理的对象移到幸存区中。</li>
<li>一旦Eden区被GC后，一部分被清理，没有被清理的移到幸存区。</li>
</ul>
<blockquote>
<p>计算过程</p>
</blockquote>
<ul>
<li><p>每个对象都被定义有<strong>寿命</strong>；</p>
</li>
<li><p>当寿命达到指定值，就会被移入老年代；</p>
</li>
</ul>
<h3 id="永久区"><a href="#永久区" class="headerlink" title="永久区"></a>永久区</h3><p>这个区域常驻内存，用来存放JDK自身携带的Class对象。Interface元数据，存储的是Java运行时的一些环境。</p>
<p>这个区域不存在垃圾回收关闭VM虚拟机会释放这个区域的内存。</p>
<blockquote>
<p>永久区满的情况</p>
</blockquote>
<ul>
<li>一个启动类，加载了大量的第三方jar包；</li>
<li>Tomcat部署了太多的应用，或者大量动态生成的反射类。</li>
</ul>
<p>不断地加载，若内存满，就会出现OOM。</p>
<blockquote>
<p>版本历史</p>
</blockquote>
<p>Jdk1.6之前：永久代，常量池在方法区；</p>
<p>Jdk1.7：永久代，但是慢慢退化了，<code>去永久代</code>，常量池在堆中；</p>
<p>jdk1.8之后：无永久代，常量池在元空间。</p>
<h2 id="用代码表现内存溢出"><a href="#用代码表现内存溢出" class="headerlink" title="用代码表现内存溢出"></a>用代码表现内存溢出</h2><p>VM参数：-Xms8M -Xmx8M -XX:+PrintGCDetails</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GetJVMMaxMemoery</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> Runtime.getRuntime().maxMemory();</span><br><span class="line">        <span class="type">long</span> <span class="variable">total</span> <span class="operator">=</span> Runtime.getRuntime().totalMemory();</span><br><span class="line">        System.out.println(<span class="string">"max = "</span>+l/(<span class="type">double</span>)<span class="number">1024</span>/<span class="number">1024</span>+<span class="string">" MB"</span>);</span><br><span class="line">        System.out.println(<span class="string">"total = "</span>+total/(<span class="type">double</span>)<span class="number">1024</span>/<span class="number">1024</span>+<span class="string">" MB"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//溢出用代码</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">"asdqwe"</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>){</span><br><span class="line">            str.append(<span class="string">"qweasdwa"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 1536K-&gt;488K(2048K)] 1536K-&gt;716K(7680K), 0.0007954 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">max = 7.5 MB</span><br><span class="line">total = 7.5 MB</span><br><span class="line">[Full GC (Ergonomics) [PSYoungGen: 1477K-&gt;0K(2048K)] [ParOldGen: 5604K-&gt;3731K(5632K)] 7082K-&gt;3731K(7680K), [Metaspace: 3242K-&gt;3242K(1056768K)], 0.0061693 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(2048K)] 3731K-&gt;3731K(7680K), 0.0004458 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[Full GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(2048K)] [ParOldGen: 3731K-&gt;3713K(5632K)] 3731K-&gt;3713K(7680K), [Metaspace: 3242K-&gt;3242K(1056768K)], 0.0055763 secs] [Times: user=0.06 sys=0.00, real=0.01 secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 2048K, used 75K [0x00000000ffd80000, 0x0000000100000000, 0x0000000100000000)</span><br><span class="line">  eden space 1536K, 4% used [0x00000000ffd80000,0x00000000ffd92f30,0x00000000fff00000)</span><br><span class="line">  from space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000)</span><br><span class="line">  to   space 512K, 0% used [0x00000000fff00000,0x00000000fff00000,0x00000000fff80000)</span><br><span class="line"> ParOldGen       total 5632K, used 3713K [0x00000000ff800000, 0x00000000ffd80000, 0x00000000ffd80000)</span><br><span class="line">  object space 5632K, 65% used [0x00000000ff800000,0x00000000ffba0518,0x00000000ffd80000)</span><br><span class="line"> Metaspace       used 3272K, capacity 4500K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 354K, capacity 388K, committed 512K, reserved 1048576K</span><br><span class="line">Exception in thread "main" java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">	at java.util.Arrays.copyOf(Arrays.java:3332)</span><br><span class="line">	at java.lang.AbstractStringBuilder.ensureCapacityInternal(AbstractStringBuilder.java:124)</span><br><span class="line">	at java.lang.AbstractStringBuilder.append(AbstractStringBuilder.java:448)</span><br><span class="line">	at java.lang.StringBuilder.append(StringBuilder.java:136)</span><br><span class="line">	at com.yn.GetJVMMaxMemoery.main(GetJVMMaxMemoery.java:13)</span><br><span class="line"></span><br><span class="line">Process finished with exit code 1</span><br></pre></td></tr></tbody></table></figure>

<h1 id="JProfiler工具"><a href="#JProfiler工具" class="headerlink" title="JProfiler工具"></a>JProfiler工具</h1><ul>
<li>分许Dump内存文件，快速定位内存泄露。</li>
<li>…</li>
</ul>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="Java程序运行的部分参数"><a href="#Java程序运行的部分参数" class="headerlink" title="Java程序运行的部分参数"></a>Java程序运行的部分参数</h2><ul>
<li><p>-Xms 初始化分配内存大小   -Xms1G、-Xms512M</p>
</li>
<li><p>-Xmx 设置最大分配内存     -Xmx1024M、-Xmx2G</p>
</li>
<li><p>-XX:PrintGCDetails 输出内存分配</p>
</li>
<li><p>-XX:HeapDumpOnOutOfMemoryError 输出栈溢出信息</p>
</li>
<li><p>-XX:MaxTenuringThreshold = 15 通过这个参数可以设定对象经过GC多少次仍然存活后晋升到老年代的<strong>最大</strong>阈值。默认：15。</p>
</li>
</ul>
<h2 id="Java代码校验过程"><a href="#Java代码校验过程" class="headerlink" title="Java代码校验过程"></a>Java代码校验过程</h2><p>java代码首先会经过<strong>编译器校验</strong>，然后在解释器解释前会被<strong>字节码校验器校验</strong>。</p>
<p>对于字节码校验器，运行的代码可能来自本地计算机，也有可能来自远程计算机，本地计算机的代码经过编译器校验，但远程计算机的代码不一定被编译器校验，所以解释前必须经过字节码校验器再次校验。</p>
<blockquote>
<p>来源</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://www.oracle.com/java/technologies/security-in-java.html">https://www.oracle.com/java/technologies/security-in-java.html</a></p>
<p>What about the concept of a “hostile compiler”? Although the Java compiler ensures that Java source code doesn’t violate the safety rules, when an application such as the HotJava Browser imports a code fragment from anywhere, it doesn’t actually know if code fragments follow Java language rules for safety: the code may not have been produced by a known-to-be trustworthy Java compiler. In such a case, how is the Java run-time system on your machine to trust the incoming bytecode stream? The answer is simple: the Java run-time system doesn’t trust the incoming code, but subjects it to <em>bytecode verification</em>.</p>
<p>The tests range from simple verification that the format of a code fragment is correct, to passing each code fragment through a simple theorem prover to establish that it plays by the rules:</p>
<ul>
<li>it doesn’t forge pointers,</li>
<li>it doesn’t violate access restrictions,</li>
<li>it accesses objects as what they are (for example, <code>InputStream</code> objects are always used as <code>InputStream</code>s and never as anything else).</li>
</ul>
<p>A language that is safe, plus run-time verification of generated code, establishes a base set of guarantees that interfaces cannot be violated.</p>
<p><strong>不准确的翻译</strong></p>
<p>“恶意编译器”是什么？即使Java编译器确保Java源代码不会避开安全规则，但当代码片段导入来自像HotJava这样的浏览器，不能保证代码片段在安全上是否遵循Java语言规则：代码可能被不被信任的Java编译器编译。因此，电脑上的Java运行时系统如何相信输入的字节流？答案很简单：Java运行时系统不信任输入的代码，而是把它交给<strong>字节码校验器</strong>。</p>
<p>首先进行简单的代码格式正确性验证，然后每段代码都要通过一个简易的规则检测器，确保符合以下规则：</p>
<ul>
<li>不会伪造指针</li>
<li>不违反访问显示</li>
<li>按原样访问对象（例如InputStream对象仅仅被访问作InputStream而不是其他的东西）</li>
</ul>
<p><strong>个人理解</strong></p>
<p>交给Java解释器的代码，可以来自可信的Java编译器，也有可能来自恶意的Java编译器。为保证安全，在Java解释器之前，字节码校验器会对代码再次（在此之前是Java编译器）进行校验，确保不会有不合适的代码被运行。</p>
<ul>
<li>没有伪造指针</li>
<li>不会违反访问限制</li>
<li>访问对象正确（例如InputStream对象仅仅被访问作InputStream而不是其他的东西）</li>
</ul>
<h2 id="Java的Robot类：java-awt-Robot"><a href="#Java的Robot类：java-awt-Robot" class="headerlink" title="Java的Robot类：java.awt.Robot"></a>Java的Robot类：java.awt.Robot</h2><p>Java中Robot类位于java.awt.Robot，该类用于为测试自动化，自运行演示程序和其他需要控制鼠标和键盘的应用程序生成本机系统输入事件，Robot类的主要目的是便于Java平台实现自动测试。</p>
<h2 id="JNI-本地方法接口"><a href="#JNI-本地方法接口" class="headerlink" title="JNI 本地方法接口"></a>JNI 本地方法接口</h2><p>Java Native Interface</p>
<h2 id="三种JVM"><a href="#三种JVM" class="headerlink" title="三种JVM"></a>三种JVM</h2><ul>
<li>Sun公司 HotSpot <code>Java HotSpot(TM) 64-Bit Server VM (build 25.202-b08, mixed mode)</code></li>
<li>BEA JRockit</li>
<li>IBM J9VM</li>
</ul>
<p>学习用主要是HotSpot</p>
<h2 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h2><h3 id="请谈谈你对"><a href="#请谈谈你对" class="headerlink" title="请谈谈你对"></a>请谈谈你对</h3><blockquote>
<p>core</p>
</blockquote>
<ul>
<li>请你谈谈你对JVM的理解？Java8虚拟机和之前的变化更新？</li>
<li>什么是OOM，什么是栈溢出<code>StackOverFlowError</code>？怎么分析？</li>
<li>JVM的常用调优参数有哪些？</li>
<li>内存快照如何抓取，怎么分析Dump文件？</li>
<li>谈谈JVM中，类加载器的你的认识？</li>
</ul>
<blockquote>
<p>JVM</p>
</blockquote>
<ul>
<li>JVM的内存模型和分区 ，每个区放什么？</li>
<li>堆里面的分区有哪些？Eden、from、to，老年区，说说他们的特点。</li>
<li>GC的算法有哪些？标记清除法，标记整理，复制算法，引用计数器，如何使用？</li>
<li>轻GC 和 重GC 分别在什么时候发生？</li>
</ul>
<h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><p>JVM位置</p>
<p>JVM体系结构</p>
<p>类加载器</p>
<p>双亲委派机制</p>
<p>沙箱安全机制</p>
<p>Native</p>
<p>PC寄存器</p>
<p>方法区</p>
<p>三种JVM</p>
<p>堆</p>
<p>新生区老年区</p>
<p>堆内存调优</p>
<p>GC</p>
<p>​	常用算法</p>
<p>JMM</p>
<p>总结</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">YN</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://zswh33.github.io/2022/09/04/Day12-JVM-1/">http://zswh33.github.io/2022/09/04/Day12-JVM-1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://zswh33.github.io">uwupu Blog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2022/09/06/Day14-JVM-2/"><i class="fa fa-chevron-left">  </i><span>Day14 JVM 2 GC 垃圾回收机制</span></a></div><div class="next-post pull-right"><a href="/2022/09/03/Day11-Multithreading2-10/"><span>Day11 多线程进阶 10 各种锁 排查死锁</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">©2019 - 2023 By YN</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">哇！感谢你来到这个Blog，虽然没有什么内容...嗯..</div><div class="busuanzi"><script async="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/lib/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="/bundle.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>